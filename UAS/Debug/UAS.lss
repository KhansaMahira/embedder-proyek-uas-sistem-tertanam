
UAS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000046c8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000052  00802000  000046c8  0000475c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003e3  00802052  00802052  000047ae  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000047ae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  0000480c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000750  00000000  00000000  00004850  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000164c3  00000000  00000000  00004fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000061e3  00000000  00000000  0001b463  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c0bb  00000000  00000000  00021646  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001918  00000000  00000000  0002d704  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0003c369  00000000  00000000  0002f01c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b3f1  00000000  00000000  0006b385  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000960  00000000  00000000  00076778  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000d388  00000000  00000000  000770d8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 ee 0b 	jmp	0x17dc	; 0x17dc <__vector_13>
      38:	0c 94 4f 12 	jmp	0x249e	; 0x249e <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 50 09 	jmp	0x12a0	; 0x12a0 <__vector_39>
      a0:	0c 94 82 09 	jmp	0x1304	; 0x1304 <__vector_40>
      a4:	0c 94 b4 09 	jmp	0x1368	; 0x1368 <__vector_41>
      a8:	0c 94 e6 09 	jmp	0x13cc	; 0x13cc <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0c 94 15 0c 	jmp	0x182a	; 0x182a <__vector_46>
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	f9 c7       	rjmp	.+4082   	; 0x1110 <__vector_71>
     11e:	00 00       	nop
     120:	0c 94 ba 08 	jmp	0x1174	; 0x1174 <__vector_72>
     124:	0c 94 ec 08 	jmp	0x11d8	; 0x11d8 <__vector_73>
     128:	0c 94 1e 09 	jmp	0x123c	; 0x123c <__vector_74>
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	e2 1a       	sub	r14, r18
     1fe:	e2 1a       	sub	r14, r18
     200:	e2 1a       	sub	r14, r18
     202:	0f 1b       	sub	r16, r31
     204:	17 1b       	sub	r17, r23
     206:	25 1b       	sub	r18, r21
     208:	e2 1a       	sub	r14, r18
     20a:	e2 1a       	sub	r14, r18
     20c:	0f 1b       	sub	r16, r31
     20e:	17 1b       	sub	r17, r23

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1c6b>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x6453>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x642b>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x5453>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1c2b>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e8 ec       	ldi	r30, 0xC8	; 200
     4ba:	f6 e4       	ldi	r31, 0x46	; 70
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a2 35       	cpi	r26, 0x52	; 82
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	24 e2       	ldi	r18, 0x24	; 36
     4ce:	a2 e5       	ldi	r26, 0x52	; 82
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a5 33       	cpi	r26, 0x35	; 53
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <main>
     4e0:	0c 94 62 23 	jmp	0x46c4	; 0x46c4 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
     4e6:	04 c0       	rjmp	.+8      	; 0x4f0 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
     4e8:	61 50       	subi	r22, 0x01	; 1
     4ea:	71 09       	sbc	r23, r1
     4ec:	81 09       	sbc	r24, r1
     4ee:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
     4f0:	61 15       	cp	r22, r1
     4f2:	71 05       	cpc	r23, r1
     4f4:	81 05       	cpc	r24, r1
     4f6:	91 05       	cpc	r25, r1
     4f8:	b9 f7       	brne	.-18     	; 0x4e8 <__portable_avr_delay_cycles+0x2>
     4fa:	08 95       	ret

000004fc <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4fc:	bf 92       	push	r11
     4fe:	cf 92       	push	r12
     500:	df 92       	push	r13
     502:	ef 92       	push	r14
     504:	ff 92       	push	r15
     506:	0f 93       	push	r16
     508:	1f 93       	push	r17
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	1f 92       	push	r1
     510:	cd b7       	in	r28, 0x3d	; 61
     512:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     514:	00 e0       	ldi	r16, 0x00	; 0
     516:	16 e0       	ldi	r17, 0x06	; 6
     518:	68 94       	set
     51a:	ff 24       	eor	r15, r15
     51c:	f3 f8       	bld	r15, 3
     51e:	f8 01       	movw	r30, r16
     520:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     522:	64 e0       	ldi	r22, 0x04	; 4
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	dd df       	rcall	.-70     	; 0x4e6 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     52c:	f8 01       	movw	r30, r16
     52e:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     530:	64 e0       	ldi	r22, 0x04	; 4
     532:	70 e0       	ldi	r23, 0x00	; 0
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	d6 df       	rcall	.-84     	; 0x4e6 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     53a:	0f 2e       	mov	r0, r31
     53c:	fb e2       	ldi	r31, 0x2B	; 43
     53e:	bf 2e       	mov	r11, r31
     540:	f0 2d       	mov	r31, r0
     542:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     544:	80 ea       	ldi	r24, 0xA0	; 160
     546:	99 e0       	ldi	r25, 0x09	; 9
     548:	43 d4       	rcall	.+2182   	; 0xdd0 <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     54a:	c1 2c       	mov	r12, r1
     54c:	d1 2c       	mov	r13, r1
     54e:	76 01       	movw	r14, r12
     550:	00 e4       	ldi	r16, 0x40	; 64
     552:	12 e4       	ldi	r17, 0x42	; 66
     554:	2f e0       	ldi	r18, 0x0F	; 15
     556:	30 e0       	ldi	r19, 0x00	; 0
     558:	43 e0       	ldi	r20, 0x03	; 3
     55a:	be 01       	movw	r22, r28
     55c:	6f 5f       	subi	r22, 0xFF	; 255
     55e:	7f 4f       	sbci	r23, 0xFF	; 255
     560:	80 ea       	ldi	r24, 0xA0	; 160
     562:	99 e0       	ldi	r25, 0x09	; 9
     564:	64 d4       	rcall	.+2248   	; 0xe2e <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     566:	00 e6       	ldi	r16, 0x60	; 96
     568:	16 e0       	ldi	r17, 0x06	; 6
     56a:	ff 24       	eor	r15, r15
     56c:	f3 94       	inc	r15
     56e:	f8 01       	movw	r30, r16
     570:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     572:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     574:	be 01       	movw	r22, r28
     576:	6f 5f       	subi	r22, 0xFF	; 255
     578:	7f 4f       	sbci	r23, 0xFF	; 255
     57a:	80 ea       	ldi	r24, 0xA0	; 160
     57c:	99 e0       	ldi	r25, 0x09	; 9
     57e:	71 d4       	rcall	.+2274   	; 0xe62 <usart_spi_select_device>
     580:	f8 01       	movw	r30, r16
     582:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     584:	e0 ea       	ldi	r30, 0xA0	; 160
     586:	f9 e0       	ldi	r31, 0x09	; 9
     588:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     58a:	85 ff       	sbrs	r24, 5
     58c:	fd cf       	rjmp	.-6      	; 0x588 <st7565r_init+0x8c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     58e:	80 ea       	ldi	r24, 0xA0	; 160
     590:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     594:	e0 ea       	ldi	r30, 0xA0	; 160
     596:	f9 e0       	ldi	r31, 0x09	; 9
     598:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     59a:	86 ff       	sbrs	r24, 6
     59c:	fd cf       	rjmp	.-6      	; 0x598 <st7565r_init+0x9c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     59e:	e0 ea       	ldi	r30, 0xA0	; 160
     5a0:	f9 e0       	ldi	r31, 0x09	; 9
     5a2:	80 e4       	ldi	r24, 0x40	; 64
     5a4:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5a6:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5a8:	be 01       	movw	r22, r28
     5aa:	6f 5f       	subi	r22, 0xFF	; 255
     5ac:	7f 4f       	sbci	r23, 0xFF	; 255
     5ae:	80 ea       	ldi	r24, 0xA0	; 160
     5b0:	99 e0       	ldi	r25, 0x09	; 9
     5b2:	6d d4       	rcall	.+2266   	; 0xe8e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5b4:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5b6:	89 83       	std	Y+1, r24	; 0x01
     5b8:	be 01       	movw	r22, r28
     5ba:	6f 5f       	subi	r22, 0xFF	; 255
     5bc:	7f 4f       	sbci	r23, 0xFF	; 255
     5be:	80 ea       	ldi	r24, 0xA0	; 160
     5c0:	99 e0       	ldi	r25, 0x09	; 9
     5c2:	4f d4       	rcall	.+2206   	; 0xe62 <usart_spi_select_device>
     5c4:	81 e0       	ldi	r24, 0x01	; 1
     5c6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5ca:	e0 ea       	ldi	r30, 0xA0	; 160
     5cc:	f9 e0       	ldi	r31, 0x09	; 9
     5ce:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5d0:	85 ff       	sbrs	r24, 5
     5d2:	fd cf       	rjmp	.-6      	; 0x5ce <st7565r_init+0xd2>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5d4:	86 ea       	ldi	r24, 0xA6	; 166
     5d6:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5da:	e0 ea       	ldi	r30, 0xA0	; 160
     5dc:	f9 e0       	ldi	r31, 0x09	; 9
     5de:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5e0:	86 ff       	sbrs	r24, 6
     5e2:	fd cf       	rjmp	.-6      	; 0x5de <st7565r_init+0xe2>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5e4:	e0 ea       	ldi	r30, 0xA0	; 160
     5e6:	f9 e0       	ldi	r31, 0x09	; 9
     5e8:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ea:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5ec:	80 81       	ld	r24, Z
     5ee:	be 01       	movw	r22, r28
     5f0:	6f 5f       	subi	r22, 0xFF	; 255
     5f2:	7f 4f       	sbci	r23, 0xFF	; 255
     5f4:	80 ea       	ldi	r24, 0xA0	; 160
     5f6:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5f8:	4a d4       	rcall	.+2196   	; 0xe8e <usart_spi_deselect_device>
     5fa:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5fc:	89 83       	std	Y+1, r24	; 0x01
     5fe:	be 01       	movw	r22, r28
     600:	6f 5f       	subi	r22, 0xFF	; 255
     602:	7f 4f       	sbci	r23, 0xFF	; 255
     604:	80 ea       	ldi	r24, 0xA0	; 160
     606:	99 e0       	ldi	r25, 0x09	; 9
     608:	2c d4       	rcall	.+2136   	; 0xe62 <usart_spi_select_device>
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     610:	e0 ea       	ldi	r30, 0xA0	; 160
     612:	f9 e0       	ldi	r31, 0x09	; 9
     614:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     616:	85 ff       	sbrs	r24, 5
     618:	fd cf       	rjmp	.-6      	; 0x614 <st7565r_init+0x118>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     61a:	88 ec       	ldi	r24, 0xC8	; 200
     61c:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     620:	e0 ea       	ldi	r30, 0xA0	; 160
     622:	f9 e0       	ldi	r31, 0x09	; 9
     624:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     626:	86 ff       	sbrs	r24, 6
     628:	fd cf       	rjmp	.-6      	; 0x624 <st7565r_init+0x128>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     62a:	e0 ea       	ldi	r30, 0xA0	; 160
     62c:	f9 e0       	ldi	r31, 0x09	; 9
     62e:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     630:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     632:	80 81       	ld	r24, Z
     634:	be 01       	movw	r22, r28
     636:	6f 5f       	subi	r22, 0xFF	; 255
     638:	7f 4f       	sbci	r23, 0xFF	; 255
     63a:	80 ea       	ldi	r24, 0xA0	; 160
     63c:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     63e:	27 d4       	rcall	.+2126   	; 0xe8e <usart_spi_deselect_device>
     640:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     642:	89 83       	std	Y+1, r24	; 0x01
     644:	be 01       	movw	r22, r28
     646:	6f 5f       	subi	r22, 0xFF	; 255
     648:	7f 4f       	sbci	r23, 0xFF	; 255
     64a:	80 ea       	ldi	r24, 0xA0	; 160
     64c:	99 e0       	ldi	r25, 0x09	; 9
     64e:	09 d4       	rcall	.+2066   	; 0xe62 <usart_spi_select_device>
     650:	81 e0       	ldi	r24, 0x01	; 1
     652:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     656:	e0 ea       	ldi	r30, 0xA0	; 160
     658:	f9 e0       	ldi	r31, 0x09	; 9
     65a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     65c:	85 ff       	sbrs	r24, 5
     65e:	fd cf       	rjmp	.-6      	; 0x65a <st7565r_init+0x15e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     660:	82 ea       	ldi	r24, 0xA2	; 162
     662:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     666:	e0 ea       	ldi	r30, 0xA0	; 160
     668:	f9 e0       	ldi	r31, 0x09	; 9
     66a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     66c:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     66e:	fd cf       	rjmp	.-6      	; 0x66a <st7565r_init+0x16e>
     670:	e0 ea       	ldi	r30, 0xA0	; 160
     672:	f9 e0       	ldi	r31, 0x09	; 9
     674:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     676:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     678:	80 81       	ld	r24, Z
     67a:	be 01       	movw	r22, r28
     67c:	6f 5f       	subi	r22, 0xFF	; 255
     67e:	7f 4f       	sbci	r23, 0xFF	; 255
     680:	80 ea       	ldi	r24, 0xA0	; 160
     682:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     684:	04 d4       	rcall	.+2056   	; 0xe8e <usart_spi_deselect_device>
     686:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     688:	89 83       	std	Y+1, r24	; 0x01
     68a:	be 01       	movw	r22, r28
     68c:	6f 5f       	subi	r22, 0xFF	; 255
     68e:	7f 4f       	sbci	r23, 0xFF	; 255
     690:	80 ea       	ldi	r24, 0xA0	; 160
     692:	99 e0       	ldi	r25, 0x09	; 9
     694:	e6 d3       	rcall	.+1996   	; 0xe62 <usart_spi_select_device>
     696:	81 e0       	ldi	r24, 0x01	; 1
     698:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     69c:	e0 ea       	ldi	r30, 0xA0	; 160
     69e:	f9 e0       	ldi	r31, 0x09	; 9
     6a0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6a2:	85 ff       	sbrs	r24, 5
     6a4:	fd cf       	rjmp	.-6      	; 0x6a0 <st7565r_init+0x1a4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6a6:	8f e2       	ldi	r24, 0x2F	; 47
     6a8:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6ac:	e0 ea       	ldi	r30, 0xA0	; 160
     6ae:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6b0:	81 81       	ldd	r24, Z+1	; 0x01
     6b2:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6b4:	fd cf       	rjmp	.-6      	; 0x6b0 <st7565r_init+0x1b4>
     6b6:	e0 ea       	ldi	r30, 0xA0	; 160
     6b8:	f9 e0       	ldi	r31, 0x09	; 9
     6ba:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6bc:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6be:	80 81       	ld	r24, Z
     6c0:	be 01       	movw	r22, r28
     6c2:	6f 5f       	subi	r22, 0xFF	; 255
     6c4:	7f 4f       	sbci	r23, 0xFF	; 255
     6c6:	80 ea       	ldi	r24, 0xA0	; 160
     6c8:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6ca:	e1 d3       	rcall	.+1986   	; 0xe8e <usart_spi_deselect_device>
     6cc:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6ce:	89 83       	std	Y+1, r24	; 0x01
     6d0:	be 01       	movw	r22, r28
     6d2:	6f 5f       	subi	r22, 0xFF	; 255
     6d4:	7f 4f       	sbci	r23, 0xFF	; 255
     6d6:	80 ea       	ldi	r24, 0xA0	; 160
     6d8:	99 e0       	ldi	r25, 0x09	; 9
     6da:	c3 d3       	rcall	.+1926   	; 0xe62 <usart_spi_select_device>
     6dc:	81 e0       	ldi	r24, 0x01	; 1
     6de:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6e2:	e0 ea       	ldi	r30, 0xA0	; 160
     6e4:	f9 e0       	ldi	r31, 0x09	; 9
     6e6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6e8:	85 ff       	sbrs	r24, 5
     6ea:	fd cf       	rjmp	.-6      	; 0x6e6 <st7565r_init+0x1ea>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6ec:	88 ef       	ldi	r24, 0xF8	; 248
     6ee:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6f2:	e0 ea       	ldi	r30, 0xA0	; 160
     6f4:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6f6:	81 81       	ldd	r24, Z+1	; 0x01
     6f8:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6fa:	fd cf       	rjmp	.-6      	; 0x6f6 <st7565r_init+0x1fa>
     6fc:	e0 ea       	ldi	r30, 0xA0	; 160
     6fe:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     700:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     702:	81 83       	std	Z+1, r24	; 0x01
     704:	80 81       	ld	r24, Z
     706:	be 01       	movw	r22, r28
     708:	6f 5f       	subi	r22, 0xFF	; 255
     70a:	7f 4f       	sbci	r23, 0xFF	; 255
     70c:	80 ea       	ldi	r24, 0xA0	; 160
     70e:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     710:	be d3       	rcall	.+1916   	; 0xe8e <usart_spi_deselect_device>
     712:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     714:	89 83       	std	Y+1, r24	; 0x01
     716:	be 01       	movw	r22, r28
     718:	6f 5f       	subi	r22, 0xFF	; 255
     71a:	7f 4f       	sbci	r23, 0xFF	; 255
     71c:	80 ea       	ldi	r24, 0xA0	; 160
     71e:	99 e0       	ldi	r25, 0x09	; 9
     720:	a0 d3       	rcall	.+1856   	; 0xe62 <usart_spi_select_device>
     722:	81 e0       	ldi	r24, 0x01	; 1
     724:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     728:	e0 ea       	ldi	r30, 0xA0	; 160
     72a:	f9 e0       	ldi	r31, 0x09	; 9
     72c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     72e:	85 ff       	sbrs	r24, 5
     730:	fd cf       	rjmp	.-6      	; 0x72c <st7565r_init+0x230>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     732:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     736:	e0 ea       	ldi	r30, 0xA0	; 160
     738:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     73a:	81 81       	ldd	r24, Z+1	; 0x01
     73c:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     73e:	fd cf       	rjmp	.-6      	; 0x73a <st7565r_init+0x23e>
     740:	e0 ea       	ldi	r30, 0xA0	; 160
     742:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     744:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     746:	81 83       	std	Z+1, r24	; 0x01
     748:	80 81       	ld	r24, Z
     74a:	be 01       	movw	r22, r28
     74c:	6f 5f       	subi	r22, 0xFF	; 255
     74e:	7f 4f       	sbci	r23, 0xFF	; 255
     750:	80 ea       	ldi	r24, 0xA0	; 160
     752:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     754:	9c d3       	rcall	.+1848   	; 0xe8e <usart_spi_deselect_device>
     756:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     758:	89 83       	std	Y+1, r24	; 0x01
     75a:	be 01       	movw	r22, r28
     75c:	6f 5f       	subi	r22, 0xFF	; 255
     75e:	7f 4f       	sbci	r23, 0xFF	; 255
     760:	80 ea       	ldi	r24, 0xA0	; 160
     762:	99 e0       	ldi	r25, 0x09	; 9
     764:	7e d3       	rcall	.+1788   	; 0xe62 <usart_spi_select_device>
     766:	81 e0       	ldi	r24, 0x01	; 1
     768:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     76c:	e0 ea       	ldi	r30, 0xA0	; 160
     76e:	f9 e0       	ldi	r31, 0x09	; 9
     770:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     772:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     774:	fd cf       	rjmp	.-6      	; 0x770 <st7565r_init+0x274>
     776:	81 e2       	ldi	r24, 0x21	; 33
     778:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     77c:	e0 ea       	ldi	r30, 0xA0	; 160
     77e:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     780:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     782:	86 ff       	sbrs	r24, 6
     784:	fd cf       	rjmp	.-6      	; 0x780 <st7565r_init+0x284>
     786:	e0 ea       	ldi	r30, 0xA0	; 160
     788:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     78a:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     78c:	81 83       	std	Z+1, r24	; 0x01
     78e:	80 81       	ld	r24, Z
     790:	be 01       	movw	r22, r28
     792:	6f 5f       	subi	r22, 0xFF	; 255
     794:	7f 4f       	sbci	r23, 0xFF	; 255
     796:	80 ea       	ldi	r24, 0xA0	; 160
     798:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     79a:	79 d3       	rcall	.+1778   	; 0xe8e <usart_spi_deselect_device>
     79c:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     79e:	89 83       	std	Y+1, r24	; 0x01
     7a0:	be 01       	movw	r22, r28
     7a2:	6f 5f       	subi	r22, 0xFF	; 255
     7a4:	7f 4f       	sbci	r23, 0xFF	; 255
     7a6:	80 ea       	ldi	r24, 0xA0	; 160
     7a8:	99 e0       	ldi	r25, 0x09	; 9
     7aa:	5b d3       	rcall	.+1718   	; 0xe62 <usart_spi_select_device>
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7b2:	e0 ea       	ldi	r30, 0xA0	; 160
     7b4:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7b6:	81 81       	ldd	r24, Z+1	; 0x01
     7b8:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7ba:	fd cf       	rjmp	.-6      	; 0x7b6 <st7565r_init+0x2ba>
     7bc:	81 e8       	ldi	r24, 0x81	; 129
     7be:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7c2:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7c4:	f9 e0       	ldi	r31, 0x09	; 9
     7c6:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7c8:	86 ff       	sbrs	r24, 6
     7ca:	fd cf       	rjmp	.-6      	; 0x7c6 <st7565r_init+0x2ca>
     7cc:	e0 ea       	ldi	r30, 0xA0	; 160
     7ce:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7d0:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7d2:	81 83       	std	Z+1, r24	; 0x01
     7d4:	80 81       	ld	r24, Z
     7d6:	be 01       	movw	r22, r28
     7d8:	6f 5f       	subi	r22, 0xFF	; 255
     7da:	7f 4f       	sbci	r23, 0xFF	; 255
     7dc:	80 ea       	ldi	r24, 0xA0	; 160
     7de:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7e0:	56 d3       	rcall	.+1708   	; 0xe8e <usart_spi_deselect_device>
     7e2:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7e4:	89 83       	std	Y+1, r24	; 0x01
     7e6:	be 01       	movw	r22, r28
     7e8:	6f 5f       	subi	r22, 0xFF	; 255
     7ea:	7f 4f       	sbci	r23, 0xFF	; 255
     7ec:	80 ea       	ldi	r24, 0xA0	; 160
     7ee:	99 e0       	ldi	r25, 0x09	; 9
     7f0:	38 d3       	rcall	.+1648   	; 0xe62 <usart_spi_select_device>
     7f2:	81 e0       	ldi	r24, 0x01	; 1
     7f4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7f8:	e0 ea       	ldi	r30, 0xA0	; 160
     7fa:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7fc:	81 81       	ldd	r24, Z+1	; 0x01
     7fe:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     800:	fd cf       	rjmp	.-6      	; 0x7fc <st7565r_init+0x300>
     802:	81 e2       	ldi	r24, 0x21	; 33
     804:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     808:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     80a:	f9 e0       	ldi	r31, 0x09	; 9
     80c:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     80e:	86 ff       	sbrs	r24, 6
     810:	fd cf       	rjmp	.-6      	; 0x80c <st7565r_init+0x310>
     812:	e0 ea       	ldi	r30, 0xA0	; 160
     814:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     816:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     818:	81 83       	std	Z+1, r24	; 0x01
     81a:	80 81       	ld	r24, Z
     81c:	be 01       	movw	r22, r28
     81e:	6f 5f       	subi	r22, 0xFF	; 255
     820:	7f 4f       	sbci	r23, 0xFF	; 255
     822:	80 ea       	ldi	r24, 0xA0	; 160
     824:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     826:	33 d3       	rcall	.+1638   	; 0xe8e <usart_spi_deselect_device>
     828:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     82a:	89 83       	std	Y+1, r24	; 0x01
     82c:	be 01       	movw	r22, r28
     82e:	6f 5f       	subi	r22, 0xFF	; 255
     830:	7f 4f       	sbci	r23, 0xFF	; 255
     832:	80 ea       	ldi	r24, 0xA0	; 160
     834:	99 e0       	ldi	r25, 0x09	; 9
     836:	15 d3       	rcall	.+1578   	; 0xe62 <usart_spi_select_device>
     838:	81 e0       	ldi	r24, 0x01	; 1
     83a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     83e:	e0 ea       	ldi	r30, 0xA0	; 160
     840:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     842:	81 81       	ldd	r24, Z+1	; 0x01
     844:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     846:	fd cf       	rjmp	.-6      	; 0x842 <st7565r_init+0x346>
     848:	8f ea       	ldi	r24, 0xAF	; 175
     84a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     84e:	e0 ea       	ldi	r30, 0xA0	; 160
     850:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     852:	81 81       	ldd	r24, Z+1	; 0x01
     854:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     856:	fd cf       	rjmp	.-6      	; 0x852 <st7565r_init+0x356>
     858:	e0 ea       	ldi	r30, 0xA0	; 160
     85a:	f9 e0       	ldi	r31, 0x09	; 9
     85c:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     85e:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     860:	80 81       	ld	r24, Z
     862:	be 01       	movw	r22, r28
     864:	6f 5f       	subi	r22, 0xFF	; 255
     866:	7f 4f       	sbci	r23, 0xFF	; 255
     868:	80 ea       	ldi	r24, 0xA0	; 160
     86a:	99 e0       	ldi	r25, 0x09	; 9
     86c:	10 d3       	rcall	.+1568   	; 0xe8e <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     86e:	0f 90       	pop	r0
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	1f 91       	pop	r17
     876:	0f 91       	pop	r16
     878:	ff 90       	pop	r15
     87a:	ef 90       	pop	r14
     87c:	df 90       	pop	r13
     87e:	cf 90       	pop	r12
     880:	bf 90       	pop	r11
     882:	08 95       	ret

00000884 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
     884:	8f ef       	ldi	r24, 0xFF	; 255
     886:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
     88a:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
     88e:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
     892:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
     896:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
     89a:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
     89e:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>
     8a2:	08 95       	ret

000008a4 <sysclk_enable_module>:
	sysclk_rtcsrc_enable(CONFIG_RTC_SOURCE);
#endif
}

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	1f 92       	push	r1
     8aa:	cd b7       	in	r28, 0x3d	; 61
     8ac:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     8ae:	9f b7       	in	r25, 0x3f	; 63
     8b0:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
     8b2:	f8 94       	cli
	return flags;
     8b4:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     8b6:	e8 2f       	mov	r30, r24
     8b8:	f0 e0       	ldi	r31, 0x00	; 0
     8ba:	e0 59       	subi	r30, 0x90	; 144
     8bc:	ff 4f       	sbci	r31, 0xFF	; 255
     8be:	60 95       	com	r22
     8c0:	80 81       	ld	r24, Z
     8c2:	68 23       	and	r22, r24
     8c4:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     8c6:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
     8c8:	0f 90       	pop	r0
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <sysclk_disable_module>:

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	1f 92       	push	r1
     8d6:	cd b7       	in	r28, 0x3d	; 61
     8d8:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     8da:	9f b7       	in	r25, 0x3f	; 63
     8dc:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
     8de:	f8 94       	cli
	return flags;
     8e0:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     8e2:	e8 2f       	mov	r30, r24
     8e4:	f0 e0       	ldi	r31, 0x00	; 0
     8e6:	e0 59       	subi	r30, 0x90	; 144
     8e8:	ff 4f       	sbci	r31, 0xFF	; 255
     8ea:	80 81       	ld	r24, Z
     8ec:	68 2b       	or	r22, r24
     8ee:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     8f0:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
     8f2:	0f 90       	pop	r0
     8f4:	df 91       	pop	r29
     8f6:	cf 91       	pop	r28
     8f8:	08 95       	ret

000008fa <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     8fa:	ff 92       	push	r15
     8fc:	0f 93       	push	r16
     8fe:	1f 93       	push	r17
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	1f 92       	push	r1
     906:	cd b7       	in	r28, 0x3d	; 61
     908:	de b7       	in	r29, 0x3e	; 62
     90a:	08 2f       	mov	r16, r24
     90c:	f6 2e       	mov	r15, r22
     90e:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     910:	1a d1       	rcall	.+564    	; 0xb46 <gfx_mono_framebuffer_put_byte>
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     912:	0f 70       	andi	r16, 0x0F	; 15
     914:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     916:	8b e2       	ldi	r24, 0x2B	; 43
     918:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     91a:	be 01       	movw	r22, r28
     91c:	6f 5f       	subi	r22, 0xFF	; 255
     91e:	7f 4f       	sbci	r23, 0xFF	; 255
     920:	80 ea       	ldi	r24, 0xA0	; 160
     922:	99 e0       	ldi	r25, 0x09	; 9
     924:	9e d2       	rcall	.+1340   	; 0xe62 <usart_spi_select_device>
     926:	81 e0       	ldi	r24, 0x01	; 1
     928:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     92c:	e0 ea       	ldi	r30, 0xA0	; 160
     92e:	f9 e0       	ldi	r31, 0x09	; 9
     930:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     932:	95 ff       	sbrs	r25, 5
     934:	fd cf       	rjmp	.-6      	; 0x930 <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     936:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     93a:	e0 ea       	ldi	r30, 0xA0	; 160
     93c:	f9 e0       	ldi	r31, 0x09	; 9
     93e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     940:	86 ff       	sbrs	r24, 6
     942:	fd cf       	rjmp	.-6      	; 0x93e <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     944:	e0 ea       	ldi	r30, 0xA0	; 160
     946:	f9 e0       	ldi	r31, 0x09	; 9
     948:	80 e4       	ldi	r24, 0x40	; 64
     94a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     94c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     94e:	be 01       	movw	r22, r28
     950:	6f 5f       	subi	r22, 0xFF	; 255
     952:	7f 4f       	sbci	r23, 0xFF	; 255
     954:	80 ea       	ldi	r24, 0xA0	; 160
     956:	99 e0       	ldi	r25, 0x09	; 9
     958:	9a d2       	rcall	.+1332   	; 0xe8e <usart_spi_deselect_device>
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     95a:	0f 2d       	mov	r16, r15
     95c:	0f 77       	andi	r16, 0x7F	; 127
     95e:	02 95       	swap	r16
     960:	0f 70       	andi	r16, 0x0F	; 15
     962:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     964:	8b e2       	ldi	r24, 0x2B	; 43
     966:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     968:	be 01       	movw	r22, r28
     96a:	6f 5f       	subi	r22, 0xFF	; 255
     96c:	7f 4f       	sbci	r23, 0xFF	; 255
     96e:	80 ea       	ldi	r24, 0xA0	; 160
     970:	99 e0       	ldi	r25, 0x09	; 9
     972:	77 d2       	rcall	.+1262   	; 0xe62 <usart_spi_select_device>
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     97a:	e0 ea       	ldi	r30, 0xA0	; 160
     97c:	f9 e0       	ldi	r31, 0x09	; 9
     97e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     980:	85 ff       	sbrs	r24, 5
     982:	fd cf       	rjmp	.-6      	; 0x97e <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     984:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     988:	e0 ea       	ldi	r30, 0xA0	; 160
     98a:	f9 e0       	ldi	r31, 0x09	; 9
     98c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     98e:	86 ff       	sbrs	r24, 6
     990:	fd cf       	rjmp	.-6      	; 0x98c <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     992:	e0 ea       	ldi	r30, 0xA0	; 160
     994:	f9 e0       	ldi	r31, 0x09	; 9
     996:	80 e4       	ldi	r24, 0x40	; 64
     998:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     99a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     99c:	be 01       	movw	r22, r28
     99e:	6f 5f       	subi	r22, 0xFF	; 255
     9a0:	7f 4f       	sbci	r23, 0xFF	; 255
     9a2:	80 ea       	ldi	r24, 0xA0	; 160
     9a4:	99 e0       	ldi	r25, 0x09	; 9
     9a6:	73 d2       	rcall	.+1254   	; 0xe8e <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     9a8:	0f 2d       	mov	r16, r15
     9aa:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9ac:	8b e2       	ldi	r24, 0x2B	; 43
     9ae:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9b0:	be 01       	movw	r22, r28
     9b2:	6f 5f       	subi	r22, 0xFF	; 255
     9b4:	7f 4f       	sbci	r23, 0xFF	; 255
     9b6:	80 ea       	ldi	r24, 0xA0	; 160
     9b8:	99 e0       	ldi	r25, 0x09	; 9
     9ba:	53 d2       	rcall	.+1190   	; 0xe62 <usart_spi_select_device>
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9c2:	e0 ea       	ldi	r30, 0xA0	; 160
     9c4:	f9 e0       	ldi	r31, 0x09	; 9
     9c6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9c8:	85 ff       	sbrs	r24, 5
     9ca:	fd cf       	rjmp	.-6      	; 0x9c6 <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9cc:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9d0:	e0 ea       	ldi	r30, 0xA0	; 160
     9d2:	f9 e0       	ldi	r31, 0x09	; 9
     9d4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9d6:	86 ff       	sbrs	r24, 6
     9d8:	fd cf       	rjmp	.-6      	; 0x9d4 <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9da:	e0 ea       	ldi	r30, 0xA0	; 160
     9dc:	f9 e0       	ldi	r31, 0x09	; 9
     9de:	80 e4       	ldi	r24, 0x40	; 64
     9e0:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9e2:	80 81       	ld	r24, Z
     9e4:	be 01       	movw	r22, r28
     9e6:	6f 5f       	subi	r22, 0xFF	; 255
     9e8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ea:	80 ea       	ldi	r24, 0xA0	; 160
     9ec:	99 e0       	ldi	r25, 0x09	; 9
     9ee:	4f d2       	rcall	.+1182   	; 0xe8e <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9f0:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9f2:	89 83       	std	Y+1, r24	; 0x01
     9f4:	be 01       	movw	r22, r28
     9f6:	6f 5f       	subi	r22, 0xFF	; 255
     9f8:	7f 4f       	sbci	r23, 0xFF	; 255
     9fa:	80 ea       	ldi	r24, 0xA0	; 160
     9fc:	99 e0       	ldi	r25, 0x09	; 9
     9fe:	31 d2       	rcall	.+1122   	; 0xe62 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a06:	e0 ea       	ldi	r30, 0xA0	; 160
     a08:	f9 e0       	ldi	r31, 0x09	; 9
     a0a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a0c:	85 ff       	sbrs	r24, 5
     a0e:	fd cf       	rjmp	.-6      	; 0xa0a <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a10:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a14:	e0 ea       	ldi	r30, 0xA0	; 160
     a16:	f9 e0       	ldi	r31, 0x09	; 9
     a18:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a1a:	86 ff       	sbrs	r24, 6
     a1c:	fd cf       	rjmp	.-6      	; 0xa18 <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a1e:	e0 ea       	ldi	r30, 0xA0	; 160
     a20:	f9 e0       	ldi	r31, 0x09	; 9
     a22:	80 e4       	ldi	r24, 0x40	; 64
     a24:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a26:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     a28:	81 e0       	ldi	r24, 0x01	; 1
     a2a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a2e:	be 01       	movw	r22, r28
     a30:	6f 5f       	subi	r22, 0xFF	; 255
     a32:	7f 4f       	sbci	r23, 0xFF	; 255
     a34:	80 ea       	ldi	r24, 0xA0	; 160
     a36:	99 e0       	ldi	r25, 0x09	; 9
     a38:	2a d2       	rcall	.+1108   	; 0xe8e <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     a3a:	0f 90       	pop	r0
     a3c:	df 91       	pop	r29
     a3e:	cf 91       	pop	r28
     a40:	1f 91       	pop	r17
     a42:	0f 91       	pop	r16
     a44:	ff 90       	pop	r15
     a46:	08 95       	ret

00000a48 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	cf 93       	push	r28
     a4e:	df 93       	push	r29
     a50:	1f 92       	push	r1
     a52:	cd b7       	in	r28, 0x3d	; 61
     a54:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a56:	82 e5       	ldi	r24, 0x52	; 82
     a58:	90 e2       	ldi	r25, 0x20	; 32
     a5a:	70 d0       	rcall	.+224    	; 0xb3c <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a5c:	4f dd       	rcall	.-1378   	; 0x4fc <st7565r_init>
     a5e:	8b e2       	ldi	r24, 0x2B	; 43
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a60:	89 83       	std	Y+1, r24	; 0x01
     a62:	be 01       	movw	r22, r28
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a64:	6f 5f       	subi	r22, 0xFF	; 255
     a66:	7f 4f       	sbci	r23, 0xFF	; 255
     a68:	80 ea       	ldi	r24, 0xA0	; 160
     a6a:	99 e0       	ldi	r25, 0x09	; 9
     a6c:	fa d1       	rcall	.+1012   	; 0xe62 <usart_spi_select_device>
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     a74:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a76:	f9 e0       	ldi	r31, 0x09	; 9
     a78:	81 81       	ldd	r24, Z+1	; 0x01
     a7a:	85 ff       	sbrs	r24, 5
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a7c:	fd cf       	rjmp	.-6      	; 0xa78 <gfx_mono_st7565r_init+0x30>
     a7e:	80 e4       	ldi	r24, 0x40	; 64
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a80:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     a84:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a86:	f9 e0       	ldi	r31, 0x09	; 9
     a88:	81 81       	ldd	r24, Z+1	; 0x01
     a8a:	86 ff       	sbrs	r24, 6
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a8c:	fd cf       	rjmp	.-6      	; 0xa88 <gfx_mono_st7565r_init+0x40>
     a8e:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a90:	f9 e0       	ldi	r31, 0x09	; 9
     a92:	80 e4       	ldi	r24, 0x40	; 64
     a94:	81 83       	std	Z+1, r24	; 0x01
     a96:	80 81       	ld	r24, Z
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a98:	be 01       	movw	r22, r28
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a9a:	6f 5f       	subi	r22, 0xFF	; 255
     a9c:	7f 4f       	sbci	r23, 0xFF	; 255
     a9e:	80 ea       	ldi	r24, 0xA0	; 160
     aa0:	99 e0       	ldi	r25, 0x09	; 9
     aa2:	f5 d1       	rcall	.+1002   	; 0xe8e <usart_spi_deselect_device>
     aa4:	00 e0       	ldi	r16, 0x00	; 0

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     aa6:	0a c0       	rjmp	.+20     	; 0xabc <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     aa8:	40 e0       	ldi	r20, 0x00	; 0
     aaa:	61 2f       	mov	r22, r17
     aac:	80 2f       	mov	r24, r16
     aae:	25 df       	rcall	.-438    	; 0x8fa <gfx_mono_st7565r_put_byte>
     ab0:	1f 5f       	subi	r17, 0xFF	; 255
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     ab2:	10 38       	cpi	r17, 0x80	; 128
     ab4:	c9 f7       	brne	.-14     	; 0xaa8 <gfx_mono_st7565r_init+0x60>
     ab6:	0f 5f       	subi	r16, 0xFF	; 255

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     ab8:	04 30       	cpi	r16, 0x04	; 4
     aba:	11 f0       	breq	.+4      	; 0xac0 <gfx_mono_st7565r_init+0x78>
     abc:	10 e0       	ldi	r17, 0x00	; 0
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     abe:	f4 cf       	rjmp	.-24     	; 0xaa8 <gfx_mono_st7565r_init+0x60>
     ac0:	0f 90       	pop	r0
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	1f 91       	pop	r17
     ac8:	0f 91       	pop	r16
     aca:	08 95       	ret

00000acc <gfx_mono_st7565r_draw_pixel>:
     acc:	ff 92       	push	r15
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     ace:	0f 93       	push	r16
     ad0:	1f 93       	push	r17
     ad2:	cf 93       	push	r28
     ad4:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     ad6:	88 23       	and	r24, r24
     ad8:	4c f1       	brlt	.+82     	; 0xb2c <gfx_mono_st7565r_draw_pixel+0x60>
     ada:	60 32       	cpi	r22, 0x20	; 32
     adc:	38 f5       	brcc	.+78     	; 0xb2c <gfx_mono_st7565r_draw_pixel+0x60>
     ade:	d4 2f       	mov	r29, r20
     ae0:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     ae2:	f6 2e       	mov	r15, r22
     ae4:	f6 94       	lsr	r15
     ae6:	f6 94       	lsr	r15
     ae8:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     aea:	70 e0       	ldi	r23, 0x00	; 0
     aec:	88 e0       	ldi	r24, 0x08	; 8
     aee:	f8 9e       	mul	r15, r24
     af0:	60 19       	sub	r22, r0
     af2:	71 09       	sbc	r23, r1
     af4:	11 24       	eor	r1, r1
     af6:	81 e0       	ldi	r24, 0x01	; 1
     af8:	90 e0       	ldi	r25, 0x00	; 0
     afa:	8c 01       	movw	r16, r24
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <gfx_mono_st7565r_draw_pixel+0x36>
     afe:	00 0f       	add	r16, r16
     b00:	11 1f       	adc	r17, r17
     b02:	6a 95       	dec	r22
     b04:	e2 f7       	brpl	.-8      	; 0xafe <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     b06:	6c 2f       	mov	r22, r28
     b08:	8f 2d       	mov	r24, r15
     b0a:	2b d0       	rcall	.+86     	; 0xb62 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     b0c:	d1 30       	cpi	r29, 0x01	; 1
     b0e:	21 f0       	breq	.+8      	; 0xb18 <gfx_mono_st7565r_draw_pixel+0x4c>
     b10:	28 f0       	brcs	.+10     	; 0xb1c <gfx_mono_st7565r_draw_pixel+0x50>
     b12:	d2 30       	cpi	r29, 0x02	; 2
     b14:	31 f0       	breq	.+12     	; 0xb22 <gfx_mono_st7565r_draw_pixel+0x56>
     b16:	06 c0       	rjmp	.+12     	; 0xb24 <gfx_mono_st7565r_draw_pixel+0x58>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     b18:	80 2b       	or	r24, r16
		break;
     b1a:	04 c0       	rjmp	.+8      	; 0xb24 <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     b1c:	00 95       	com	r16
     b1e:	80 23       	and	r24, r16
		break;
     b20:	01 c0       	rjmp	.+2      	; 0xb24 <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     b22:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     b24:	48 2f       	mov	r20, r24
     b26:	6c 2f       	mov	r22, r28
     b28:	8f 2d       	mov	r24, r15
     b2a:	e7 de       	rcall	.-562    	; 0x8fa <gfx_mono_st7565r_put_byte>
}
     b2c:	df 91       	pop	r29
     b2e:	cf 91       	pop	r28
     b30:	1f 91       	pop	r17
     b32:	0f 91       	pop	r16
     b34:	ff 90       	pop	r15
     b36:	08 95       	ret

00000b38 <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     b38:	14 c0       	rjmp	.+40     	; 0xb62 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     b3a:	08 95       	ret

00000b3c <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     b3c:	80 93 52 22 	sts	0x2252, r24	; 0x802252 <fbpointer>
     b40:	90 93 53 22 	sts	0x2253, r25	; 0x802253 <fbpointer+0x1>
     b44:	08 95       	ret

00000b46 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     b46:	20 91 52 22 	lds	r18, 0x2252	; 0x802252 <fbpointer>
     b4a:	30 91 53 22 	lds	r19, 0x2253	; 0x802253 <fbpointer+0x1>
     b4e:	90 e8       	ldi	r25, 0x80	; 128
     b50:	89 9f       	mul	r24, r25
     b52:	20 0d       	add	r18, r0
     b54:	31 1d       	adc	r19, r1
     b56:	11 24       	eor	r1, r1
     b58:	f9 01       	movw	r30, r18
     b5a:	e6 0f       	add	r30, r22
     b5c:	f1 1d       	adc	r31, r1
     b5e:	40 83       	st	Z, r20
     b60:	08 95       	ret

00000b62 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     b62:	20 91 52 22 	lds	r18, 0x2252	; 0x802252 <fbpointer>
     b66:	30 91 53 22 	lds	r19, 0x2253	; 0x802253 <fbpointer+0x1>
     b6a:	90 e8       	ldi	r25, 0x80	; 128
     b6c:	89 9f       	mul	r24, r25
     b6e:	20 0d       	add	r18, r0
     b70:	31 1d       	adc	r19, r1
     b72:	11 24       	eor	r1, r1
     b74:	f9 01       	movw	r30, r18
     b76:	e6 0f       	add	r30, r22
     b78:	f1 1d       	adc	r31, r1
}
     b7a:	80 81       	ld	r24, Z
     b7c:	08 95       	ret

00000b7e <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b7e:	ff 92       	push	r15
     b80:	0f 93       	push	r16
     b82:	1f 93       	push	r17
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	e4 2f       	mov	r30, r20
     b8a:	f0 e0       	ldi	r31, 0x00	; 0
     b8c:	e8 0f       	add	r30, r24
     b8e:	f1 1d       	adc	r31, r1
     b90:	e1 38       	cpi	r30, 0x81	; 129
     b92:	f1 05       	cpc	r31, r1
     b94:	1c f0       	brlt	.+6      	; 0xb9c <gfx_mono_generic_draw_horizontal_line+0x1e>
     b96:	c0 e8       	ldi	r28, 0x80	; 128
     b98:	4c 2f       	mov	r20, r28
     b9a:	48 1b       	sub	r20, r24
     b9c:	44 23       	and	r20, r20
     b9e:	09 f4       	brne	.+2      	; 0xba2 <gfx_mono_generic_draw_horizontal_line+0x24>
     ba0:	4a c0       	rjmp	.+148    	; 0xc36 <gfx_mono_generic_draw_horizontal_line+0xb8>
     ba2:	d6 2f       	mov	r29, r22
     ba4:	d6 95       	lsr	r29
     ba6:	d6 95       	lsr	r29
     ba8:	d6 95       	lsr	r29
     baa:	70 e0       	ldi	r23, 0x00	; 0
     bac:	98 e0       	ldi	r25, 0x08	; 8
     bae:	d9 9f       	mul	r29, r25
     bb0:	60 19       	sub	r22, r0
     bb2:	71 09       	sbc	r23, r1
     bb4:	11 24       	eor	r1, r1
     bb6:	e1 e0       	ldi	r30, 0x01	; 1
     bb8:	f0 e0       	ldi	r31, 0x00	; 0
     bba:	df 01       	movw	r26, r30
     bbc:	02 c0       	rjmp	.+4      	; 0xbc2 <gfx_mono_generic_draw_horizontal_line+0x44>
     bbe:	aa 0f       	add	r26, r26
     bc0:	bb 1f       	adc	r27, r27
     bc2:	6a 95       	dec	r22
     bc4:	e2 f7       	brpl	.-8      	; 0xbbe <gfx_mono_generic_draw_horizontal_line+0x40>
     bc6:	fa 2e       	mov	r15, r26
     bc8:	21 30       	cpi	r18, 0x01	; 1
     bca:	21 f0       	breq	.+8      	; 0xbd4 <gfx_mono_generic_draw_horizontal_line+0x56>
     bcc:	98 f0       	brcs	.+38     	; 0xbf4 <gfx_mono_generic_draw_horizontal_line+0x76>
     bce:	22 30       	cpi	r18, 0x02	; 2
     bd0:	19 f1       	breq	.+70     	; 0xc18 <gfx_mono_generic_draw_horizontal_line+0x9a>
     bd2:	31 c0       	rjmp	.+98     	; 0xc36 <gfx_mono_generic_draw_horizontal_line+0xb8>
     bd4:	c4 2f       	mov	r28, r20
     bd6:	1f ef       	ldi	r17, 0xFF	; 255
     bd8:	18 0f       	add	r17, r24
     bda:	01 2f       	mov	r16, r17
     bdc:	0c 0f       	add	r16, r28
     bde:	60 2f       	mov	r22, r16
     be0:	8d 2f       	mov	r24, r29
     be2:	aa df       	rcall	.-172    	; 0xb38 <gfx_mono_st7565r_get_byte>
     be4:	4f 2d       	mov	r20, r15
     be6:	48 2b       	or	r20, r24
     be8:	60 2f       	mov	r22, r16
     bea:	8d 2f       	mov	r24, r29
     bec:	86 de       	rcall	.-756    	; 0x8fa <gfx_mono_st7565r_put_byte>
     bee:	c1 50       	subi	r28, 0x01	; 1
     bf0:	a1 f7       	brne	.-24     	; 0xbda <gfx_mono_generic_draw_horizontal_line+0x5c>
     bf2:	21 c0       	rjmp	.+66     	; 0xc36 <gfx_mono_generic_draw_horizontal_line+0xb8>
     bf4:	c4 2f       	mov	r28, r20
     bf6:	1f ef       	ldi	r17, 0xFF	; 255
     bf8:	18 0f       	add	r17, r24
     bfa:	fa 2e       	mov	r15, r26
     bfc:	f0 94       	com	r15
     bfe:	01 2f       	mov	r16, r17
     c00:	0c 0f       	add	r16, r28
     c02:	60 2f       	mov	r22, r16
     c04:	8d 2f       	mov	r24, r29
     c06:	98 df       	rcall	.-208    	; 0xb38 <gfx_mono_st7565r_get_byte>
     c08:	4f 2d       	mov	r20, r15
     c0a:	48 23       	and	r20, r24
     c0c:	60 2f       	mov	r22, r16
     c0e:	8d 2f       	mov	r24, r29
     c10:	74 de       	rcall	.-792    	; 0x8fa <gfx_mono_st7565r_put_byte>
     c12:	c1 50       	subi	r28, 0x01	; 1
     c14:	a1 f7       	brne	.-24     	; 0xbfe <gfx_mono_generic_draw_horizontal_line+0x80>
     c16:	0f c0       	rjmp	.+30     	; 0xc36 <gfx_mono_generic_draw_horizontal_line+0xb8>
     c18:	c4 2f       	mov	r28, r20
     c1a:	1f ef       	ldi	r17, 0xFF	; 255
     c1c:	18 0f       	add	r17, r24
     c1e:	01 2f       	mov	r16, r17
     c20:	0c 0f       	add	r16, r28
     c22:	60 2f       	mov	r22, r16
     c24:	8d 2f       	mov	r24, r29
     c26:	88 df       	rcall	.-240    	; 0xb38 <gfx_mono_st7565r_get_byte>
     c28:	4f 2d       	mov	r20, r15
     c2a:	48 27       	eor	r20, r24
     c2c:	60 2f       	mov	r22, r16
     c2e:	8d 2f       	mov	r24, r29
     c30:	64 de       	rcall	.-824    	; 0x8fa <gfx_mono_st7565r_put_byte>
     c32:	c1 50       	subi	r28, 0x01	; 1
     c34:	a1 f7       	brne	.-24     	; 0xc1e <gfx_mono_generic_draw_horizontal_line+0xa0>
     c36:	df 91       	pop	r29
     c38:	cf 91       	pop	r28
     c3a:	1f 91       	pop	r17
     c3c:	0f 91       	pop	r16
     c3e:	ff 90       	pop	r15
     c40:	08 95       	ret

00000c42 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     c42:	ff 92       	push	r15
     c44:	0f 93       	push	r16
     c46:	1f 93       	push	r17
     c48:	cf 93       	push	r28
     c4a:	df 93       	push	r29
	if (height == 0) {
     c4c:	22 23       	and	r18, r18
     c4e:	69 f0       	breq	.+26     	; 0xc6a <gfx_mono_generic_draw_filled_rect+0x28>
     c50:	f4 2e       	mov	r15, r20
     c52:	18 2f       	mov	r17, r24
     c54:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c56:	df ef       	ldi	r29, 0xFF	; 255
     c58:	d6 0f       	add	r29, r22
     c5a:	6d 2f       	mov	r22, r29
     c5c:	6c 0f       	add	r22, r28
     c5e:	20 2f       	mov	r18, r16
     c60:	4f 2d       	mov	r20, r15
     c62:	81 2f       	mov	r24, r17
     c64:	8c df       	rcall	.-232    	; 0xb7e <gfx_mono_generic_draw_horizontal_line>
     c66:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c68:	c1 f7       	brne	.-16     	; 0xc5a <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	1f 91       	pop	r17
     c70:	0f 91       	pop	r16
     c72:	ff 90       	pop	r15
     c74:	08 95       	ret

00000c76 <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c76:	af 92       	push	r10
     c78:	bf 92       	push	r11
     c7a:	cf 92       	push	r12
     c7c:	df 92       	push	r13
     c7e:	ef 92       	push	r14
     c80:	ff 92       	push	r15
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
     c8a:	c8 2f       	mov	r28, r24
     c8c:	e6 2e       	mov	r14, r22
     c8e:	b4 2e       	mov	r11, r20
     c90:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c92:	00 e0       	ldi	r16, 0x00	; 0
     c94:	f9 01       	movw	r30, r18
     c96:	24 81       	ldd	r18, Z+4	; 0x04
     c98:	43 81       	ldd	r20, Z+3	; 0x03
     c9a:	6b 2d       	mov	r22, r11
     c9c:	8e 2d       	mov	r24, r14
     c9e:	d1 df       	rcall	.-94     	; 0xc42 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     ca0:	f6 01       	movw	r30, r12
     ca2:	80 81       	ld	r24, Z
     ca4:	81 11       	cpse	r24, r1
     ca6:	39 c0       	rjmp	.+114    	; 0xd1a <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     ca8:	83 81       	ldd	r24, Z+3	; 0x03
     caa:	28 2f       	mov	r18, r24
     cac:	26 95       	lsr	r18
     cae:	26 95       	lsr	r18
     cb0:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     cb2:	87 70       	andi	r24, 0x07	; 7
     cb4:	09 f0       	breq	.+2      	; 0xcb8 <gfx_mono_draw_char+0x42>
		char_row_size++;
     cb6:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     cb8:	f6 01       	movw	r30, r12
     cba:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     cbc:	8c 2f       	mov	r24, r28
     cbe:	90 e0       	ldi	r25, 0x00	; 0
     cc0:	35 81       	ldd	r19, Z+5	; 0x05
     cc2:	83 1b       	sub	r24, r19
     cc4:	91 09       	sbc	r25, r1
     cc6:	2a 9d       	mul	r18, r10
     cc8:	90 01       	movw	r18, r0
     cca:	11 24       	eor	r1, r1
     ccc:	82 9f       	mul	r24, r18
     cce:	a0 01       	movw	r20, r0
     cd0:	83 9f       	mul	r24, r19
     cd2:	50 0d       	add	r21, r0
     cd4:	92 9f       	mul	r25, r18
     cd6:	50 0d       	add	r21, r0
     cd8:	11 24       	eor	r1, r1
     cda:	01 81       	ldd	r16, Z+1	; 0x01
     cdc:	12 81       	ldd	r17, Z+2	; 0x02
     cde:	04 0f       	add	r16, r20
     ce0:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     ce2:	f6 01       	movw	r30, r12
     ce4:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     ce6:	ff 20       	and	r15, r15
     ce8:	a1 f0       	breq	.+40     	; 0xd12 <gfx_mono_draw_char+0x9c>
     cea:	d0 e0       	ldi	r29, 0x00	; 0
     cec:	c0 e0       	ldi	r28, 0x00	; 0
     cee:	8e 2d       	mov	r24, r14
     cf0:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     cf2:	9c 2f       	mov	r25, r28
     cf4:	97 70       	andi	r25, 0x07	; 7
     cf6:	21 f4       	brne	.+8      	; 0xd00 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     cf8:	f8 01       	movw	r30, r16
     cfa:	d4 91       	lpm	r29, Z
				glyph_data++;
     cfc:	0f 5f       	subi	r16, 0xFF	; 255
     cfe:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     d00:	dd 23       	and	r29, r29
     d02:	1c f4       	brge	.+6      	; 0xd0a <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     d04:	41 e0       	ldi	r20, 0x01	; 1
     d06:	6b 2d       	mov	r22, r11
     d08:	e1 de       	rcall	.-574    	; 0xacc <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     d0a:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     d0c:	cf 5f       	subi	r28, 0xFF	; 255
     d0e:	fc 12       	cpse	r15, r28
     d10:	ee cf       	rjmp	.-36     	; 0xcee <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     d12:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     d14:	aa 94       	dec	r10
	} while (rows_left > 0);
     d16:	a1 10       	cpse	r10, r1
     d18:	e4 cf       	rjmp	.-56     	; 0xce2 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     d1a:	df 91       	pop	r29
     d1c:	cf 91       	pop	r28
     d1e:	1f 91       	pop	r17
     d20:	0f 91       	pop	r16
     d22:	ff 90       	pop	r15
     d24:	ef 90       	pop	r14
     d26:	df 90       	pop	r13
     d28:	cf 90       	pop	r12
     d2a:	bf 90       	pop	r11
     d2c:	af 90       	pop	r10
     d2e:	08 95       	ret

00000d30 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     d30:	df 92       	push	r13
     d32:	ef 92       	push	r14
     d34:	ff 92       	push	r15
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	cf 93       	push	r28
     d3c:	df 93       	push	r29
     d3e:	d6 2e       	mov	r13, r22
     d40:	04 2f       	mov	r16, r20
     d42:	79 01       	movw	r14, r18
     d44:	ec 01       	movw	r28, r24
     d46:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     d48:	89 91       	ld	r24, Y+
     d4a:	8a 30       	cpi	r24, 0x0A	; 10
     d4c:	31 f4       	brne	.+12     	; 0xd5a <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
     d4e:	f7 01       	movw	r30, r14
     d50:	84 81       	ldd	r24, Z+4	; 0x04
     d52:	8f 5f       	subi	r24, 0xFF	; 255
     d54:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     d56:	1d 2d       	mov	r17, r13
     d58:	09 c0       	rjmp	.+18     	; 0xd6c <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d5a:	8d 30       	cpi	r24, 0x0D	; 13
     d5c:	39 f0       	breq	.+14     	; 0xd6c <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d5e:	97 01       	movw	r18, r14
     d60:	40 2f       	mov	r20, r16
     d62:	61 2f       	mov	r22, r17
     d64:	88 df       	rcall	.-240    	; 0xc76 <gfx_mono_draw_char>
			x += font->width;
     d66:	f7 01       	movw	r30, r14
     d68:	83 81       	ldd	r24, Z+3	; 0x03
     d6a:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     d6c:	88 81       	ld	r24, Y
     d6e:	81 11       	cpse	r24, r1
     d70:	eb cf       	rjmp	.-42     	; 0xd48 <gfx_mono_draw_string+0x18>
}
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	1f 91       	pop	r17
     d78:	0f 91       	pop	r16
     d7a:	ff 90       	pop	r15
     d7c:	ef 90       	pop	r14
     d7e:	df 90       	pop	r13
     d80:	08 95       	ret

00000d82 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
     d82:	cf 93       	push	r28
     d84:	df 93       	push	r29
     d86:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
     d88:	20 e0       	ldi	r18, 0x00	; 0
     d8a:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
     d8c:	c6 2f       	mov	r28, r22
     d8e:	d0 e0       	ldi	r29, 0x00	; 0
     d90:	de 01       	movw	r26, r28
     d92:	02 2e       	mov	r0, r18
     d94:	02 c0       	rjmp	.+4      	; 0xd9a <ioport_configure_port_pin+0x18>
     d96:	b5 95       	asr	r27
     d98:	a7 95       	ror	r26
     d9a:	0a 94       	dec	r0
     d9c:	e2 f7       	brpl	.-8      	; 0xd96 <ioport_configure_port_pin+0x14>
     d9e:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
     da0:	50 8b       	std	Z+16, r21	; 0x10
     da2:	2f 5f       	subi	r18, 0xFF	; 255
     da4:	3f 4f       	sbci	r19, 0xFF	; 255
     da6:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
     da8:	28 30       	cpi	r18, 0x08	; 8
     daa:	31 05       	cpc	r19, r1
     dac:	89 f7       	brne	.-30     	; 0xd90 <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
     dae:	40 ff       	sbrs	r20, 0
     db0:	0a c0       	rjmp	.+20     	; 0xdc6 <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
     db2:	41 ff       	sbrs	r20, 1
     db4:	03 c0       	rjmp	.+6      	; 0xdbc <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
     db6:	fc 01       	movw	r30, r24
     db8:	65 83       	std	Z+5, r22	; 0x05
     dba:	02 c0       	rjmp	.+4      	; 0xdc0 <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
     dbc:	fc 01       	movw	r30, r24
     dbe:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
     dc0:	fc 01       	movw	r30, r24
     dc2:	61 83       	std	Z+1, r22	; 0x01
     dc4:	02 c0       	rjmp	.+4      	; 0xdca <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
     dc6:	fc 01       	movw	r30, r24
     dc8:	62 83       	std	Z+2, r22	; 0x02
	}
}
     dca:	df 91       	pop	r29
     dcc:	cf 91       	pop	r28
     dce:	08 95       	ret

00000dd0 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     dd0:	80 3a       	cpi	r24, 0xA0	; 160
     dd2:	28 e0       	ldi	r18, 0x08	; 8
     dd4:	92 07       	cpc	r25, r18
     dd6:	21 f4       	brne	.+8      	; 0xde0 <usart_spi_init+0x10>
     dd8:	60 e1       	ldi	r22, 0x10	; 16
     dda:	83 e0       	ldi	r24, 0x03	; 3
     ddc:	63 cd       	rjmp	.-1338   	; 0x8a4 <sysclk_enable_module>
     dde:	08 95       	ret
     de0:	80 3b       	cpi	r24, 0xB0	; 176
     de2:	28 e0       	ldi	r18, 0x08	; 8
     de4:	92 07       	cpc	r25, r18
     de6:	21 f4       	brne	.+8      	; 0xdf0 <usart_spi_init+0x20>
     de8:	60 e2       	ldi	r22, 0x20	; 32
     dea:	83 e0       	ldi	r24, 0x03	; 3
     dec:	5b cd       	rjmp	.-1354   	; 0x8a4 <sysclk_enable_module>
     dee:	08 95       	ret
     df0:	80 3a       	cpi	r24, 0xA0	; 160
     df2:	29 e0       	ldi	r18, 0x09	; 9
     df4:	92 07       	cpc	r25, r18
     df6:	21 f4       	brne	.+8      	; 0xe00 <usart_spi_init+0x30>
     df8:	60 e1       	ldi	r22, 0x10	; 16
     dfa:	84 e0       	ldi	r24, 0x04	; 4
     dfc:	53 cd       	rjmp	.-1370   	; 0x8a4 <sysclk_enable_module>
     dfe:	08 95       	ret
     e00:	80 3b       	cpi	r24, 0xB0	; 176
     e02:	29 e0       	ldi	r18, 0x09	; 9
     e04:	92 07       	cpc	r25, r18
     e06:	21 f4       	brne	.+8      	; 0xe10 <usart_spi_init+0x40>
     e08:	60 e2       	ldi	r22, 0x20	; 32
     e0a:	84 e0       	ldi	r24, 0x04	; 4
     e0c:	4b cd       	rjmp	.-1386   	; 0x8a4 <sysclk_enable_module>
     e0e:	08 95       	ret
     e10:	80 3a       	cpi	r24, 0xA0	; 160
     e12:	2a e0       	ldi	r18, 0x0A	; 10
     e14:	92 07       	cpc	r25, r18
     e16:	21 f4       	brne	.+8      	; 0xe20 <usart_spi_init+0x50>
     e18:	60 e1       	ldi	r22, 0x10	; 16
     e1a:	85 e0       	ldi	r24, 0x05	; 5
     e1c:	43 cd       	rjmp	.-1402   	; 0x8a4 <sysclk_enable_module>
     e1e:	08 95       	ret
     e20:	80 3a       	cpi	r24, 0xA0	; 160
     e22:	9b 40       	sbci	r25, 0x0B	; 11
     e24:	19 f4       	brne	.+6      	; 0xe2c <usart_spi_init+0x5c>
     e26:	60 e1       	ldi	r22, 0x10	; 16
     e28:	86 e0       	ldi	r24, 0x06	; 6
     e2a:	3c cd       	rjmp	.-1416   	; 0x8a4 <sysclk_enable_module>
     e2c:	08 95       	ret

00000e2e <usart_spi_setup_device>:
     e2e:	0f 93       	push	r16
     e30:	1f 93       	push	r17
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	00 d0       	rcall	.+0      	; 0xe38 <usart_spi_setup_device+0xa>
     e38:	00 d0       	rcall	.+0      	; 0xe3a <usart_spi_setup_device+0xc>
     e3a:	cd b7       	in	r28, 0x3d	; 61
     e3c:	de b7       	in	r29, 0x3e	; 62
     e3e:	09 83       	std	Y+1, r16	; 0x01
     e40:	1a 83       	std	Y+2, r17	; 0x02
     e42:	2b 83       	std	Y+3, r18	; 0x03
     e44:	3c 83       	std	Y+4, r19	; 0x04
     e46:	4d 83       	std	Y+5, r20	; 0x05
     e48:	1e 82       	std	Y+6, r1	; 0x06
     e4a:	be 01       	movw	r22, r28
     e4c:	6f 5f       	subi	r22, 0xFF	; 255
     e4e:	7f 4f       	sbci	r23, 0xFF	; 255
     e50:	86 d7       	rcall	.+3852   	; 0x1d5e <usart_init_spi>
     e52:	26 96       	adiw	r28, 0x06	; 6
     e54:	cd bf       	out	0x3d, r28	; 61
     e56:	de bf       	out	0x3e, r29	; 62
     e58:	df 91       	pop	r29
     e5a:	cf 91       	pop	r28
     e5c:	1f 91       	pop	r17
     e5e:	0f 91       	pop	r16
     e60:	08 95       	ret

00000e62 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     e62:	fb 01       	movw	r30, r22
     e64:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e66:	e8 2f       	mov	r30, r24
     e68:	e6 95       	lsr	r30
     e6a:	e6 95       	lsr	r30
     e6c:	e6 95       	lsr	r30
     e6e:	40 e2       	ldi	r20, 0x20	; 32
     e70:	e4 9f       	mul	r30, r20
     e72:	f0 01       	movw	r30, r0
     e74:	11 24       	eor	r1, r1
     e76:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     e78:	87 70       	andi	r24, 0x07	; 7
     e7a:	21 e0       	ldi	r18, 0x01	; 1
     e7c:	30 e0       	ldi	r19, 0x00	; 0
     e7e:	a9 01       	movw	r20, r18
     e80:	02 c0       	rjmp	.+4      	; 0xe86 <usart_spi_select_device+0x24>
     e82:	44 0f       	add	r20, r20
     e84:	55 1f       	adc	r21, r21
     e86:	8a 95       	dec	r24
     e88:	e2 f7       	brpl	.-8      	; 0xe82 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     e8a:	46 83       	std	Z+6, r20	; 0x06
     e8c:	08 95       	ret

00000e8e <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     e8e:	fb 01       	movw	r30, r22
     e90:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e92:	e8 2f       	mov	r30, r24
     e94:	e6 95       	lsr	r30
     e96:	e6 95       	lsr	r30
     e98:	e6 95       	lsr	r30
     e9a:	40 e2       	ldi	r20, 0x20	; 32
     e9c:	e4 9f       	mul	r30, r20
     e9e:	f0 01       	movw	r30, r0
     ea0:	11 24       	eor	r1, r1
     ea2:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     ea4:	87 70       	andi	r24, 0x07	; 7
     ea6:	21 e0       	ldi	r18, 0x01	; 1
     ea8:	30 e0       	ldi	r19, 0x00	; 0
     eaa:	a9 01       	movw	r20, r18
     eac:	02 c0       	rjmp	.+4      	; 0xeb2 <usart_spi_deselect_device+0x24>
     eae:	44 0f       	add	r20, r20
     eb0:	55 1f       	adc	r21, r21
     eb2:	8a 95       	dec	r24
     eb4:	e2 f7       	brpl	.-8      	; 0xeae <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     eb6:	45 83       	std	Z+5, r20	; 0x05
     eb8:	08 95       	ret

00000eba <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
     eba:	43 e0       	ldi	r20, 0x03	; 3
     ebc:	50 e0       	ldi	r21, 0x00	; 0
     ebe:	61 e0       	ldi	r22, 0x01	; 1
     ec0:	80 ee       	ldi	r24, 0xE0	; 224
     ec2:	97 e0       	ldi	r25, 0x07	; 7
     ec4:	5e df       	rcall	.-324    	; 0xd82 <ioport_configure_port_pin>
     ec6:	43 e0       	ldi	r20, 0x03	; 3
     ec8:	50 e0       	ldi	r21, 0x00	; 0
     eca:	62 e0       	ldi	r22, 0x02	; 2
     ecc:	80 ee       	ldi	r24, 0xE0	; 224
     ece:	97 e0       	ldi	r25, 0x07	; 7
     ed0:	58 df       	rcall	.-336    	; 0xd82 <ioport_configure_port_pin>
     ed2:	43 e0       	ldi	r20, 0x03	; 3
     ed4:	50 e0       	ldi	r21, 0x00	; 0
     ed6:	60 e1       	ldi	r22, 0x10	; 16
     ed8:	80 e6       	ldi	r24, 0x60	; 96
     eda:	96 e0       	ldi	r25, 0x06	; 6
     edc:	52 df       	rcall	.-348    	; 0xd82 <ioport_configure_port_pin>
     ede:	41 e0       	ldi	r20, 0x01	; 1
     ee0:	50 e4       	ldi	r21, 0x40	; 64
     ee2:	60 e2       	ldi	r22, 0x20	; 32
     ee4:	80 e6       	ldi	r24, 0x60	; 96
     ee6:	96 e0       	ldi	r25, 0x06	; 6
     ee8:	4c df       	rcall	.-360    	; 0xd82 <ioport_configure_port_pin>
     eea:	40 e0       	ldi	r20, 0x00	; 0
     eec:	5b e1       	ldi	r21, 0x1B	; 27
     eee:	60 e2       	ldi	r22, 0x20	; 32
     ef0:	80 e8       	ldi	r24, 0x80	; 128
     ef2:	96 e0       	ldi	r25, 0x06	; 6
     ef4:	46 df       	rcall	.-372    	; 0xd82 <ioport_configure_port_pin>
     ef6:	40 e0       	ldi	r20, 0x00	; 0
     ef8:	5b e1       	ldi	r21, 0x1B	; 27
     efa:	62 e0       	ldi	r22, 0x02	; 2
     efc:	80 ea       	ldi	r24, 0xA0	; 160
     efe:	96 e0       	ldi	r25, 0x06	; 6
     f00:	40 df       	rcall	.-384    	; 0xd82 <ioport_configure_port_pin>
     f02:	40 e0       	ldi	r20, 0x00	; 0
     f04:	5b e1       	ldi	r21, 0x1B	; 27
     f06:	64 e0       	ldi	r22, 0x04	; 4
     f08:	80 ea       	ldi	r24, 0xA0	; 160
     f0a:	96 e0       	ldi	r25, 0x06	; 6
     f0c:	3a df       	rcall	.-396    	; 0xd82 <ioport_configure_port_pin>
     f0e:	43 e0       	ldi	r20, 0x03	; 3
     f10:	50 e0       	ldi	r21, 0x00	; 0
     f12:	62 e0       	ldi	r22, 0x02	; 2
     f14:	80 e6       	ldi	r24, 0x60	; 96
     f16:	96 e0       	ldi	r25, 0x06	; 6
     f18:	34 df       	rcall	.-408    	; 0xd82 <ioport_configure_port_pin>
     f1a:	43 e0       	ldi	r20, 0x03	; 3
     f1c:	50 e0       	ldi	r21, 0x00	; 0
     f1e:	68 e0       	ldi	r22, 0x08	; 8
     f20:	80 e6       	ldi	r24, 0x60	; 96
     f22:	96 e0       	ldi	r25, 0x06	; 6
     f24:	2e df       	rcall	.-420    	; 0xd82 <ioport_configure_port_pin>
     f26:	43 e0       	ldi	r20, 0x03	; 3
     f28:	50 e0       	ldi	r21, 0x00	; 0
     f2a:	68 e0       	ldi	r22, 0x08	; 8
     f2c:	80 ea       	ldi	r24, 0xA0	; 160
     f2e:	96 e0       	ldi	r25, 0x06	; 6
     f30:	28 df       	rcall	.-432    	; 0xd82 <ioport_configure_port_pin>
     f32:	43 e0       	ldi	r20, 0x03	; 3
     f34:	50 e0       	ldi	r21, 0x00	; 0
     f36:	61 e0       	ldi	r22, 0x01	; 1
     f38:	80 e6       	ldi	r24, 0x60	; 96
     f3a:	96 e0       	ldi	r25, 0x06	; 6
     f3c:	22 df       	rcall	.-444    	; 0xd82 <ioport_configure_port_pin>
     f3e:	43 e0       	ldi	r20, 0x03	; 3
     f40:	50 e0       	ldi	r21, 0x00	; 0
     f42:	68 e0       	ldi	r22, 0x08	; 8
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	96 e0       	ldi	r25, 0x06	; 6
     f48:	1c df       	rcall	.-456    	; 0xd82 <ioport_configure_port_pin>
     f4a:	41 e0       	ldi	r20, 0x01	; 1
     f4c:	50 e0       	ldi	r21, 0x00	; 0
     f4e:	60 e1       	ldi	r22, 0x10	; 16
     f50:	80 e8       	ldi	r24, 0x80	; 128
     f52:	96 e0       	ldi	r25, 0x06	; 6
     f54:	16 df       	rcall	.-468    	; 0xd82 <ioport_configure_port_pin>
     f56:	43 e0       	ldi	r20, 0x03	; 3
     f58:	50 e0       	ldi	r21, 0x00	; 0
     f5a:	62 e0       	ldi	r22, 0x02	; 2
     f5c:	80 e6       	ldi	r24, 0x60	; 96
     f5e:	96 e0       	ldi	r25, 0x06	; 6
     f60:	10 df       	rcall	.-480    	; 0xd82 <ioport_configure_port_pin>
     f62:	43 e0       	ldi	r20, 0x03	; 3
     f64:	50 e0       	ldi	r21, 0x00	; 0
     f66:	68 e0       	ldi	r22, 0x08	; 8
     f68:	80 e6       	ldi	r24, 0x60	; 96
     f6a:	96 e0       	ldi	r25, 0x06	; 6
     f6c:	0a df       	rcall	.-492    	; 0xd82 <ioport_configure_port_pin>
     f6e:	40 e0       	ldi	r20, 0x00	; 0
     f70:	50 e0       	ldi	r21, 0x00	; 0
     f72:	64 e0       	ldi	r22, 0x04	; 4
     f74:	80 e6       	ldi	r24, 0x60	; 96
     f76:	96 e0       	ldi	r25, 0x06	; 6
     f78:	04 df       	rcall	.-504    	; 0xd82 <ioport_configure_port_pin>
     f7a:	43 e0       	ldi	r20, 0x03	; 3
     f7c:	50 e0       	ldi	r21, 0x00	; 0
     f7e:	60 e1       	ldi	r22, 0x10	; 16
     f80:	80 ea       	ldi	r24, 0xA0	; 160
     f82:	96 e0       	ldi	r25, 0x06	; 6
     f84:	fe de       	rcall	.-516    	; 0xd82 <ioport_configure_port_pin>
     f86:	40 e0       	ldi	r20, 0x00	; 0
     f88:	50 e0       	ldi	r21, 0x00	; 0
     f8a:	61 e0       	ldi	r22, 0x01	; 1
     f8c:	80 e0       	ldi	r24, 0x00	; 0
     f8e:	96 e0       	ldi	r25, 0x06	; 6
     f90:	f8 de       	rcall	.-528    	; 0xd82 <ioport_configure_port_pin>
     f92:	40 e0       	ldi	r20, 0x00	; 0
     f94:	50 e0       	ldi	r21, 0x00	; 0
     f96:	64 e0       	ldi	r22, 0x04	; 4
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	96 e0       	ldi	r25, 0x06	; 6
     f9c:	f2 de       	rcall	.-540    	; 0xd82 <ioport_configure_port_pin>
     f9e:	40 e0       	ldi	r20, 0x00	; 0
     fa0:	50 e0       	ldi	r21, 0x00	; 0
     fa2:	62 e0       	ldi	r22, 0x02	; 2
     fa4:	80 e2       	ldi	r24, 0x20	; 32
     fa6:	96 e0       	ldi	r25, 0x06	; 6
     fa8:	ec de       	rcall	.-552    	; 0xd82 <ioport_configure_port_pin>
     faa:	43 e0       	ldi	r20, 0x03	; 3
     fac:	50 e0       	ldi	r21, 0x00	; 0
     fae:	68 e0       	ldi	r22, 0x08	; 8
     fb0:	80 e4       	ldi	r24, 0x40	; 64
     fb2:	96 e0       	ldi	r25, 0x06	; 6
     fb4:	e6 de       	rcall	.-564    	; 0xd82 <ioport_configure_port_pin>
     fb6:	40 e0       	ldi	r20, 0x00	; 0
     fb8:	50 e0       	ldi	r21, 0x00	; 0
     fba:	64 e0       	ldi	r22, 0x04	; 4
     fbc:	80 e4       	ldi	r24, 0x40	; 64
     fbe:	96 e0       	ldi	r25, 0x06	; 6
     fc0:	e0 de       	rcall	.-576    	; 0xd82 <ioport_configure_port_pin>
     fc2:	43 e0       	ldi	r20, 0x03	; 3
     fc4:	50 e0       	ldi	r21, 0x00	; 0
     fc6:	68 e0       	ldi	r22, 0x08	; 8
     fc8:	80 e6       	ldi	r24, 0x60	; 96
     fca:	96 e0       	ldi	r25, 0x06	; 6
     fcc:	da de       	rcall	.-588    	; 0xd82 <ioport_configure_port_pin>
     fce:	40 e0       	ldi	r20, 0x00	; 0
     fd0:	50 e0       	ldi	r21, 0x00	; 0
     fd2:	64 e0       	ldi	r22, 0x04	; 4
     fd4:	80 e6       	ldi	r24, 0x60	; 96
     fd6:	96 e0       	ldi	r25, 0x06	; 6
     fd8:	d4 de       	rcall	.-600    	; 0xd82 <ioport_configure_port_pin>
     fda:	43 e0       	ldi	r20, 0x03	; 3
     fdc:	50 e0       	ldi	r21, 0x00	; 0
     fde:	68 e0       	ldi	r22, 0x08	; 8
     fe0:	80 e8       	ldi	r24, 0x80	; 128
     fe2:	96 e0       	ldi	r25, 0x06	; 6
     fe4:	ce de       	rcall	.-612    	; 0xd82 <ioport_configure_port_pin>
     fe6:	40 e0       	ldi	r20, 0x00	; 0
     fe8:	50 e0       	ldi	r21, 0x00	; 0
     fea:	64 e0       	ldi	r22, 0x04	; 4
     fec:	80 e8       	ldi	r24, 0x80	; 128
     fee:	96 e0       	ldi	r25, 0x06	; 6
     ff0:	c8 ce       	rjmp	.-624    	; 0xd82 <ioport_configure_port_pin>
     ff2:	08 95       	ret

00000ff4 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     ff4:	81 15       	cp	r24, r1
     ff6:	22 e0       	ldi	r18, 0x02	; 2
     ff8:	92 07       	cpc	r25, r18
     ffa:	61 f4       	brne	.+24     	; 0x1014 <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     ffc:	80 91 55 22 	lds	r24, 0x2255	; 0x802255 <adca_enable_count>
    1000:	91 e0       	ldi	r25, 0x01	; 1
    1002:	98 0f       	add	r25, r24
    1004:	90 93 55 22 	sts	0x2255, r25	; 0x802255 <adca_enable_count>
    1008:	81 11       	cpse	r24, r1
    100a:	12 c0       	rjmp	.+36     	; 0x1030 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    100c:	62 e0       	ldi	r22, 0x02	; 2
    100e:	81 e0       	ldi	r24, 0x01	; 1
    1010:	49 cc       	rjmp	.-1902   	; 0x8a4 <sysclk_enable_module>
    1012:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    1014:	80 34       	cpi	r24, 0x40	; 64
    1016:	92 40       	sbci	r25, 0x02	; 2
    1018:	59 f4       	brne	.+22     	; 0x1030 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
    101a:	80 91 54 22 	lds	r24, 0x2254	; 0x802254 <adcb_enable_count>
    101e:	91 e0       	ldi	r25, 0x01	; 1
    1020:	98 0f       	add	r25, r24
    1022:	90 93 54 22 	sts	0x2254, r25	; 0x802254 <adcb_enable_count>
    1026:	81 11       	cpse	r24, r1
    1028:	03 c0       	rjmp	.+6      	; 0x1030 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    102a:	62 e0       	ldi	r22, 0x02	; 2
    102c:	82 e0       	ldi	r24, 0x02	; 2
    102e:	3a cc       	rjmp	.-1932   	; 0x8a4 <sysclk_enable_module>
    1030:	08 95       	ret

00001032 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
    1032:	81 15       	cp	r24, r1
    1034:	22 e0       	ldi	r18, 0x02	; 2
    1036:	92 07       	cpc	r25, r18
    1038:	59 f4       	brne	.+22     	; 0x1050 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
    103a:	80 91 55 22 	lds	r24, 0x2255	; 0x802255 <adca_enable_count>
    103e:	81 50       	subi	r24, 0x01	; 1
    1040:	80 93 55 22 	sts	0x2255, r24	; 0x802255 <adca_enable_count>
    1044:	81 11       	cpse	r24, r1
    1046:	11 c0       	rjmp	.+34     	; 0x106a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1048:	62 e0       	ldi	r22, 0x02	; 2
    104a:	81 e0       	ldi	r24, 0x01	; 1
    104c:	41 cc       	rjmp	.-1918   	; 0x8d0 <sysclk_disable_module>
    104e:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    1050:	80 34       	cpi	r24, 0x40	; 64
    1052:	92 40       	sbci	r25, 0x02	; 2
    1054:	51 f4       	brne	.+20     	; 0x106a <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
    1056:	80 91 54 22 	lds	r24, 0x2254	; 0x802254 <adcb_enable_count>
    105a:	81 50       	subi	r24, 0x01	; 1
    105c:	80 93 54 22 	sts	0x2254, r24	; 0x802254 <adcb_enable_count>
    1060:	81 11       	cpse	r24, r1
    1062:	03 c0       	rjmp	.+6      	; 0x106a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1064:	62 e0       	ldi	r22, 0x02	; 2
    1066:	82 e0       	ldi	r24, 0x02	; 2
    1068:	33 cc       	rjmp	.-1946   	; 0x8d0 <sysclk_disable_module>
    106a:	08 95       	ret

0000106c <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
    106c:	ef 92       	push	r14
    106e:	ff 92       	push	r15
    1070:	1f 93       	push	r17
    1072:	cf 93       	push	r28
    1074:	df 93       	push	r29
    1076:	1f 92       	push	r1
    1078:	1f 92       	push	r1
    107a:	cd b7       	in	r28, 0x3d	; 61
    107c:	de b7       	in	r29, 0x3e	; 62
    107e:	7c 01       	movw	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    1080:	8f b7       	in	r24, 0x3f	; 63
    1082:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    1084:	f8 94       	cli
	return flags;
    1086:	19 81       	ldd	r17, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
    1088:	c7 01       	movw	r24, r14
    108a:	b4 df       	rcall	.-152    	; 0xff4 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
    108c:	f7 01       	movw	r30, r14
    108e:	80 81       	ld	r24, Z
    1090:	81 60       	ori	r24, 0x01	; 1
    1092:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1094:	1f bf       	out	0x3f, r17	; 63
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
    1096:	80 91 28 24 	lds	r24, 0x2428	; 0x802428 <sleepmgr_locks+0x1>
    109a:	8f 3f       	cpi	r24, 0xFF	; 255
    109c:	09 f4       	brne	.+2      	; 0x10a0 <adc_enable+0x34>
    109e:	ff cf       	rjmp	.-2      	; 0x109e <adc_enable+0x32>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    10a0:	8f b7       	in	r24, 0x3f	; 63
    10a2:	8a 83       	std	Y+2, r24	; 0x02
	cpu_irq_disable();
    10a4:	f8 94       	cli
	return flags;
    10a6:	9a 81       	ldd	r25, Y+2	; 0x02
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
    10a8:	e7 e2       	ldi	r30, 0x27	; 39
    10aa:	f4 e2       	ldi	r31, 0x24	; 36
    10ac:	81 81       	ldd	r24, Z+1	; 0x01
    10ae:	8f 5f       	subi	r24, 0xFF	; 255
    10b0:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    10b2:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	ff 90       	pop	r15
    10c0:	ef 90       	pop	r14
    10c2:	08 95       	ret

000010c4 <adc_disable>:
 * Disables the ADC and unlocks IDLE mode for the sleep manager.
 *
 * \param adc Pointer to ADC module
 */
void adc_disable(ADC_t *adc)
{
    10c4:	1f 93       	push	r17
    10c6:	cf 93       	push	r28
    10c8:	df 93       	push	r29
    10ca:	1f 92       	push	r1
    10cc:	1f 92       	push	r1
    10ce:	cd b7       	in	r28, 0x3d	; 61
    10d0:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    10d2:	2f b7       	in	r18, 0x3f	; 63
    10d4:	29 83       	std	Y+1, r18	; 0x01
	cpu_irq_disable();
    10d6:	f8 94       	cli
	return flags;
    10d8:	19 81       	ldd	r17, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();
	adc->CTRLA &= ~ADC_ENABLE_bm;
    10da:	fc 01       	movw	r30, r24
    10dc:	20 81       	ld	r18, Z
    10de:	2e 7f       	andi	r18, 0xFE	; 254
    10e0:	20 83       	st	Z, r18
	adc_disable_clock(adc);
    10e2:	a7 df       	rcall	.-178    	; 0x1032 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    10e4:	1f bf       	out	0x3f, r17	; 63
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] == 0) {
    10e6:	80 91 28 24 	lds	r24, 0x2428	; 0x802428 <sleepmgr_locks+0x1>
    10ea:	81 11       	cpse	r24, r1
    10ec:	01 c0       	rjmp	.+2      	; 0x10f0 <adc_disable+0x2c>
    10ee:	ff cf       	rjmp	.-2      	; 0x10ee <adc_disable+0x2a>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    10f0:	8f b7       	in	r24, 0x3f	; 63
    10f2:	8a 83       	std	Y+2, r24	; 0x02
	cpu_irq_disable();
    10f4:	f8 94       	cli
	return flags;
    10f6:	9a 81       	ldd	r25, Y+2	; 0x02
	}

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
    10f8:	e7 e2       	ldi	r30, 0x27	; 39
    10fa:	f4 e2       	ldi	r31, 0x24	; 36
    10fc:	81 81       	ldd	r24, Z+1	; 0x01
    10fe:	81 50       	subi	r24, 0x01	; 1
    1100:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1102:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_unlock_mode(SLEEPMGR_IDLE);
}
    1104:	0f 90       	pop	r0
    1106:	0f 90       	pop	r0
    1108:	df 91       	pop	r29
    110a:	cf 91       	pop	r28
    110c:	1f 91       	pop	r17
    110e:	08 95       	ret

00001110 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
    1110:	1f 92       	push	r1
    1112:	0f 92       	push	r0
    1114:	0f b6       	in	r0, 0x3f	; 63
    1116:	0f 92       	push	r0
    1118:	11 24       	eor	r1, r1
    111a:	0b b6       	in	r0, 0x3b	; 59
    111c:	0f 92       	push	r0
    111e:	2f 93       	push	r18
    1120:	3f 93       	push	r19
    1122:	4f 93       	push	r20
    1124:	5f 93       	push	r21
    1126:	6f 93       	push	r22
    1128:	7f 93       	push	r23
    112a:	8f 93       	push	r24
    112c:	9f 93       	push	r25
    112e:	af 93       	push	r26
    1130:	bf 93       	push	r27
    1132:	ef 93       	push	r30
    1134:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
    1136:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
    113a:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
    113e:	e0 91 2f 24 	lds	r30, 0x242F	; 0x80242f <adca_callback>
    1142:	f0 91 30 24 	lds	r31, 0x2430	; 0x802430 <adca_callback+0x1>
    1146:	61 e0       	ldi	r22, 0x01	; 1
    1148:	80 e0       	ldi	r24, 0x00	; 0
    114a:	92 e0       	ldi	r25, 0x02	; 2
    114c:	19 95       	eicall
}
    114e:	ff 91       	pop	r31
    1150:	ef 91       	pop	r30
    1152:	bf 91       	pop	r27
    1154:	af 91       	pop	r26
    1156:	9f 91       	pop	r25
    1158:	8f 91       	pop	r24
    115a:	7f 91       	pop	r23
    115c:	6f 91       	pop	r22
    115e:	5f 91       	pop	r21
    1160:	4f 91       	pop	r20
    1162:	3f 91       	pop	r19
    1164:	2f 91       	pop	r18
    1166:	0f 90       	pop	r0
    1168:	0b be       	out	0x3b, r0	; 59
    116a:	0f 90       	pop	r0
    116c:	0f be       	out	0x3f, r0	; 63
    116e:	0f 90       	pop	r0
    1170:	1f 90       	pop	r1
    1172:	18 95       	reti

00001174 <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
    1174:	1f 92       	push	r1
    1176:	0f 92       	push	r0
    1178:	0f b6       	in	r0, 0x3f	; 63
    117a:	0f 92       	push	r0
    117c:	11 24       	eor	r1, r1
    117e:	0b b6       	in	r0, 0x3b	; 59
    1180:	0f 92       	push	r0
    1182:	2f 93       	push	r18
    1184:	3f 93       	push	r19
    1186:	4f 93       	push	r20
    1188:	5f 93       	push	r21
    118a:	6f 93       	push	r22
    118c:	7f 93       	push	r23
    118e:	8f 93       	push	r24
    1190:	9f 93       	push	r25
    1192:	af 93       	push	r26
    1194:	bf 93       	push	r27
    1196:	ef 93       	push	r30
    1198:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
    119a:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
    119e:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
    11a2:	e0 91 2f 24 	lds	r30, 0x242F	; 0x80242f <adca_callback>
    11a6:	f0 91 30 24 	lds	r31, 0x2430	; 0x802430 <adca_callback+0x1>
    11aa:	62 e0       	ldi	r22, 0x02	; 2
    11ac:	80 e0       	ldi	r24, 0x00	; 0
    11ae:	92 e0       	ldi	r25, 0x02	; 2
    11b0:	19 95       	eicall
}
    11b2:	ff 91       	pop	r31
    11b4:	ef 91       	pop	r30
    11b6:	bf 91       	pop	r27
    11b8:	af 91       	pop	r26
    11ba:	9f 91       	pop	r25
    11bc:	8f 91       	pop	r24
    11be:	7f 91       	pop	r23
    11c0:	6f 91       	pop	r22
    11c2:	5f 91       	pop	r21
    11c4:	4f 91       	pop	r20
    11c6:	3f 91       	pop	r19
    11c8:	2f 91       	pop	r18
    11ca:	0f 90       	pop	r0
    11cc:	0b be       	out	0x3b, r0	; 59
    11ce:	0f 90       	pop	r0
    11d0:	0f be       	out	0x3f, r0	; 63
    11d2:	0f 90       	pop	r0
    11d4:	1f 90       	pop	r1
    11d6:	18 95       	reti

000011d8 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    11d8:	1f 92       	push	r1
    11da:	0f 92       	push	r0
    11dc:	0f b6       	in	r0, 0x3f	; 63
    11de:	0f 92       	push	r0
    11e0:	11 24       	eor	r1, r1
    11e2:	0b b6       	in	r0, 0x3b	; 59
    11e4:	0f 92       	push	r0
    11e6:	2f 93       	push	r18
    11e8:	3f 93       	push	r19
    11ea:	4f 93       	push	r20
    11ec:	5f 93       	push	r21
    11ee:	6f 93       	push	r22
    11f0:	7f 93       	push	r23
    11f2:	8f 93       	push	r24
    11f4:	9f 93       	push	r25
    11f6:	af 93       	push	r26
    11f8:	bf 93       	push	r27
    11fa:	ef 93       	push	r30
    11fc:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    11fe:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
    1202:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
    1206:	e0 91 2f 24 	lds	r30, 0x242F	; 0x80242f <adca_callback>
    120a:	f0 91 30 24 	lds	r31, 0x2430	; 0x802430 <adca_callback+0x1>
    120e:	64 e0       	ldi	r22, 0x04	; 4
    1210:	80 e0       	ldi	r24, 0x00	; 0
    1212:	92 e0       	ldi	r25, 0x02	; 2
    1214:	19 95       	eicall
}
    1216:	ff 91       	pop	r31
    1218:	ef 91       	pop	r30
    121a:	bf 91       	pop	r27
    121c:	af 91       	pop	r26
    121e:	9f 91       	pop	r25
    1220:	8f 91       	pop	r24
    1222:	7f 91       	pop	r23
    1224:	6f 91       	pop	r22
    1226:	5f 91       	pop	r21
    1228:	4f 91       	pop	r20
    122a:	3f 91       	pop	r19
    122c:	2f 91       	pop	r18
    122e:	0f 90       	pop	r0
    1230:	0b be       	out	0x3b, r0	; 59
    1232:	0f 90       	pop	r0
    1234:	0f be       	out	0x3f, r0	; 63
    1236:	0f 90       	pop	r0
    1238:	1f 90       	pop	r1
    123a:	18 95       	reti

0000123c <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    123c:	1f 92       	push	r1
    123e:	0f 92       	push	r0
    1240:	0f b6       	in	r0, 0x3f	; 63
    1242:	0f 92       	push	r0
    1244:	11 24       	eor	r1, r1
    1246:	0b b6       	in	r0, 0x3b	; 59
    1248:	0f 92       	push	r0
    124a:	2f 93       	push	r18
    124c:	3f 93       	push	r19
    124e:	4f 93       	push	r20
    1250:	5f 93       	push	r21
    1252:	6f 93       	push	r22
    1254:	7f 93       	push	r23
    1256:	8f 93       	push	r24
    1258:	9f 93       	push	r25
    125a:	af 93       	push	r26
    125c:	bf 93       	push	r27
    125e:	ef 93       	push	r30
    1260:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    1262:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
    1266:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
    126a:	e0 91 2f 24 	lds	r30, 0x242F	; 0x80242f <adca_callback>
    126e:	f0 91 30 24 	lds	r31, 0x2430	; 0x802430 <adca_callback+0x1>
    1272:	68 e0       	ldi	r22, 0x08	; 8
    1274:	80 e0       	ldi	r24, 0x00	; 0
    1276:	92 e0       	ldi	r25, 0x02	; 2
    1278:	19 95       	eicall
}
    127a:	ff 91       	pop	r31
    127c:	ef 91       	pop	r30
    127e:	bf 91       	pop	r27
    1280:	af 91       	pop	r26
    1282:	9f 91       	pop	r25
    1284:	8f 91       	pop	r24
    1286:	7f 91       	pop	r23
    1288:	6f 91       	pop	r22
    128a:	5f 91       	pop	r21
    128c:	4f 91       	pop	r20
    128e:	3f 91       	pop	r19
    1290:	2f 91       	pop	r18
    1292:	0f 90       	pop	r0
    1294:	0b be       	out	0x3b, r0	; 59
    1296:	0f 90       	pop	r0
    1298:	0f be       	out	0x3f, r0	; 63
    129a:	0f 90       	pop	r0
    129c:	1f 90       	pop	r1
    129e:	18 95       	reti

000012a0 <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    12a0:	1f 92       	push	r1
    12a2:	0f 92       	push	r0
    12a4:	0f b6       	in	r0, 0x3f	; 63
    12a6:	0f 92       	push	r0
    12a8:	11 24       	eor	r1, r1
    12aa:	0b b6       	in	r0, 0x3b	; 59
    12ac:	0f 92       	push	r0
    12ae:	2f 93       	push	r18
    12b0:	3f 93       	push	r19
    12b2:	4f 93       	push	r20
    12b4:	5f 93       	push	r21
    12b6:	6f 93       	push	r22
    12b8:	7f 93       	push	r23
    12ba:	8f 93       	push	r24
    12bc:	9f 93       	push	r25
    12be:	af 93       	push	r26
    12c0:	bf 93       	push	r27
    12c2:	ef 93       	push	r30
    12c4:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    12c6:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
    12ca:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
    12ce:	e0 91 2d 24 	lds	r30, 0x242D	; 0x80242d <adcb_callback>
    12d2:	f0 91 2e 24 	lds	r31, 0x242E	; 0x80242e <adcb_callback+0x1>
    12d6:	61 e0       	ldi	r22, 0x01	; 1
    12d8:	80 e4       	ldi	r24, 0x40	; 64
    12da:	92 e0       	ldi	r25, 0x02	; 2
    12dc:	19 95       	eicall
}
    12de:	ff 91       	pop	r31
    12e0:	ef 91       	pop	r30
    12e2:	bf 91       	pop	r27
    12e4:	af 91       	pop	r26
    12e6:	9f 91       	pop	r25
    12e8:	8f 91       	pop	r24
    12ea:	7f 91       	pop	r23
    12ec:	6f 91       	pop	r22
    12ee:	5f 91       	pop	r21
    12f0:	4f 91       	pop	r20
    12f2:	3f 91       	pop	r19
    12f4:	2f 91       	pop	r18
    12f6:	0f 90       	pop	r0
    12f8:	0b be       	out	0x3b, r0	; 59
    12fa:	0f 90       	pop	r0
    12fc:	0f be       	out	0x3f, r0	; 63
    12fe:	0f 90       	pop	r0
    1300:	1f 90       	pop	r1
    1302:	18 95       	reti

00001304 <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    1304:	1f 92       	push	r1
    1306:	0f 92       	push	r0
    1308:	0f b6       	in	r0, 0x3f	; 63
    130a:	0f 92       	push	r0
    130c:	11 24       	eor	r1, r1
    130e:	0b b6       	in	r0, 0x3b	; 59
    1310:	0f 92       	push	r0
    1312:	2f 93       	push	r18
    1314:	3f 93       	push	r19
    1316:	4f 93       	push	r20
    1318:	5f 93       	push	r21
    131a:	6f 93       	push	r22
    131c:	7f 93       	push	r23
    131e:	8f 93       	push	r24
    1320:	9f 93       	push	r25
    1322:	af 93       	push	r26
    1324:	bf 93       	push	r27
    1326:	ef 93       	push	r30
    1328:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    132a:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
    132e:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
    1332:	e0 91 2d 24 	lds	r30, 0x242D	; 0x80242d <adcb_callback>
    1336:	f0 91 2e 24 	lds	r31, 0x242E	; 0x80242e <adcb_callback+0x1>
    133a:	62 e0       	ldi	r22, 0x02	; 2
    133c:	80 e4       	ldi	r24, 0x40	; 64
    133e:	92 e0       	ldi	r25, 0x02	; 2
    1340:	19 95       	eicall
}
    1342:	ff 91       	pop	r31
    1344:	ef 91       	pop	r30
    1346:	bf 91       	pop	r27
    1348:	af 91       	pop	r26
    134a:	9f 91       	pop	r25
    134c:	8f 91       	pop	r24
    134e:	7f 91       	pop	r23
    1350:	6f 91       	pop	r22
    1352:	5f 91       	pop	r21
    1354:	4f 91       	pop	r20
    1356:	3f 91       	pop	r19
    1358:	2f 91       	pop	r18
    135a:	0f 90       	pop	r0
    135c:	0b be       	out	0x3b, r0	; 59
    135e:	0f 90       	pop	r0
    1360:	0f be       	out	0x3f, r0	; 63
    1362:	0f 90       	pop	r0
    1364:	1f 90       	pop	r1
    1366:	18 95       	reti

00001368 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1368:	1f 92       	push	r1
    136a:	0f 92       	push	r0
    136c:	0f b6       	in	r0, 0x3f	; 63
    136e:	0f 92       	push	r0
    1370:	11 24       	eor	r1, r1
    1372:	0b b6       	in	r0, 0x3b	; 59
    1374:	0f 92       	push	r0
    1376:	2f 93       	push	r18
    1378:	3f 93       	push	r19
    137a:	4f 93       	push	r20
    137c:	5f 93       	push	r21
    137e:	6f 93       	push	r22
    1380:	7f 93       	push	r23
    1382:	8f 93       	push	r24
    1384:	9f 93       	push	r25
    1386:	af 93       	push	r26
    1388:	bf 93       	push	r27
    138a:	ef 93       	push	r30
    138c:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    138e:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
    1392:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
    1396:	e0 91 2d 24 	lds	r30, 0x242D	; 0x80242d <adcb_callback>
    139a:	f0 91 2e 24 	lds	r31, 0x242E	; 0x80242e <adcb_callback+0x1>
    139e:	64 e0       	ldi	r22, 0x04	; 4
    13a0:	80 e4       	ldi	r24, 0x40	; 64
    13a2:	92 e0       	ldi	r25, 0x02	; 2
    13a4:	19 95       	eicall
}
    13a6:	ff 91       	pop	r31
    13a8:	ef 91       	pop	r30
    13aa:	bf 91       	pop	r27
    13ac:	af 91       	pop	r26
    13ae:	9f 91       	pop	r25
    13b0:	8f 91       	pop	r24
    13b2:	7f 91       	pop	r23
    13b4:	6f 91       	pop	r22
    13b6:	5f 91       	pop	r21
    13b8:	4f 91       	pop	r20
    13ba:	3f 91       	pop	r19
    13bc:	2f 91       	pop	r18
    13be:	0f 90       	pop	r0
    13c0:	0b be       	out	0x3b, r0	; 59
    13c2:	0f 90       	pop	r0
    13c4:	0f be       	out	0x3f, r0	; 63
    13c6:	0f 90       	pop	r0
    13c8:	1f 90       	pop	r1
    13ca:	18 95       	reti

000013cc <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    13cc:	1f 92       	push	r1
    13ce:	0f 92       	push	r0
    13d0:	0f b6       	in	r0, 0x3f	; 63
    13d2:	0f 92       	push	r0
    13d4:	11 24       	eor	r1, r1
    13d6:	0b b6       	in	r0, 0x3b	; 59
    13d8:	0f 92       	push	r0
    13da:	2f 93       	push	r18
    13dc:	3f 93       	push	r19
    13de:	4f 93       	push	r20
    13e0:	5f 93       	push	r21
    13e2:	6f 93       	push	r22
    13e4:	7f 93       	push	r23
    13e6:	8f 93       	push	r24
    13e8:	9f 93       	push	r25
    13ea:	af 93       	push	r26
    13ec:	bf 93       	push	r27
    13ee:	ef 93       	push	r30
    13f0:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    13f2:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
    13f6:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
    13fa:	e0 91 2d 24 	lds	r30, 0x242D	; 0x80242d <adcb_callback>
    13fe:	f0 91 2e 24 	lds	r31, 0x242E	; 0x80242e <adcb_callback+0x1>
    1402:	68 e0       	ldi	r22, 0x08	; 8
    1404:	80 e4       	ldi	r24, 0x40	; 64
    1406:	92 e0       	ldi	r25, 0x02	; 2
    1408:	19 95       	eicall
}
    140a:	ff 91       	pop	r31
    140c:	ef 91       	pop	r30
    140e:	bf 91       	pop	r27
    1410:	af 91       	pop	r26
    1412:	9f 91       	pop	r25
    1414:	8f 91       	pop	r24
    1416:	7f 91       	pop	r23
    1418:	6f 91       	pop	r22
    141a:	5f 91       	pop	r21
    141c:	4f 91       	pop	r20
    141e:	3f 91       	pop	r19
    1420:	2f 91       	pop	r18
    1422:	0f 90       	pop	r0
    1424:	0b be       	out	0x3b, r0	; 59
    1426:	0f 90       	pop	r0
    1428:	0f be       	out	0x3f, r0	; 63
    142a:	0f 90       	pop	r0
    142c:	1f 90       	pop	r1
    142e:	18 95       	reti

00001430 <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    1430:	bf 92       	push	r11
    1432:	cf 92       	push	r12
    1434:	df 92       	push	r13
    1436:	ef 92       	push	r14
    1438:	ff 92       	push	r15
    143a:	0f 93       	push	r16
    143c:	1f 93       	push	r17
    143e:	cf 93       	push	r28
    1440:	df 93       	push	r29
    1442:	1f 92       	push	r1
    1444:	cd b7       	in	r28, 0x3d	; 61
    1446:	de b7       	in	r29, 0x3e	; 62
    1448:	8c 01       	movw	r16, r24
    144a:	7b 01       	movw	r14, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    144c:	81 15       	cp	r24, r1
    144e:	22 e0       	ldi	r18, 0x02	; 2
    1450:	92 07       	cpc	r25, r18
    1452:	71 f4       	brne	.+28     	; 0x1470 <adc_write_configuration+0x40>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    1454:	61 e2       	ldi	r22, 0x21	; 33
    1456:	70 e0       	ldi	r23, 0x00	; 0
    1458:	82 e0       	ldi	r24, 0x02	; 2
    145a:	1f d1       	rcall	.+574    	; 0x169a <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    145c:	c8 2e       	mov	r12, r24
    145e:	d1 2c       	mov	r13, r1
    1460:	60 e2       	ldi	r22, 0x20	; 32
    1462:	70 e0       	ldi	r23, 0x00	; 0
    1464:	82 e0       	ldi	r24, 0x02	; 2
    1466:	19 d1       	rcall	.+562    	; 0x169a <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCACAL0);
    1468:	dc 2c       	mov	r13, r12
    146a:	cc 24       	eor	r12, r12
    146c:	c8 2a       	or	r12, r24
    146e:	10 c0       	rjmp	.+32     	; 0x1490 <adc_write_configuration+0x60>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1470:	80 34       	cpi	r24, 0x40	; 64
    1472:	92 40       	sbci	r25, 0x02	; 2
    1474:	c1 f5       	brne	.+112    	; 0x14e6 <adc_write_configuration+0xb6>
    1476:	65 e2       	ldi	r22, 0x25	; 37
    1478:	70 e0       	ldi	r23, 0x00	; 0
    147a:	82 e0       	ldi	r24, 0x02	; 2
    147c:	0e d1       	rcall	.+540    	; 0x169a <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    147e:	c8 2e       	mov	r12, r24
    1480:	d1 2c       	mov	r13, r1
    1482:	64 e2       	ldi	r22, 0x24	; 36
    1484:	70 e0       	ldi	r23, 0x00	; 0
    1486:	82 e0       	ldi	r24, 0x02	; 2
    1488:	08 d1       	rcall	.+528    	; 0x169a <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCBCAL0);
    148a:	dc 2c       	mov	r13, r12
    148c:	cc 24       	eor	r12, r12
    148e:	c8 2a       	or	r12, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    1490:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    1492:	89 83       	std	Y+1, r24	; 0x01
	return flags;
    1494:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1496:	b9 80       	ldd	r11, Y+1	; 0x01
    1498:	c8 01       	movw	r24, r16
    149a:	ac dd       	rcall	.-1192   	; 0xff4 <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    149c:	f8 01       	movw	r30, r16
    149e:	80 81       	ld	r24, Z

	adc->CTRLA = ADC_FLUSH_bm;
    14a0:	92 e0       	ldi	r25, 0x02	; 2
    14a2:	90 83       	st	Z, r25
	adc->CAL = cal;
    14a4:	c4 86       	std	Z+12, r12	; 0x0c
    14a6:	d5 86       	std	Z+13, r13	; 0x0d
	adc->CMP = conf->cmp;
    14a8:	f7 01       	movw	r30, r14
    14aa:	25 81       	ldd	r18, Z+5	; 0x05
    14ac:	36 81       	ldd	r19, Z+6	; 0x06
    14ae:	f8 01       	movw	r30, r16
    14b0:	20 8f       	std	Z+24, r18	; 0x18
    14b2:	31 8f       	std	Z+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
    14b4:	f7 01       	movw	r30, r14
    14b6:	92 81       	ldd	r25, Z+2	; 0x02
    14b8:	f8 01       	movw	r30, r16
    14ba:	92 83       	std	Z+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
    14bc:	f7 01       	movw	r30, r14
    14be:	94 81       	ldd	r25, Z+4	; 0x04
    14c0:	f8 01       	movw	r30, r16
    14c2:	94 83       	std	Z+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
    14c4:	f7 01       	movw	r30, r14
    14c6:	93 81       	ldd	r25, Z+3	; 0x03
    14c8:	f8 01       	movw	r30, r16
    14ca:	93 83       	std	Z+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    14cc:	f7 01       	movw	r30, r14
    14ce:	91 81       	ldd	r25, Z+1	; 0x01
    14d0:	f8 01       	movw	r30, r16
    14d2:	91 83       	std	Z+1, r25	; 0x01

	adc->CTRLA = enable | conf->ctrla;
    14d4:	81 70       	andi	r24, 0x01	; 1
    14d6:	f7 01       	movw	r30, r14
    14d8:	90 81       	ld	r25, Z
    14da:	89 2b       	or	r24, r25
    14dc:	f8 01       	movw	r30, r16

	adc_disable_clock(adc);
    14de:	80 83       	st	Z, r24
    14e0:	c8 01       	movw	r24, r16
    14e2:	a7 dd       	rcall	.-1202   	; 0x1032 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    14e4:	bf be       	out	0x3f, r11	; 63

	cpu_irq_restore(flags);
}
    14e6:	0f 90       	pop	r0
    14e8:	df 91       	pop	r29
    14ea:	cf 91       	pop	r28
    14ec:	1f 91       	pop	r17
    14ee:	0f 91       	pop	r16
    14f0:	ff 90       	pop	r15
    14f2:	ef 90       	pop	r14
    14f4:	df 90       	pop	r13
    14f6:	cf 90       	pop	r12
    14f8:	bf 90       	pop	r11
    14fa:	08 95       	ret

000014fc <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    14fc:	df 92       	push	r13
    14fe:	ef 92       	push	r14
    1500:	ff 92       	push	r15
    1502:	0f 93       	push	r16
    1504:	1f 93       	push	r17
    1506:	cf 93       	push	r28
    1508:	df 93       	push	r29
    150a:	1f 92       	push	r1
    150c:	cd b7       	in	r28, 0x3d	; 61
    150e:	de b7       	in	r29, 0x3e	; 62
    1510:	8c 01       	movw	r16, r24
    1512:	7b 01       	movw	r14, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    1514:	8f b7       	in	r24, 0x3f	; 63
    1516:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    1518:	f8 94       	cli
	return flags;
    151a:	d9 80       	ldd	r13, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    151c:	c8 01       	movw	r24, r16
    151e:	6a dd       	rcall	.-1324   	; 0xff4 <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    1520:	f8 01       	movw	r30, r16
    1522:	80 81       	ld	r24, Z
    1524:	80 7c       	andi	r24, 0xC0	; 192
    1526:	f7 01       	movw	r30, r14
    1528:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    152a:	f8 01       	movw	r30, r16
    152c:	80 8d       	ldd	r24, Z+24	; 0x18
    152e:	91 8d       	ldd	r25, Z+25	; 0x19
    1530:	f7 01       	movw	r30, r14
    1532:	85 83       	std	Z+5, r24	; 0x05
    1534:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    1536:	f8 01       	movw	r30, r16
    1538:	82 81       	ldd	r24, Z+2	; 0x02
    153a:	f7 01       	movw	r30, r14
    153c:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    153e:	f8 01       	movw	r30, r16
    1540:	84 81       	ldd	r24, Z+4	; 0x04
    1542:	f7 01       	movw	r30, r14
    1544:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    1546:	f8 01       	movw	r30, r16
    1548:	83 81       	ldd	r24, Z+3	; 0x03
    154a:	f7 01       	movw	r30, r14
    154c:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    154e:	f8 01       	movw	r30, r16
    1550:	81 81       	ldd	r24, Z+1	; 0x01
    1552:	f7 01       	movw	r30, r14
    1554:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    1556:	c8 01       	movw	r24, r16
    1558:	6c dd       	rcall	.-1320   	; 0x1032 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    155a:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    155c:	0f 90       	pop	r0
    155e:	df 91       	pop	r29
    1560:	cf 91       	pop	r28
    1562:	1f 91       	pop	r17
    1564:	0f 91       	pop	r16
    1566:	ff 90       	pop	r15
    1568:	ef 90       	pop	r14
    156a:	df 90       	pop	r13
    156c:	08 95       	ret

0000156e <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    156e:	af 92       	push	r10
    1570:	bf 92       	push	r11
    1572:	cf 92       	push	r12
    1574:	df 92       	push	r13
    1576:	ef 92       	push	r14
    1578:	ff 92       	push	r15
    157a:	0f 93       	push	r16
    157c:	1f 93       	push	r17
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	1f 92       	push	r1
    1584:	cd b7       	in	r28, 0x3d	; 61
    1586:	de b7       	in	r29, 0x3e	; 62
    1588:	6c 01       	movw	r12, r24
    158a:	b6 2e       	mov	r11, r22
    158c:	7a 01       	movw	r14, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    158e:	86 2f       	mov	r24, r22
    1590:	83 70       	andi	r24, 0x03	; 3
    1592:	29 f4       	brne	.+10     	; 0x159e <adcch_write_configuration+0x30>
		index += 2;
		ch_mask >>= 2;
    1594:	96 2f       	mov	r25, r22
    1596:	96 95       	lsr	r25
    1598:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    159a:	82 e0       	ldi	r24, 0x02	; 2
    159c:	02 c0       	rjmp	.+4      	; 0x15a2 <adcch_write_configuration+0x34>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    159e:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
__always_inline static  ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    15a0:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    15a2:	90 ff       	sbrs	r25, 0
		index++;
    15a4:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    15a6:	86 01       	movw	r16, r12
    15a8:	00 5e       	subi	r16, 0xE0	; 224
    15aa:	1f 4f       	sbci	r17, 0xFF	; 255
    15ac:	98 e0       	ldi	r25, 0x08	; 8
    15ae:	89 9f       	mul	r24, r25
    15b0:	00 0d       	add	r16, r0
    15b2:	11 1d       	adc	r17, r1
    15b4:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    15b6:	8f b7       	in	r24, 0x3f	; 63
    15b8:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    15ba:	f8 94       	cli
	return flags;
    15bc:	a9 80       	ldd	r10, Y+1	; 0x01
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    15be:	c6 01       	movw	r24, r12
    15c0:	19 dd       	rcall	.-1486   	; 0xff4 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    15c2:	f7 01       	movw	r30, r14
    15c4:	80 81       	ld	r24, Z
    15c6:	f8 01       	movw	r30, r16
    15c8:	80 83       	st	Z, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    15ca:	f7 01       	movw	r30, r14
    15cc:	82 81       	ldd	r24, Z+2	; 0x02
    15ce:	f8 01       	movw	r30, r16
    15d0:	82 83       	std	Z+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    15d2:	f7 01       	movw	r30, r14
    15d4:	81 81       	ldd	r24, Z+1	; 0x01
    15d6:	f8 01       	movw	r30, r16
    15d8:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    15da:	b0 fe       	sbrs	r11, 0
    15dc:	04 c0       	rjmp	.+8      	; 0x15e6 <adcch_write_configuration+0x78>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    15de:	f7 01       	movw	r30, r14
    15e0:	83 81       	ldd	r24, Z+3	; 0x03
    15e2:	f8 01       	movw	r30, r16
    15e4:	86 83       	std	Z+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    15e6:	c6 01       	movw	r24, r12
    15e8:	24 dd       	rcall	.-1464   	; 0x1032 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    15ea:	af be       	out	0x3f, r10	; 63

	cpu_irq_restore(flags);
}
    15ec:	0f 90       	pop	r0
    15ee:	df 91       	pop	r29
    15f0:	cf 91       	pop	r28
    15f2:	1f 91       	pop	r17
    15f4:	0f 91       	pop	r16
    15f6:	ff 90       	pop	r15
    15f8:	ef 90       	pop	r14
    15fa:	df 90       	pop	r13
    15fc:	cf 90       	pop	r12
    15fe:	bf 90       	pop	r11
    1600:	af 90       	pop	r10
    1602:	08 95       	ret

00001604 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1604:	af 92       	push	r10
    1606:	bf 92       	push	r11
    1608:	cf 92       	push	r12
    160a:	df 92       	push	r13
    160c:	ef 92       	push	r14
    160e:	ff 92       	push	r15
    1610:	0f 93       	push	r16
    1612:	1f 93       	push	r17
    1614:	cf 93       	push	r28
    1616:	df 93       	push	r29
    1618:	1f 92       	push	r1
    161a:	cd b7       	in	r28, 0x3d	; 61
    161c:	de b7       	in	r29, 0x3e	; 62
    161e:	6c 01       	movw	r12, r24
    1620:	b6 2e       	mov	r11, r22
    1622:	7a 01       	movw	r14, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1624:	86 2f       	mov	r24, r22
    1626:	83 70       	andi	r24, 0x03	; 3
    1628:	29 f4       	brne	.+10     	; 0x1634 <adcch_read_configuration+0x30>
		index += 2;
		ch_mask >>= 2;
    162a:	96 2f       	mov	r25, r22
    162c:	96 95       	lsr	r25
    162e:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1630:	82 e0       	ldi	r24, 0x02	; 2
    1632:	02 c0       	rjmp	.+4      	; 0x1638 <adcch_read_configuration+0x34>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1634:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
__always_inline static  ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1636:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1638:	90 ff       	sbrs	r25, 0
		index++;
    163a:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    163c:	86 01       	movw	r16, r12
    163e:	00 5e       	subi	r16, 0xE0	; 224
    1640:	1f 4f       	sbci	r17, 0xFF	; 255
    1642:	98 e0       	ldi	r25, 0x08	; 8
    1644:	89 9f       	mul	r24, r25
    1646:	00 0d       	add	r16, r0
    1648:	11 1d       	adc	r17, r1
    164a:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    164c:	8f b7       	in	r24, 0x3f	; 63
    164e:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    1650:	f8 94       	cli
	return flags;
    1652:	a9 80       	ldd	r10, Y+1	; 0x01

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1654:	c6 01       	movw	r24, r12
    1656:	ce dc       	rcall	.-1636   	; 0xff4 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1658:	f8 01       	movw	r30, r16
    165a:	80 81       	ld	r24, Z
    165c:	f7 01       	movw	r30, r14
    165e:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    1660:	f8 01       	movw	r30, r16
    1662:	82 81       	ldd	r24, Z+2	; 0x02
    1664:	f7 01       	movw	r30, r14
    1666:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1668:	f8 01       	movw	r30, r16
    166a:	81 81       	ldd	r24, Z+1	; 0x01
    166c:	f7 01       	movw	r30, r14
    166e:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1670:	b0 fe       	sbrs	r11, 0
    1672:	04 c0       	rjmp	.+8      	; 0x167c <adcch_read_configuration+0x78>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1674:	f8 01       	movw	r30, r16
    1676:	86 81       	ldd	r24, Z+6	; 0x06
    1678:	f7 01       	movw	r30, r14
    167a:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    167c:	c6 01       	movw	r24, r12
    167e:	d9 dc       	rcall	.-1614   	; 0x1032 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1680:	af be       	out	0x3f, r10	; 63

	cpu_irq_restore(flags);
}
    1682:	0f 90       	pop	r0
    1684:	df 91       	pop	r29
    1686:	cf 91       	pop	r28
    1688:	1f 91       	pop	r17
    168a:	0f 91       	pop	r16
    168c:	ff 90       	pop	r15
    168e:	ef 90       	pop	r14
    1690:	df 90       	pop	r13
    1692:	cf 90       	pop	r12
    1694:	bf 90       	pop	r11
    1696:	af 90       	pop	r10
    1698:	08 95       	ret

0000169a <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    169a:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    169e:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    16a0:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    16a2:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    16a6:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    16a8:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    16ac:	08 95       	ret

000016ae <twim_interrupt_handler>:
 * \brief Common TWI master interrupt service routine.
 *
 *  Check current status and calls the appropriate handler.
 */
static void twim_interrupt_handler(void)
{
    16ae:	cf 93       	push	r28
    16b0:	df 93       	push	r29
	uint8_t const master_status = transfer.bus->MASTER.STATUS;
    16b2:	e0 91 56 22 	lds	r30, 0x2256	; 0x802256 <transfer>
    16b6:	f0 91 57 22 	lds	r31, 0x2257	; 0x802257 <transfer+0x1>
    16ba:	84 81       	ldd	r24, Z+4	; 0x04

	if (master_status & TWI_MASTER_ARBLOST_bm) {
    16bc:	83 ff       	sbrs	r24, 3
    16be:	08 c0       	rjmp	.+16     	; 0x16d0 <twim_interrupt_handler+0x22>

		transfer.bus->MASTER.STATUS = master_status | TWI_MASTER_ARBLOST_bm;
    16c0:	88 60       	ori	r24, 0x08	; 8
    16c2:	84 83       	std	Z+4, r24	; 0x04
		transfer.bus->MASTER.CTRLC  = TWI_MASTER_CMD_STOP_gc;
    16c4:	83 e0       	ldi	r24, 0x03	; 3
    16c6:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_BUSY;
    16c8:	86 ef       	ldi	r24, 0xF6	; 246
    16ca:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <transfer+0xa>
    16ce:	83 c0       	rjmp	.+262    	; 0x17d6 <twim_interrupt_handler+0x128>

	} else if ((master_status & TWI_MASTER_BUSERR_bm) ||
    16d0:	98 2f       	mov	r25, r24
    16d2:	94 71       	andi	r25, 0x14	; 20
    16d4:	31 f0       	breq	.+12     	; 0x16e2 <twim_interrupt_handler+0x34>
		(master_status & TWI_MASTER_RXACK_bm)) {

		transfer.bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    16d6:	83 e0       	ldi	r24, 0x03	; 3
    16d8:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_IO_ERROR;
    16da:	8f ef       	ldi	r24, 0xFF	; 255
    16dc:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <transfer+0xa>
    16e0:	7a c0       	rjmp	.+244    	; 0x17d6 <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {
    16e2:	86 ff       	sbrs	r24, 6
    16e4:	43 c0       	rjmp	.+134    	; 0x176c <twim_interrupt_handler+0xbe>
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 */
static inline void twim_write_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    16e6:	c6 e5       	ldi	r28, 0x56	; 86
    16e8:	d2 e2       	ldi	r29, 0x22	; 34
    16ea:	aa 81       	ldd	r26, Y+2	; 0x02
    16ec:	bb 81       	ldd	r27, Y+3	; 0x03

	if (transfer.addr_count < pkg->addr_length) {
    16ee:	8c 81       	ldd	r24, Y+4	; 0x04
    16f0:	9d 81       	ldd	r25, Y+5	; 0x05
    16f2:	14 96       	adiw	r26, 0x04	; 4
    16f4:	2d 91       	ld	r18, X+
    16f6:	3c 91       	ld	r19, X
    16f8:	15 97       	sbiw	r26, 0x05	; 5
    16fa:	82 17       	cp	r24, r18
    16fc:	93 07       	cpc	r25, r19
    16fe:	6c f4       	brge	.+26     	; 0x171a <twim_interrupt_handler+0x6c>

		const uint8_t * const data = pkg->addr;
		bus->MASTER.DATA = data[transfer.addr_count++];
    1700:	9c 01       	movw	r18, r24
    1702:	2f 5f       	subi	r18, 0xFF	; 255
    1704:	3f 4f       	sbci	r19, 0xFF	; 255
    1706:	20 93 5a 22 	sts	0x225A, r18	; 0x80225a <transfer+0x4>
    170a:	30 93 5b 22 	sts	0x225B, r19	; 0x80225b <transfer+0x5>
    170e:	a8 0f       	add	r26, r24
    1710:	b9 1f       	adc	r27, r25
    1712:	11 96       	adiw	r26, 0x01	; 1
    1714:	8c 91       	ld	r24, X
    1716:	87 83       	std	Z+7, r24	; 0x07
    1718:	5e c0       	rjmp	.+188    	; 0x17d6 <twim_interrupt_handler+0x128>

	} else if (transfer.data_count < pkg->length) {
    171a:	80 91 5c 22 	lds	r24, 0x225C	; 0x80225c <transfer+0x6>
    171e:	90 91 5d 22 	lds	r25, 0x225D	; 0x80225d <transfer+0x7>
    1722:	18 96       	adiw	r26, 0x08	; 8
    1724:	2d 91       	ld	r18, X+
    1726:	3c 91       	ld	r19, X
    1728:	19 97       	sbiw	r26, 0x09	; 9
    172a:	82 17       	cp	r24, r18
    172c:	93 07       	cpc	r25, r19
    172e:	c8 f4       	brcc	.+50     	; 0x1762 <twim_interrupt_handler+0xb4>

		if (transfer.read) {
    1730:	20 91 5e 22 	lds	r18, 0x225E	; 0x80225e <transfer+0x8>
    1734:	22 23       	and	r18, r18
    1736:	21 f0       	breq	.+8      	; 0x1740 <twim_interrupt_handler+0x92>

			/* Send repeated START condition (Address|R/W=1). */

			bus->MASTER.ADDR |= 0x01;
    1738:	86 81       	ldd	r24, Z+6	; 0x06
    173a:	81 60       	ori	r24, 0x01	; 1
    173c:	86 83       	std	Z+6, r24	; 0x06
    173e:	4b c0       	rjmp	.+150    	; 0x17d6 <twim_interrupt_handler+0x128>

		} else {
			const uint8_t * const data = pkg->buffer;
    1740:	16 96       	adiw	r26, 0x06	; 6
    1742:	2d 91       	ld	r18, X+
    1744:	3c 91       	ld	r19, X
    1746:	17 97       	sbiw	r26, 0x07	; 7
			bus->MASTER.DATA = data[transfer.data_count++];
    1748:	ac 01       	movw	r20, r24
    174a:	4f 5f       	subi	r20, 0xFF	; 255
    174c:	5f 4f       	sbci	r21, 0xFF	; 255
    174e:	40 93 5c 22 	sts	0x225C, r20	; 0x80225c <transfer+0x6>
    1752:	50 93 5d 22 	sts	0x225D, r21	; 0x80225d <transfer+0x7>
    1756:	d9 01       	movw	r26, r18
    1758:	a8 0f       	add	r26, r24
    175a:	b9 1f       	adc	r27, r25
    175c:	8c 91       	ld	r24, X
    175e:	87 83       	std	Z+7, r24	; 0x07
    1760:	3a c0       	rjmp	.+116    	; 0x17d6 <twim_interrupt_handler+0x128>

	} else {

		/* Send STOP condition to complete the transaction. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1762:	83 e0       	ldi	r24, 0x03	; 3
    1764:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = STATUS_OK;
    1766:	10 92 60 22 	sts	0x2260, r1	; 0x802260 <transfer+0xa>
    176a:	35 c0       	rjmp	.+106    	; 0x17d6 <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {

		twim_write_handler();

	} else if (master_status & TWI_MASTER_RIF_bm) {
    176c:	88 23       	and	r24, r24
    176e:	84 f5       	brge	.+96     	; 0x17d0 <twim_interrupt_handler+0x122>
 *  reading bytes from the TWI slave.
 */
static inline void twim_read_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    1770:	a6 e5       	ldi	r26, 0x56	; 86
    1772:	b2 e2       	ldi	r27, 0x22	; 34
    1774:	12 96       	adiw	r26, 0x02	; 2
    1776:	cd 91       	ld	r28, X+
    1778:	dc 91       	ld	r29, X
    177a:	13 97       	sbiw	r26, 0x03	; 3

	if (transfer.data_count < pkg->length) {
    177c:	16 96       	adiw	r26, 0x06	; 6
    177e:	8d 91       	ld	r24, X+
    1780:	9c 91       	ld	r25, X
    1782:	17 97       	sbiw	r26, 0x07	; 7
    1784:	28 85       	ldd	r18, Y+8	; 0x08
    1786:	39 85       	ldd	r19, Y+9	; 0x09
    1788:	82 17       	cp	r24, r18
    178a:	93 07       	cpc	r25, r19
    178c:	d8 f4       	brcc	.+54     	; 0x17c4 <twim_interrupt_handler+0x116>

		uint8_t * const data = pkg->buffer;
    178e:	6e 81       	ldd	r22, Y+6	; 0x06
    1790:	7f 81       	ldd	r23, Y+7	; 0x07
		data[transfer.data_count++] = bus->MASTER.DATA;
    1792:	9c 01       	movw	r18, r24
    1794:	2f 5f       	subi	r18, 0xFF	; 255
    1796:	3f 4f       	sbci	r19, 0xFF	; 255
    1798:	20 93 5c 22 	sts	0x225C, r18	; 0x80225c <transfer+0x6>
    179c:	30 93 5d 22 	sts	0x225D, r19	; 0x80225d <transfer+0x7>
    17a0:	47 81       	ldd	r20, Z+7	; 0x07
    17a2:	db 01       	movw	r26, r22
    17a4:	a8 0f       	add	r26, r24
    17a6:	b9 1f       	adc	r27, r25
    17a8:	4c 93       	st	X, r20

		/* If there is more to read, issue ACK and start a byte read.
		 * Otherwise, issue NACK and STOP to complete the transaction.
		 */
		if (transfer.data_count < pkg->length) {
    17aa:	88 85       	ldd	r24, Y+8	; 0x08
    17ac:	99 85       	ldd	r25, Y+9	; 0x09
    17ae:	28 17       	cp	r18, r24
    17b0:	39 07       	cpc	r19, r25
    17b2:	18 f4       	brcc	.+6      	; 0x17ba <twim_interrupt_handler+0x10c>

			bus->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    17b4:	82 e0       	ldi	r24, 0x02	; 2
    17b6:	83 83       	std	Z+3, r24	; 0x03
    17b8:	0e c0       	rjmp	.+28     	; 0x17d6 <twim_interrupt_handler+0x128>

		} else {

			bus->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    17ba:	87 e0       	ldi	r24, 0x07	; 7
    17bc:	83 83       	std	Z+3, r24	; 0x03
			transfer.status = STATUS_OK;
    17be:	10 92 60 22 	sts	0x2260, r1	; 0x802260 <transfer+0xa>
    17c2:	09 c0       	rjmp	.+18     	; 0x17d6 <twim_interrupt_handler+0x128>

	} else {

		/* Issue STOP and buffer overflow condition. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    17c4:	83 e0       	ldi	r24, 0x03	; 3
    17c6:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_NO_MEMORY;
    17c8:	89 ef       	ldi	r24, 0xF9	; 249
    17ca:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <transfer+0xa>
    17ce:	03 c0       	rjmp	.+6      	; 0x17d6 <twim_interrupt_handler+0x128>

		twim_read_handler();

	} else {

		transfer.status = ERR_PROTOCOL;
    17d0:	8b ef       	ldi	r24, 0xFB	; 251
    17d2:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <transfer+0xa>
	}
}
    17d6:	df 91       	pop	r29
    17d8:	cf 91       	pop	r28
    17da:	08 95       	ret

000017dc <__vector_13>:
 * parameters specified in the global \c transfer structure.
 */
static void twim_interrupt_handler(void);

#ifdef TWIC
ISR(TWIC_TWIM_vect) { twim_interrupt_handler(); }
    17dc:	1f 92       	push	r1
    17de:	0f 92       	push	r0
    17e0:	0f b6       	in	r0, 0x3f	; 63
    17e2:	0f 92       	push	r0
    17e4:	11 24       	eor	r1, r1
    17e6:	0b b6       	in	r0, 0x3b	; 59
    17e8:	0f 92       	push	r0
    17ea:	2f 93       	push	r18
    17ec:	3f 93       	push	r19
    17ee:	4f 93       	push	r20
    17f0:	5f 93       	push	r21
    17f2:	6f 93       	push	r22
    17f4:	7f 93       	push	r23
    17f6:	8f 93       	push	r24
    17f8:	9f 93       	push	r25
    17fa:	af 93       	push	r26
    17fc:	bf 93       	push	r27
    17fe:	ef 93       	push	r30
    1800:	ff 93       	push	r31
    1802:	55 df       	rcall	.-342    	; 0x16ae <twim_interrupt_handler>
    1804:	ff 91       	pop	r31
    1806:	ef 91       	pop	r30
    1808:	bf 91       	pop	r27
    180a:	af 91       	pop	r26
    180c:	9f 91       	pop	r25
    180e:	8f 91       	pop	r24
    1810:	7f 91       	pop	r23
    1812:	6f 91       	pop	r22
    1814:	5f 91       	pop	r21
    1816:	4f 91       	pop	r20
    1818:	3f 91       	pop	r19
    181a:	2f 91       	pop	r18
    181c:	0f 90       	pop	r0
    181e:	0b be       	out	0x3b, r0	; 59
    1820:	0f 90       	pop	r0
    1822:	0f be       	out	0x3f, r0	; 63
    1824:	0f 90       	pop	r0
    1826:	1f 90       	pop	r1
    1828:	18 95       	reti

0000182a <__vector_46>:
#endif
#ifdef TWID
ISR(TWID_TWIM_vect) { twim_interrupt_handler(); }
#endif
#ifdef TWIE
ISR(TWIE_TWIM_vect) { twim_interrupt_handler(); }
    182a:	1f 92       	push	r1
    182c:	0f 92       	push	r0
    182e:	0f b6       	in	r0, 0x3f	; 63
    1830:	0f 92       	push	r0
    1832:	11 24       	eor	r1, r1
    1834:	0b b6       	in	r0, 0x3b	; 59
    1836:	0f 92       	push	r0
    1838:	2f 93       	push	r18
    183a:	3f 93       	push	r19
    183c:	4f 93       	push	r20
    183e:	5f 93       	push	r21
    1840:	6f 93       	push	r22
    1842:	7f 93       	push	r23
    1844:	8f 93       	push	r24
    1846:	9f 93       	push	r25
    1848:	af 93       	push	r26
    184a:	bf 93       	push	r27
    184c:	ef 93       	push	r30
    184e:	ff 93       	push	r31
    1850:	2e df       	rcall	.-420    	; 0x16ae <twim_interrupt_handler>
    1852:	ff 91       	pop	r31
    1854:	ef 91       	pop	r30
    1856:	bf 91       	pop	r27
    1858:	af 91       	pop	r26
    185a:	9f 91       	pop	r25
    185c:	8f 91       	pop	r24
    185e:	7f 91       	pop	r23
    1860:	6f 91       	pop	r22
    1862:	5f 91       	pop	r21
    1864:	4f 91       	pop	r20
    1866:	3f 91       	pop	r19
    1868:	2f 91       	pop	r18
    186a:	0f 90       	pop	r0
    186c:	0b be       	out	0x3b, r0	; 59
    186e:	0f 90       	pop	r0
    1870:	0f be       	out	0x3f, r0	; 63
    1872:	0f 90       	pop	r0
    1874:	1f 90       	pop	r1
    1876:	18 95       	reti

00001878 <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1878:	4f 92       	push	r4
    187a:	5f 92       	push	r5
    187c:	6f 92       	push	r6
    187e:	7f 92       	push	r7
    1880:	8f 92       	push	r8
    1882:	9f 92       	push	r9
    1884:	af 92       	push	r10
    1886:	bf 92       	push	r11
    1888:	ef 92       	push	r14
    188a:	ff 92       	push	r15
    188c:	0f 93       	push	r16
    188e:	1f 93       	push	r17
    1890:	cf 93       	push	r28
    1892:	7c 01       	movw	r14, r24
    1894:	4a 01       	movw	r8, r20
    1896:	5b 01       	movw	r10, r22
    1898:	28 01       	movw	r4, r16
    189a:	39 01       	movw	r6, r18
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    189c:	fc 01       	movw	r30, r24
    189e:	84 81       	ldd	r24, Z+4	; 0x04
    18a0:	82 ff       	sbrs	r24, 2
    18a2:	16 c0       	rjmp	.+44     	; 0x18d0 <usart_set_baudrate+0x58>

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    18a4:	d9 01       	movw	r26, r18
    18a6:	c8 01       	movw	r24, r16
    18a8:	68 94       	set
    18aa:	12 f8       	bld	r1, 2
    18ac:	b6 95       	lsr	r27
    18ae:	a7 95       	ror	r26
    18b0:	97 95       	ror	r25
    18b2:	87 95       	ror	r24
    18b4:	16 94       	lsr	r1
    18b6:	d1 f7       	brne	.-12     	; 0x18ac <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    18b8:	b9 01       	movw	r22, r18
    18ba:	a8 01       	movw	r20, r16
    18bc:	03 2e       	mov	r0, r19
    18be:	36 e1       	ldi	r19, 0x16	; 22
    18c0:	76 95       	lsr	r23
    18c2:	67 95       	ror	r22
    18c4:	57 95       	ror	r21
    18c6:	47 95       	ror	r20
    18c8:	3a 95       	dec	r19
    18ca:	d1 f7       	brne	.-12     	; 0x18c0 <usart_set_baudrate+0x48>
    18cc:	30 2d       	mov	r19, r0
    18ce:	15 c0       	rjmp	.+42     	; 0x18fa <usart_set_baudrate+0x82>

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
		max_rate /= 2;
    18d0:	d9 01       	movw	r26, r18
    18d2:	c8 01       	movw	r24, r16
    18d4:	68 94       	set
    18d6:	13 f8       	bld	r1, 3
    18d8:	b6 95       	lsr	r27
    18da:	a7 95       	ror	r26
    18dc:	97 95       	ror	r25
    18de:	87 95       	ror	r24
    18e0:	16 94       	lsr	r1
    18e2:	d1 f7       	brne	.-12     	; 0x18d8 <usart_set_baudrate+0x60>
		min_rate /= 2;
    18e4:	b9 01       	movw	r22, r18
    18e6:	a8 01       	movw	r20, r16
    18e8:	03 2e       	mov	r0, r19
    18ea:	37 e1       	ldi	r19, 0x17	; 23
    18ec:	76 95       	lsr	r23
    18ee:	67 95       	ror	r22
    18f0:	57 95       	ror	r21
    18f2:	47 95       	ror	r20
    18f4:	3a 95       	dec	r19
    18f6:	d1 f7       	brne	.-12     	; 0x18ec <usart_set_baudrate+0x74>
    18f8:	30 2d       	mov	r19, r0
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    18fa:	88 15       	cp	r24, r8
    18fc:	99 05       	cpc	r25, r9
    18fe:	aa 05       	cpc	r26, r10
    1900:	bb 05       	cpc	r27, r11
    1902:	08 f4       	brcc	.+2      	; 0x1906 <usart_set_baudrate+0x8e>
    1904:	a6 c0       	rjmp	.+332    	; 0x1a52 <usart_set_baudrate+0x1da>
    1906:	84 16       	cp	r8, r20
    1908:	95 06       	cpc	r9, r21
    190a:	a6 06       	cpc	r10, r22
    190c:	b7 06       	cpc	r11, r23
    190e:	08 f4       	brcc	.+2      	; 0x1912 <usart_set_baudrate+0x9a>
    1910:	a2 c0       	rjmp	.+324    	; 0x1a56 <usart_set_baudrate+0x1de>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    1912:	f7 01       	movw	r30, r14
    1914:	84 81       	ldd	r24, Z+4	; 0x04
    1916:	82 fd       	sbrc	r24, 2
    1918:	04 c0       	rjmp	.+8      	; 0x1922 <usart_set_baudrate+0xaa>
		baud *= 2;
    191a:	88 0c       	add	r8, r8
    191c:	99 1c       	adc	r9, r9
    191e:	aa 1c       	adc	r10, r10
    1920:	bb 1c       	adc	r11, r11
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    1922:	c3 01       	movw	r24, r6
    1924:	b2 01       	movw	r22, r4
    1926:	a5 01       	movw	r20, r10
    1928:	94 01       	movw	r18, r8
    192a:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    192e:	2f 3f       	cpi	r18, 0xFF	; 255
    1930:	31 05       	cpc	r19, r1
    1932:	41 05       	cpc	r20, r1
    1934:	51 05       	cpc	r21, r1
    1936:	08 f4       	brcc	.+2      	; 0x193a <usart_set_baudrate+0xc2>
    1938:	90 c0       	rjmp	.+288    	; 0x1a5a <usart_set_baudrate+0x1e2>
    193a:	8f ef       	ldi	r24, 0xFF	; 255
    193c:	90 e0       	ldi	r25, 0x00	; 0
    193e:	a0 e0       	ldi	r26, 0x00	; 0
    1940:	b0 e0       	ldi	r27, 0x00	; 0
    1942:	c9 ef       	ldi	r28, 0xF9	; 249
    1944:	05 c0       	rjmp	.+10     	; 0x1950 <usart_set_baudrate+0xd8>
    1946:	28 17       	cp	r18, r24
    1948:	39 07       	cpc	r19, r25
    194a:	4a 07       	cpc	r20, r26
    194c:	5b 07       	cpc	r21, r27
    194e:	58 f0       	brcs	.+22     	; 0x1966 <usart_set_baudrate+0xee>
			break;
		}

		limit <<= 1;
    1950:	88 0f       	add	r24, r24
    1952:	99 1f       	adc	r25, r25
    1954:	aa 1f       	adc	r26, r26
    1956:	bb 1f       	adc	r27, r27

		if (exp < -3) {
    1958:	cd 3f       	cpi	r28, 0xFD	; 253
    195a:	0c f4       	brge	.+2      	; 0x195e <usart_set_baudrate+0xe6>
			limit |= 1;
    195c:	81 60       	ori	r24, 0x01	; 1
    195e:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1960:	c7 30       	cpi	r28, 0x07	; 7
    1962:	89 f7       	brne	.-30     	; 0x1946 <usart_set_baudrate+0xce>
    1964:	4f c0       	rjmp	.+158    	; 0x1a04 <usart_set_baudrate+0x18c>
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    1966:	cc 23       	and	r28, r28
    1968:	0c f0       	brlt	.+2      	; 0x196c <usart_set_baudrate+0xf4>
    196a:	4c c0       	rjmp	.+152    	; 0x1a04 <usart_set_baudrate+0x18c>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    196c:	d5 01       	movw	r26, r10
    196e:	c4 01       	movw	r24, r8
    1970:	88 0f       	add	r24, r24
    1972:	99 1f       	adc	r25, r25
    1974:	aa 1f       	adc	r26, r26
    1976:	bb 1f       	adc	r27, r27
    1978:	88 0f       	add	r24, r24
    197a:	99 1f       	adc	r25, r25
    197c:	aa 1f       	adc	r26, r26
    197e:	bb 1f       	adc	r27, r27
    1980:	88 0f       	add	r24, r24
    1982:	99 1f       	adc	r25, r25
    1984:	aa 1f       	adc	r26, r26
    1986:	bb 1f       	adc	r27, r27
    1988:	48 1a       	sub	r4, r24
    198a:	59 0a       	sbc	r5, r25
    198c:	6a 0a       	sbc	r6, r26
    198e:	7b 0a       	sbc	r7, r27
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    1990:	ce 3f       	cpi	r28, 0xFE	; 254
    1992:	f4 f4       	brge	.+60     	; 0x19d0 <usart_set_baudrate+0x158>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    1994:	8d ef       	ldi	r24, 0xFD	; 253
    1996:	9f ef       	ldi	r25, 0xFF	; 255
    1998:	8c 1b       	sub	r24, r28
    199a:	91 09       	sbc	r25, r1
    199c:	c7 fd       	sbrc	r28, 7
    199e:	93 95       	inc	r25
    19a0:	04 c0       	rjmp	.+8      	; 0x19aa <usart_set_baudrate+0x132>
    19a2:	44 0c       	add	r4, r4
    19a4:	55 1c       	adc	r5, r5
    19a6:	66 1c       	adc	r6, r6
    19a8:	77 1c       	adc	r7, r7
    19aa:	8a 95       	dec	r24
    19ac:	d2 f7       	brpl	.-12     	; 0x19a2 <usart_set_baudrate+0x12a>
    19ae:	d5 01       	movw	r26, r10
    19b0:	c4 01       	movw	r24, r8
    19b2:	b6 95       	lsr	r27
    19b4:	a7 95       	ror	r26
    19b6:	97 95       	ror	r25
    19b8:	87 95       	ror	r24
    19ba:	bc 01       	movw	r22, r24
    19bc:	cd 01       	movw	r24, r26
    19be:	64 0d       	add	r22, r4
    19c0:	75 1d       	adc	r23, r5
    19c2:	86 1d       	adc	r24, r6
    19c4:	97 1d       	adc	r25, r7
    19c6:	a5 01       	movw	r20, r10
    19c8:	94 01       	movw	r18, r8
    19ca:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <__udivmodsi4>
    19ce:	37 c0       	rjmp	.+110    	; 0x1a3e <usart_set_baudrate+0x1c6>
		} else {
			baud <<= exp + 3;
    19d0:	83 e0       	ldi	r24, 0x03	; 3
    19d2:	8c 0f       	add	r24, r28
    19d4:	a5 01       	movw	r20, r10
    19d6:	94 01       	movw	r18, r8
    19d8:	04 c0       	rjmp	.+8      	; 0x19e2 <usart_set_baudrate+0x16a>
    19da:	22 0f       	add	r18, r18
    19dc:	33 1f       	adc	r19, r19
    19de:	44 1f       	adc	r20, r20
    19e0:	55 1f       	adc	r21, r21
    19e2:	8a 95       	dec	r24
    19e4:	d2 f7       	brpl	.-12     	; 0x19da <usart_set_baudrate+0x162>
			div = (cpu_hz + baud / 2) / baud;
    19e6:	da 01       	movw	r26, r20
    19e8:	c9 01       	movw	r24, r18
    19ea:	b6 95       	lsr	r27
    19ec:	a7 95       	ror	r26
    19ee:	97 95       	ror	r25
    19f0:	87 95       	ror	r24
    19f2:	bc 01       	movw	r22, r24
    19f4:	cd 01       	movw	r24, r26
    19f6:	64 0d       	add	r22, r4
    19f8:	75 1d       	adc	r23, r5
    19fa:	86 1d       	adc	r24, r6
    19fc:	97 1d       	adc	r25, r7
    19fe:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <__udivmodsi4>
    1a02:	1d c0       	rjmp	.+58     	; 0x1a3e <usart_set_baudrate+0x1c6>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    1a04:	83 e0       	ldi	r24, 0x03	; 3
    1a06:	8c 0f       	add	r24, r28
    1a08:	a5 01       	movw	r20, r10
    1a0a:	94 01       	movw	r18, r8
    1a0c:	04 c0       	rjmp	.+8      	; 0x1a16 <usart_set_baudrate+0x19e>
    1a0e:	22 0f       	add	r18, r18
    1a10:	33 1f       	adc	r19, r19
    1a12:	44 1f       	adc	r20, r20
    1a14:	55 1f       	adc	r21, r21
    1a16:	8a 95       	dec	r24
    1a18:	d2 f7       	brpl	.-12     	; 0x1a0e <usart_set_baudrate+0x196>
		div = (cpu_hz + baud / 2) / baud - 1;
    1a1a:	da 01       	movw	r26, r20
    1a1c:	c9 01       	movw	r24, r18
    1a1e:	b6 95       	lsr	r27
    1a20:	a7 95       	ror	r26
    1a22:	97 95       	ror	r25
    1a24:	87 95       	ror	r24
    1a26:	bc 01       	movw	r22, r24
    1a28:	cd 01       	movw	r24, r26
    1a2a:	64 0d       	add	r22, r4
    1a2c:	75 1d       	adc	r23, r5
    1a2e:	86 1d       	adc	r24, r6
    1a30:	97 1d       	adc	r25, r7
    1a32:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <__udivmodsi4>
    1a36:	21 50       	subi	r18, 0x01	; 1
    1a38:	31 09       	sbc	r19, r1
    1a3a:	41 09       	sbc	r20, r1
    1a3c:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    1a3e:	83 2f       	mov	r24, r19
    1a40:	8f 70       	andi	r24, 0x0F	; 15
    1a42:	c2 95       	swap	r28
    1a44:	c0 7f       	andi	r28, 0xF0	; 240
    1a46:	c8 2b       	or	r28, r24
    1a48:	f7 01       	movw	r30, r14
    1a4a:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    1a4c:	26 83       	std	Z+6, r18	; 0x06

	return true;
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	18 c0       	rjmp	.+48     	; 0x1a82 <usart_set_baudrate+0x20a>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    1a52:	80 e0       	ldi	r24, 0x00	; 0
    1a54:	16 c0       	rjmp	.+44     	; 0x1a82 <usart_set_baudrate+0x20a>
    1a56:	80 e0       	ldi	r24, 0x00	; 0
    1a58:	14 c0       	rjmp	.+40     	; 0x1a82 <usart_set_baudrate+0x20a>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    1a5a:	d5 01       	movw	r26, r10
    1a5c:	c4 01       	movw	r24, r8
    1a5e:	88 0f       	add	r24, r24
    1a60:	99 1f       	adc	r25, r25
    1a62:	aa 1f       	adc	r26, r26
    1a64:	bb 1f       	adc	r27, r27
    1a66:	88 0f       	add	r24, r24
    1a68:	99 1f       	adc	r25, r25
    1a6a:	aa 1f       	adc	r26, r26
    1a6c:	bb 1f       	adc	r27, r27
    1a6e:	88 0f       	add	r24, r24
    1a70:	99 1f       	adc	r25, r25
    1a72:	aa 1f       	adc	r26, r26
    1a74:	bb 1f       	adc	r27, r27
    1a76:	48 1a       	sub	r4, r24
    1a78:	59 0a       	sbc	r5, r25
    1a7a:	6a 0a       	sbc	r6, r26
    1a7c:	7b 0a       	sbc	r7, r27

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1a7e:	c9 ef       	ldi	r28, 0xF9	; 249
    1a80:	89 cf       	rjmp	.-238    	; 0x1994 <usart_set_baudrate+0x11c>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    1a82:	cf 91       	pop	r28
    1a84:	1f 91       	pop	r17
    1a86:	0f 91       	pop	r16
    1a88:	ff 90       	pop	r15
    1a8a:	ef 90       	pop	r14
    1a8c:	bf 90       	pop	r11
    1a8e:	af 90       	pop	r10
    1a90:	9f 90       	pop	r9
    1a92:	8f 90       	pop	r8
    1a94:	7f 90       	pop	r7
    1a96:	6f 90       	pop	r6
    1a98:	5f 90       	pop	r5
    1a9a:	4f 90       	pop	r4
    1a9c:	08 95       	ret

00001a9e <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    1a9e:	0f 93       	push	r16
    1aa0:	1f 93       	push	r17
    1aa2:	cf 93       	push	r28
    1aa4:	df 93       	push	r29
    1aa6:	ec 01       	movw	r28, r24
    1aa8:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1aaa:	00 97       	sbiw	r24, 0x00	; 0
    1aac:	09 f4       	brne	.+2      	; 0x1ab0 <usart_init_rs232+0x12>
    1aae:	03 c1       	rjmp	.+518    	; 0x1cb6 <usart_init_rs232+0x218>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1ab0:	80 3c       	cpi	r24, 0xC0	; 192
    1ab2:	91 05       	cpc	r25, r1
    1ab4:	29 f4       	brne	.+10     	; 0x1ac0 <usart_init_rs232+0x22>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1ab6:	60 e1       	ldi	r22, 0x10	; 16
    1ab8:	80 e0       	ldi	r24, 0x00	; 0
    1aba:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1abe:	fb c0       	rjmp	.+502    	; 0x1cb6 <usart_init_rs232+0x218>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1ac0:	c0 38       	cpi	r28, 0x80	; 128
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	d8 07       	cpc	r29, r24
    1ac6:	29 f4       	brne	.+10     	; 0x1ad2 <usart_init_rs232+0x34>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1ac8:	62 e0       	ldi	r22, 0x02	; 2
    1aca:	80 e0       	ldi	r24, 0x00	; 0
    1acc:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ad0:	f2 c0       	rjmp	.+484    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1ad2:	c1 15       	cp	r28, r1
    1ad4:	e1 e0       	ldi	r30, 0x01	; 1
    1ad6:	de 07       	cpc	r29, r30
    1ad8:	29 f4       	brne	.+10     	; 0x1ae4 <usart_init_rs232+0x46>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1ada:	61 e0       	ldi	r22, 0x01	; 1
    1adc:	80 e0       	ldi	r24, 0x00	; 0
    1ade:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ae2:	e9 c0       	rjmp	.+466    	; 0x1cb6 <usart_init_rs232+0x218>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1ae4:	c0 38       	cpi	r28, 0x80	; 128
    1ae6:	f3 e0       	ldi	r31, 0x03	; 3
    1ae8:	df 07       	cpc	r29, r31
    1aea:	29 f4       	brne	.+10     	; 0x1af6 <usart_init_rs232+0x58>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1aec:	61 e0       	ldi	r22, 0x01	; 1
    1aee:	81 e0       	ldi	r24, 0x01	; 1
    1af0:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1af4:	e0 c0       	rjmp	.+448    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1af6:	c0 39       	cpi	r28, 0x90	; 144
    1af8:	83 e0       	ldi	r24, 0x03	; 3
    1afa:	d8 07       	cpc	r29, r24
    1afc:	29 f4       	brne	.+10     	; 0x1b08 <usart_init_rs232+0x6a>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1afe:	61 e0       	ldi	r22, 0x01	; 1
    1b00:	82 e0       	ldi	r24, 0x02	; 2
    1b02:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b06:	d7 c0       	rjmp	.+430    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1b08:	c1 15       	cp	r28, r1
    1b0a:	e2 e0       	ldi	r30, 0x02	; 2
    1b0c:	de 07       	cpc	r29, r30
    1b0e:	29 f4       	brne	.+10     	; 0x1b1a <usart_init_rs232+0x7c>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1b10:	62 e0       	ldi	r22, 0x02	; 2
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b18:	ce c0       	rjmp	.+412    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1b1a:	c0 34       	cpi	r28, 0x40	; 64
    1b1c:	f2 e0       	ldi	r31, 0x02	; 2
    1b1e:	df 07       	cpc	r29, r31
    1b20:	29 f4       	brne	.+10     	; 0x1b2c <usart_init_rs232+0x8e>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1b22:	62 e0       	ldi	r22, 0x02	; 2
    1b24:	82 e0       	ldi	r24, 0x02	; 2
    1b26:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b2a:	c5 c0       	rjmp	.+394    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1b2c:	c0 32       	cpi	r28, 0x20	; 32
    1b2e:	83 e0       	ldi	r24, 0x03	; 3
    1b30:	d8 07       	cpc	r29, r24
    1b32:	29 f4       	brne	.+10     	; 0x1b3e <usart_init_rs232+0xa0>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1b34:	64 e0       	ldi	r22, 0x04	; 4
    1b36:	82 e0       	ldi	r24, 0x02	; 2
    1b38:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b3c:	bc c0       	rjmp	.+376    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1b3e:	c1 15       	cp	r28, r1
    1b40:	e8 e0       	ldi	r30, 0x08	; 8
    1b42:	de 07       	cpc	r29, r30
    1b44:	29 f4       	brne	.+10     	; 0x1b50 <usart_init_rs232+0xb2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1b46:	61 e0       	ldi	r22, 0x01	; 1
    1b48:	83 e0       	ldi	r24, 0x03	; 3
    1b4a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b4e:	b3 c0       	rjmp	.+358    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1b50:	c1 15       	cp	r28, r1
    1b52:	f9 e0       	ldi	r31, 0x09	; 9
    1b54:	df 07       	cpc	r29, r31
    1b56:	29 f4       	brne	.+10     	; 0x1b62 <usart_init_rs232+0xc4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1b58:	61 e0       	ldi	r22, 0x01	; 1
    1b5a:	84 e0       	ldi	r24, 0x04	; 4
    1b5c:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b60:	aa c0       	rjmp	.+340    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1b62:	c1 15       	cp	r28, r1
    1b64:	8a e0       	ldi	r24, 0x0A	; 10
    1b66:	d8 07       	cpc	r29, r24
    1b68:	29 f4       	brne	.+10     	; 0x1b74 <usart_init_rs232+0xd6>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1b6a:	61 e0       	ldi	r22, 0x01	; 1
    1b6c:	85 e0       	ldi	r24, 0x05	; 5
    1b6e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b72:	a1 c0       	rjmp	.+322    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1b74:	c1 15       	cp	r28, r1
    1b76:	eb e0       	ldi	r30, 0x0B	; 11
    1b78:	de 07       	cpc	r29, r30
    1b7a:	29 f4       	brne	.+10     	; 0x1b86 <usart_init_rs232+0xe8>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1b7c:	61 e0       	ldi	r22, 0x01	; 1
    1b7e:	86 e0       	ldi	r24, 0x06	; 6
    1b80:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b84:	98 c0       	rjmp	.+304    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1b86:	c0 34       	cpi	r28, 0x40	; 64
    1b88:	f8 e0       	ldi	r31, 0x08	; 8
    1b8a:	df 07       	cpc	r29, r31
    1b8c:	29 f4       	brne	.+10     	; 0x1b98 <usart_init_rs232+0xfa>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1b8e:	62 e0       	ldi	r22, 0x02	; 2
    1b90:	83 e0       	ldi	r24, 0x03	; 3
    1b92:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b96:	8f c0       	rjmp	.+286    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1b98:	c0 34       	cpi	r28, 0x40	; 64
    1b9a:	89 e0       	ldi	r24, 0x09	; 9
    1b9c:	d8 07       	cpc	r29, r24
    1b9e:	29 f4       	brne	.+10     	; 0x1baa <usart_init_rs232+0x10c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1ba0:	62 e0       	ldi	r22, 0x02	; 2
    1ba2:	84 e0       	ldi	r24, 0x04	; 4
    1ba4:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ba8:	86 c0       	rjmp	.+268    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1baa:	c0 34       	cpi	r28, 0x40	; 64
    1bac:	ea e0       	ldi	r30, 0x0A	; 10
    1bae:	de 07       	cpc	r29, r30
    1bb0:	29 f4       	brne	.+10     	; 0x1bbc <usart_init_rs232+0x11e>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1bb2:	62 e0       	ldi	r22, 0x02	; 2
    1bb4:	85 e0       	ldi	r24, 0x05	; 5
    1bb6:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1bba:	7d c0       	rjmp	.+250    	; 0x1cb6 <usart_init_rs232+0x218>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1bbc:	c0 39       	cpi	r28, 0x90	; 144
    1bbe:	f8 e0       	ldi	r31, 0x08	; 8
    1bc0:	df 07       	cpc	r29, r31
    1bc2:	29 f4       	brne	.+10     	; 0x1bce <usart_init_rs232+0x130>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1bc4:	64 e0       	ldi	r22, 0x04	; 4
    1bc6:	83 e0       	ldi	r24, 0x03	; 3
    1bc8:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1bcc:	74 c0       	rjmp	.+232    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1bce:	c0 39       	cpi	r28, 0x90	; 144
    1bd0:	89 e0       	ldi	r24, 0x09	; 9
    1bd2:	d8 07       	cpc	r29, r24
    1bd4:	29 f4       	brne	.+10     	; 0x1be0 <usart_init_rs232+0x142>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1bd6:	64 e0       	ldi	r22, 0x04	; 4
    1bd8:	84 e0       	ldi	r24, 0x04	; 4
    1bda:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1bde:	6b c0       	rjmp	.+214    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1be0:	c0 39       	cpi	r28, 0x90	; 144
    1be2:	ea e0       	ldi	r30, 0x0A	; 10
    1be4:	de 07       	cpc	r29, r30
    1be6:	29 f4       	brne	.+10     	; 0x1bf2 <usart_init_rs232+0x154>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1be8:	64 e0       	ldi	r22, 0x04	; 4
    1bea:	85 e0       	ldi	r24, 0x05	; 5
    1bec:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1bf0:	62 c0       	rjmp	.+196    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1bf2:	c0 39       	cpi	r28, 0x90	; 144
    1bf4:	fb e0       	ldi	r31, 0x0B	; 11
    1bf6:	df 07       	cpc	r29, r31
    1bf8:	29 f4       	brne	.+10     	; 0x1c04 <usart_init_rs232+0x166>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1bfa:	64 e0       	ldi	r22, 0x04	; 4
    1bfc:	86 e0       	ldi	r24, 0x06	; 6
    1bfe:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c02:	59 c0       	rjmp	.+178    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1c04:	c0 3c       	cpi	r28, 0xC0	; 192
    1c06:	88 e0       	ldi	r24, 0x08	; 8
    1c08:	d8 07       	cpc	r29, r24
    1c0a:	29 f4       	brne	.+10     	; 0x1c16 <usart_init_rs232+0x178>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1c0c:	68 e0       	ldi	r22, 0x08	; 8
    1c0e:	83 e0       	ldi	r24, 0x03	; 3
    1c10:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c14:	50 c0       	rjmp	.+160    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1c16:	c0 3c       	cpi	r28, 0xC0	; 192
    1c18:	e9 e0       	ldi	r30, 0x09	; 9
    1c1a:	de 07       	cpc	r29, r30
    1c1c:	29 f4       	brne	.+10     	; 0x1c28 <usart_init_rs232+0x18a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1c1e:	68 e0       	ldi	r22, 0x08	; 8
    1c20:	84 e0       	ldi	r24, 0x04	; 4
    1c22:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c26:	47 c0       	rjmp	.+142    	; 0x1cb6 <usart_init_rs232+0x218>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1c28:	c0 3a       	cpi	r28, 0xA0	; 160
    1c2a:	f8 e0       	ldi	r31, 0x08	; 8
    1c2c:	df 07       	cpc	r29, r31
    1c2e:	29 f4       	brne	.+10     	; 0x1c3a <usart_init_rs232+0x19c>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1c30:	60 e1       	ldi	r22, 0x10	; 16
    1c32:	83 e0       	ldi	r24, 0x03	; 3
    1c34:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c38:	3e c0       	rjmp	.+124    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1c3a:	c0 3a       	cpi	r28, 0xA0	; 160
    1c3c:	89 e0       	ldi	r24, 0x09	; 9
    1c3e:	d8 07       	cpc	r29, r24
    1c40:	29 f4       	brne	.+10     	; 0x1c4c <usart_init_rs232+0x1ae>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1c42:	60 e1       	ldi	r22, 0x10	; 16
    1c44:	84 e0       	ldi	r24, 0x04	; 4
    1c46:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c4a:	35 c0       	rjmp	.+106    	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1c4c:	c0 3a       	cpi	r28, 0xA0	; 160
    1c4e:	ea e0       	ldi	r30, 0x0A	; 10
    1c50:	de 07       	cpc	r29, r30
    1c52:	29 f4       	brne	.+10     	; 0x1c5e <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1c54:	60 e1       	ldi	r22, 0x10	; 16
    1c56:	85 e0       	ldi	r24, 0x05	; 5
    1c58:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c5c:	2c c0       	rjmp	.+88     	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1c5e:	c0 3a       	cpi	r28, 0xA0	; 160
    1c60:	fb e0       	ldi	r31, 0x0B	; 11
    1c62:	df 07       	cpc	r29, r31
    1c64:	29 f4       	brne	.+10     	; 0x1c70 <usart_init_rs232+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1c66:	60 e1       	ldi	r22, 0x10	; 16
    1c68:	86 e0       	ldi	r24, 0x06	; 6
    1c6a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c6e:	23 c0       	rjmp	.+70     	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1c70:	c0 3b       	cpi	r28, 0xB0	; 176
    1c72:	88 e0       	ldi	r24, 0x08	; 8
    1c74:	d8 07       	cpc	r29, r24
    1c76:	29 f4       	brne	.+10     	; 0x1c82 <usart_init_rs232+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1c78:	60 e2       	ldi	r22, 0x20	; 32
    1c7a:	83 e0       	ldi	r24, 0x03	; 3
    1c7c:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c80:	1a c0       	rjmp	.+52     	; 0x1cb6 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1c82:	c0 3b       	cpi	r28, 0xB0	; 176
    1c84:	e9 e0       	ldi	r30, 0x09	; 9
    1c86:	de 07       	cpc	r29, r30
    1c88:	29 f4       	brne	.+10     	; 0x1c94 <usart_init_rs232+0x1f6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1c8a:	60 e2       	ldi	r22, 0x20	; 32
    1c8c:	84 e0       	ldi	r24, 0x04	; 4
    1c8e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c92:	11 c0       	rjmp	.+34     	; 0x1cb6 <usart_init_rs232+0x218>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1c94:	c0 38       	cpi	r28, 0x80	; 128
    1c96:	f4 e0       	ldi	r31, 0x04	; 4
    1c98:	df 07       	cpc	r29, r31
    1c9a:	29 f4       	brne	.+10     	; 0x1ca6 <usart_init_rs232+0x208>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1c9c:	60 e4       	ldi	r22, 0x40	; 64
    1c9e:	83 e0       	ldi	r24, 0x03	; 3
    1ca0:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ca4:	08 c0       	rjmp	.+16     	; 0x1cb6 <usart_init_rs232+0x218>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1ca6:	c0 3a       	cpi	r28, 0xA0	; 160
    1ca8:	84 e0       	ldi	r24, 0x04	; 4
    1caa:	d8 07       	cpc	r29, r24
    1cac:	21 f4       	brne	.+8      	; 0x1cb6 <usart_init_rs232+0x218>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1cae:	60 e4       	ldi	r22, 0x40	; 64
    1cb0:	85 e0       	ldi	r24, 0x05	; 5
    1cb2:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1cb6:	8d 81       	ldd	r24, Y+5	; 0x05
    1cb8:	8f 73       	andi	r24, 0x3F	; 63
    1cba:	8d 83       	std	Y+5, r24	; 0x05
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    1cbc:	f8 01       	movw	r30, r16
    1cbe:	95 81       	ldd	r25, Z+5	; 0x05
    1cc0:	84 81       	ldd	r24, Z+4	; 0x04
    1cc2:	89 2b       	or	r24, r25
    1cc4:	96 81       	ldd	r25, Z+6	; 0x06
    1cc6:	91 11       	cpse	r25, r1
    1cc8:	98 e0       	ldi	r25, 0x08	; 8
    1cca:	89 2b       	or	r24, r25
    1ccc:	8d 83       	std	Y+5, r24	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1cce:	f8 01       	movw	r30, r16
    1cd0:	40 81       	ld	r20, Z
    1cd2:	51 81       	ldd	r21, Z+1	; 0x01
    1cd4:	62 81       	ldd	r22, Z+2	; 0x02
    1cd6:	73 81       	ldd	r23, Z+3	; 0x03
    1cd8:	00 e8       	ldi	r16, 0x80	; 128
    1cda:	14 e8       	ldi	r17, 0x84	; 132
    1cdc:	2e e1       	ldi	r18, 0x1E	; 30
    1cde:	30 e0       	ldi	r19, 0x00	; 0
    1ce0:	ce 01       	movw	r24, r28
    1ce2:	ca dd       	rcall	.-1132   	; 0x1878 <usart_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1ce4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce6:	98 60       	ori	r25, 0x08	; 8
    1ce8:	9c 83       	std	Y+4, r25	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1cea:	9c 81       	ldd	r25, Y+4	; 0x04
    1cec:	90 61       	ori	r25, 0x10	; 16
    1cee:	9c 83       	std	Y+4, r25	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    1cf0:	df 91       	pop	r29
    1cf2:	cf 91       	pop	r28
    1cf4:	1f 91       	pop	r17
    1cf6:	0f 91       	pop	r16
    1cf8:	08 95       	ret

00001cfa <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1cfa:	cf 92       	push	r12
    1cfc:	df 92       	push	r13
    1cfe:	ef 92       	push	r14
    1d00:	ff 92       	push	r15
    1d02:	0f 93       	push	r16
    1d04:	1f 93       	push	r17
    1d06:	cf 93       	push	r28
    1d08:	df 93       	push	r29
    1d0a:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1d0c:	d9 01       	movw	r26, r18
    1d0e:	c8 01       	movw	r24, r16
    1d10:	b6 95       	lsr	r27
    1d12:	a7 95       	ror	r26
    1d14:	97 95       	ror	r25
    1d16:	87 95       	ror	r24
    1d18:	48 17       	cp	r20, r24
    1d1a:	59 07       	cpc	r21, r25
    1d1c:	6a 07       	cpc	r22, r26
    1d1e:	7b 07       	cpc	r23, r27
    1d20:	78 f4       	brcc	.+30     	; 0x1d40 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1d22:	6a 01       	movw	r12, r20
    1d24:	7b 01       	movw	r14, r22
    1d26:	cc 0c       	add	r12, r12
    1d28:	dd 1c       	adc	r13, r13
    1d2a:	ee 1c       	adc	r14, r14
    1d2c:	ff 1c       	adc	r15, r15
    1d2e:	c9 01       	movw	r24, r18
    1d30:	b8 01       	movw	r22, r16
    1d32:	a7 01       	movw	r20, r14
    1d34:	96 01       	movw	r18, r12
    1d36:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <__udivmodsi4>
    1d3a:	21 50       	subi	r18, 0x01	; 1
    1d3c:	31 09       	sbc	r19, r1
    1d3e:	02 c0       	rjmp	.+4      	; 0x1d44 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1d40:	20 e0       	ldi	r18, 0x00	; 0
    1d42:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1d44:	83 2f       	mov	r24, r19
    1d46:	8f 70       	andi	r24, 0x0F	; 15
    1d48:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1d4a:	2e 83       	std	Y+6, r18	; 0x06
}
    1d4c:	df 91       	pop	r29
    1d4e:	cf 91       	pop	r28
    1d50:	1f 91       	pop	r17
    1d52:	0f 91       	pop	r16
    1d54:	ff 90       	pop	r15
    1d56:	ef 90       	pop	r14
    1d58:	df 90       	pop	r13
    1d5a:	cf 90       	pop	r12
    1d5c:	08 95       	ret

00001d5e <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1d5e:	df 92       	push	r13
    1d60:	ef 92       	push	r14
    1d62:	ff 92       	push	r15
    1d64:	0f 93       	push	r16
    1d66:	1f 93       	push	r17
    1d68:	cf 93       	push	r28
    1d6a:	df 93       	push	r29
    1d6c:	1f 92       	push	r1
    1d6e:	cd b7       	in	r28, 0x3d	; 61
    1d70:	de b7       	in	r29, 0x3e	; 62
    1d72:	7c 01       	movw	r14, r24
    1d74:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1d76:	00 97       	sbiw	r24, 0x00	; 0
    1d78:	09 f4       	brne	.+2      	; 0x1d7c <usart_init_spi+0x1e>
    1d7a:	cf c1       	rjmp	.+926    	; 0x211a <usart_init_spi+0x3bc>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1d7c:	80 3c       	cpi	r24, 0xC0	; 192
    1d7e:	91 05       	cpc	r25, r1
    1d80:	29 f4       	brne	.+10     	; 0x1d8c <usart_init_spi+0x2e>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1d82:	60 e1       	ldi	r22, 0x10	; 16
    1d84:	80 e0       	ldi	r24, 0x00	; 0
    1d86:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1d8a:	c7 c1       	rjmp	.+910    	; 0x211a <usart_init_spi+0x3bc>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1d8c:	80 e8       	ldi	r24, 0x80	; 128
    1d8e:	e8 16       	cp	r14, r24
    1d90:	81 e0       	ldi	r24, 0x01	; 1
    1d92:	f8 06       	cpc	r15, r24
    1d94:	29 f4       	brne	.+10     	; 0x1da0 <usart_init_spi+0x42>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1d96:	62 e0       	ldi	r22, 0x02	; 2
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1d9e:	bd c1       	rjmp	.+890    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1da0:	e1 14       	cp	r14, r1
    1da2:	e1 e0       	ldi	r30, 0x01	; 1
    1da4:	fe 06       	cpc	r15, r30
    1da6:	29 f4       	brne	.+10     	; 0x1db2 <usart_init_spi+0x54>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1da8:	61 e0       	ldi	r22, 0x01	; 1
    1daa:	80 e0       	ldi	r24, 0x00	; 0
    1dac:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1db0:	b4 c1       	rjmp	.+872    	; 0x211a <usart_init_spi+0x3bc>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1db2:	f0 e8       	ldi	r31, 0x80	; 128
    1db4:	ef 16       	cp	r14, r31
    1db6:	f3 e0       	ldi	r31, 0x03	; 3
    1db8:	ff 06       	cpc	r15, r31
    1dba:	29 f4       	brne	.+10     	; 0x1dc6 <usart_init_spi+0x68>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1dbc:	61 e0       	ldi	r22, 0x01	; 1
    1dbe:	81 e0       	ldi	r24, 0x01	; 1
    1dc0:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1dc4:	aa c1       	rjmp	.+852    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1dc6:	30 e9       	ldi	r19, 0x90	; 144
    1dc8:	e3 16       	cp	r14, r19
    1dca:	33 e0       	ldi	r19, 0x03	; 3
    1dcc:	f3 06       	cpc	r15, r19
    1dce:	29 f4       	brne	.+10     	; 0x1dda <usart_init_spi+0x7c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1dd0:	61 e0       	ldi	r22, 0x01	; 1
    1dd2:	82 e0       	ldi	r24, 0x02	; 2
    1dd4:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1dd8:	a0 c1       	rjmp	.+832    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1dda:	e1 14       	cp	r14, r1
    1ddc:	82 e0       	ldi	r24, 0x02	; 2
    1dde:	f8 06       	cpc	r15, r24
    1de0:	29 f4       	brne	.+10     	; 0x1dec <usart_init_spi+0x8e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1de2:	62 e0       	ldi	r22, 0x02	; 2
    1de4:	81 e0       	ldi	r24, 0x01	; 1
    1de6:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1dea:	97 c1       	rjmp	.+814    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1dec:	e0 e4       	ldi	r30, 0x40	; 64
    1dee:	ee 16       	cp	r14, r30
    1df0:	e2 e0       	ldi	r30, 0x02	; 2
    1df2:	fe 06       	cpc	r15, r30
    1df4:	29 f4       	brne	.+10     	; 0x1e00 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1df6:	62 e0       	ldi	r22, 0x02	; 2
    1df8:	82 e0       	ldi	r24, 0x02	; 2
    1dfa:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1dfe:	8d c1       	rjmp	.+794    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1e00:	f0 e2       	ldi	r31, 0x20	; 32
    1e02:	ef 16       	cp	r14, r31
    1e04:	f3 e0       	ldi	r31, 0x03	; 3
    1e06:	ff 06       	cpc	r15, r31
    1e08:	29 f4       	brne	.+10     	; 0x1e14 <usart_init_spi+0xb6>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1e0a:	64 e0       	ldi	r22, 0x04	; 4
    1e0c:	82 e0       	ldi	r24, 0x02	; 2
    1e0e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e12:	83 c1       	rjmp	.+774    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1e14:	e1 14       	cp	r14, r1
    1e16:	38 e0       	ldi	r19, 0x08	; 8
    1e18:	f3 06       	cpc	r15, r19
    1e1a:	29 f4       	brne	.+10     	; 0x1e26 <usart_init_spi+0xc8>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1e1c:	61 e0       	ldi	r22, 0x01	; 1
    1e1e:	83 e0       	ldi	r24, 0x03	; 3
    1e20:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e24:	7a c1       	rjmp	.+756    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1e26:	e1 14       	cp	r14, r1
    1e28:	89 e0       	ldi	r24, 0x09	; 9
    1e2a:	f8 06       	cpc	r15, r24
    1e2c:	29 f4       	brne	.+10     	; 0x1e38 <usart_init_spi+0xda>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1e2e:	61 e0       	ldi	r22, 0x01	; 1
    1e30:	84 e0       	ldi	r24, 0x04	; 4
    1e32:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e36:	71 c1       	rjmp	.+738    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1e38:	e1 14       	cp	r14, r1
    1e3a:	ea e0       	ldi	r30, 0x0A	; 10
    1e3c:	fe 06       	cpc	r15, r30
    1e3e:	29 f4       	brne	.+10     	; 0x1e4a <usart_init_spi+0xec>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1e40:	61 e0       	ldi	r22, 0x01	; 1
    1e42:	85 e0       	ldi	r24, 0x05	; 5
    1e44:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e48:	68 c1       	rjmp	.+720    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1e4a:	e1 14       	cp	r14, r1
    1e4c:	fb e0       	ldi	r31, 0x0B	; 11
    1e4e:	ff 06       	cpc	r15, r31
    1e50:	29 f4       	brne	.+10     	; 0x1e5c <usart_init_spi+0xfe>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1e52:	61 e0       	ldi	r22, 0x01	; 1
    1e54:	86 e0       	ldi	r24, 0x06	; 6
    1e56:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e5a:	5f c1       	rjmp	.+702    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1e5c:	30 e4       	ldi	r19, 0x40	; 64
    1e5e:	e3 16       	cp	r14, r19
    1e60:	38 e0       	ldi	r19, 0x08	; 8
    1e62:	f3 06       	cpc	r15, r19
    1e64:	29 f4       	brne	.+10     	; 0x1e70 <usart_init_spi+0x112>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1e66:	62 e0       	ldi	r22, 0x02	; 2
    1e68:	83 e0       	ldi	r24, 0x03	; 3
    1e6a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e6e:	55 c1       	rjmp	.+682    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1e70:	80 e4       	ldi	r24, 0x40	; 64
    1e72:	e8 16       	cp	r14, r24
    1e74:	89 e0       	ldi	r24, 0x09	; 9
    1e76:	f8 06       	cpc	r15, r24
    1e78:	29 f4       	brne	.+10     	; 0x1e84 <usart_init_spi+0x126>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1e7a:	62 e0       	ldi	r22, 0x02	; 2
    1e7c:	84 e0       	ldi	r24, 0x04	; 4
    1e7e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e82:	4b c1       	rjmp	.+662    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1e84:	e0 e4       	ldi	r30, 0x40	; 64
    1e86:	ee 16       	cp	r14, r30
    1e88:	ea e0       	ldi	r30, 0x0A	; 10
    1e8a:	fe 06       	cpc	r15, r30
    1e8c:	29 f4       	brne	.+10     	; 0x1e98 <usart_init_spi+0x13a>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1e8e:	62 e0       	ldi	r22, 0x02	; 2
    1e90:	85 e0       	ldi	r24, 0x05	; 5
    1e92:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e96:	41 c1       	rjmp	.+642    	; 0x211a <usart_init_spi+0x3bc>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1e98:	f0 e9       	ldi	r31, 0x90	; 144
    1e9a:	ef 16       	cp	r14, r31
    1e9c:	f8 e0       	ldi	r31, 0x08	; 8
    1e9e:	ff 06       	cpc	r15, r31
    1ea0:	29 f4       	brne	.+10     	; 0x1eac <usart_init_spi+0x14e>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1ea2:	64 e0       	ldi	r22, 0x04	; 4
    1ea4:	83 e0       	ldi	r24, 0x03	; 3
    1ea6:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1eaa:	37 c1       	rjmp	.+622    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1eac:	30 e9       	ldi	r19, 0x90	; 144
    1eae:	e3 16       	cp	r14, r19
    1eb0:	39 e0       	ldi	r19, 0x09	; 9
    1eb2:	f3 06       	cpc	r15, r19
    1eb4:	29 f4       	brne	.+10     	; 0x1ec0 <usart_init_spi+0x162>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1eb6:	64 e0       	ldi	r22, 0x04	; 4
    1eb8:	84 e0       	ldi	r24, 0x04	; 4
    1eba:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ebe:	2d c1       	rjmp	.+602    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1ec0:	80 e9       	ldi	r24, 0x90	; 144
    1ec2:	e8 16       	cp	r14, r24
    1ec4:	8a e0       	ldi	r24, 0x0A	; 10
    1ec6:	f8 06       	cpc	r15, r24
    1ec8:	29 f4       	brne	.+10     	; 0x1ed4 <usart_init_spi+0x176>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1eca:	64 e0       	ldi	r22, 0x04	; 4
    1ecc:	85 e0       	ldi	r24, 0x05	; 5
    1ece:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ed2:	23 c1       	rjmp	.+582    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1ed4:	e0 e9       	ldi	r30, 0x90	; 144
    1ed6:	ee 16       	cp	r14, r30
    1ed8:	eb e0       	ldi	r30, 0x0B	; 11
    1eda:	fe 06       	cpc	r15, r30
    1edc:	29 f4       	brne	.+10     	; 0x1ee8 <usart_init_spi+0x18a>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1ede:	64 e0       	ldi	r22, 0x04	; 4
    1ee0:	86 e0       	ldi	r24, 0x06	; 6
    1ee2:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ee6:	19 c1       	rjmp	.+562    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1ee8:	f0 ec       	ldi	r31, 0xC0	; 192
    1eea:	ef 16       	cp	r14, r31
    1eec:	f8 e0       	ldi	r31, 0x08	; 8
    1eee:	ff 06       	cpc	r15, r31
    1ef0:	29 f4       	brne	.+10     	; 0x1efc <usart_init_spi+0x19e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1ef2:	68 e0       	ldi	r22, 0x08	; 8
    1ef4:	83 e0       	ldi	r24, 0x03	; 3
    1ef6:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1efa:	0f c1       	rjmp	.+542    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1efc:	30 ec       	ldi	r19, 0xC0	; 192
    1efe:	e3 16       	cp	r14, r19
    1f00:	39 e0       	ldi	r19, 0x09	; 9
    1f02:	f3 06       	cpc	r15, r19
    1f04:	29 f4       	brne	.+10     	; 0x1f10 <usart_init_spi+0x1b2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1f06:	68 e0       	ldi	r22, 0x08	; 8
    1f08:	84 e0       	ldi	r24, 0x04	; 4
    1f0a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f0e:	05 c1       	rjmp	.+522    	; 0x211a <usart_init_spi+0x3bc>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1f10:	80 ea       	ldi	r24, 0xA0	; 160
    1f12:	e8 16       	cp	r14, r24
    1f14:	88 e0       	ldi	r24, 0x08	; 8
    1f16:	f8 06       	cpc	r15, r24
    1f18:	69 f4       	brne	.+26     	; 0x1f34 <usart_init_spi+0x1d6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1f1a:	60 e1       	ldi	r22, 0x10	; 16
    1f1c:	83 e0       	ldi	r24, 0x03	; 3
    1f1e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1f22:	e0 ea       	ldi	r30, 0xA0	; 160
    1f24:	f8 e0       	ldi	r31, 0x08	; 8
    1f26:	84 81       	ldd	r24, Z+4	; 0x04
    1f28:	8f 7e       	andi	r24, 0xEF	; 239
    1f2a:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1f2c:	f8 01       	movw	r30, r16
    1f2e:	24 81       	ldd	r18, Z+4	; 0x04
    1f30:	22 50       	subi	r18, 0x02	; 2
    1f32:	53 c0       	rjmp	.+166    	; 0x1fda <usart_init_spi+0x27c>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1f34:	f0 ea       	ldi	r31, 0xA0	; 160
    1f36:	ef 16       	cp	r14, r31
    1f38:	f9 e0       	ldi	r31, 0x09	; 9
    1f3a:	ff 06       	cpc	r15, r31
    1f3c:	29 f4       	brne	.+10     	; 0x1f48 <usart_init_spi+0x1ea>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1f3e:	60 e1       	ldi	r22, 0x10	; 16
    1f40:	84 e0       	ldi	r24, 0x04	; 4
    1f42:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f46:	e9 c0       	rjmp	.+466    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1f48:	30 ea       	ldi	r19, 0xA0	; 160
    1f4a:	e3 16       	cp	r14, r19
    1f4c:	3a e0       	ldi	r19, 0x0A	; 10
    1f4e:	f3 06       	cpc	r15, r19
    1f50:	29 f4       	brne	.+10     	; 0x1f5c <usart_init_spi+0x1fe>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1f52:	60 e1       	ldi	r22, 0x10	; 16
    1f54:	85 e0       	ldi	r24, 0x05	; 5
    1f56:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f5a:	df c0       	rjmp	.+446    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1f5c:	80 ea       	ldi	r24, 0xA0	; 160
    1f5e:	e8 16       	cp	r14, r24
    1f60:	8b e0       	ldi	r24, 0x0B	; 11
    1f62:	f8 06       	cpc	r15, r24
    1f64:	29 f4       	brne	.+10     	; 0x1f70 <usart_init_spi+0x212>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1f66:	60 e1       	ldi	r22, 0x10	; 16
    1f68:	86 e0       	ldi	r24, 0x06	; 6
    1f6a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f6e:	d5 c0       	rjmp	.+426    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1f70:	e0 eb       	ldi	r30, 0xB0	; 176
    1f72:	ee 16       	cp	r14, r30
    1f74:	e8 e0       	ldi	r30, 0x08	; 8
    1f76:	fe 06       	cpc	r15, r30
    1f78:	29 f4       	brne	.+10     	; 0x1f84 <usart_init_spi+0x226>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1f7a:	60 e2       	ldi	r22, 0x20	; 32
    1f7c:	83 e0       	ldi	r24, 0x03	; 3
    1f7e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f82:	cb c0       	rjmp	.+406    	; 0x211a <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1f84:	f0 eb       	ldi	r31, 0xB0	; 176
    1f86:	ef 16       	cp	r14, r31
    1f88:	f9 e0       	ldi	r31, 0x09	; 9
    1f8a:	ff 06       	cpc	r15, r31
    1f8c:	29 f4       	brne	.+10     	; 0x1f98 <usart_init_spi+0x23a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1f8e:	60 e2       	ldi	r22, 0x20	; 32
    1f90:	84 e0       	ldi	r24, 0x04	; 4
    1f92:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f96:	c1 c0       	rjmp	.+386    	; 0x211a <usart_init_spi+0x3bc>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1f98:	30 e8       	ldi	r19, 0x80	; 128
    1f9a:	e3 16       	cp	r14, r19
    1f9c:	34 e0       	ldi	r19, 0x04	; 4
    1f9e:	f3 06       	cpc	r15, r19
    1fa0:	29 f4       	brne	.+10     	; 0x1fac <usart_init_spi+0x24e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1fa2:	60 e4       	ldi	r22, 0x40	; 64
    1fa4:	83 e0       	ldi	r24, 0x03	; 3
    1fa6:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1faa:	b7 c0       	rjmp	.+366    	; 0x211a <usart_init_spi+0x3bc>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1fac:	80 ea       	ldi	r24, 0xA0	; 160
    1fae:	e8 16       	cp	r14, r24
    1fb0:	84 e0       	ldi	r24, 0x04	; 4
    1fb2:	f8 06       	cpc	r15, r24
    1fb4:	29 f4       	brne	.+10     	; 0x1fc0 <usart_init_spi+0x262>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1fb6:	60 e4       	ldi	r22, 0x40	; 64
    1fb8:	85 e0       	ldi	r24, 0x05	; 5
    1fba:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1fbe:	ad c0       	rjmp	.+346    	; 0x211a <usart_init_spi+0x3bc>
    1fc0:	f7 01       	movw	r30, r14
    1fc2:	84 81       	ldd	r24, Z+4	; 0x04
    1fc4:	8f 7e       	andi	r24, 0xEF	; 239
    1fc6:	84 83       	std	Z+4, r24	; 0x04
    1fc8:	fb 01       	movw	r30, r22
    1fca:	24 81       	ldd	r18, Z+4	; 0x04
    1fcc:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1fce:	c7 01       	movw	r24, r14
    1fd0:	f0 ea       	ldi	r31, 0xA0	; 160
    1fd2:	ef 16       	cp	r14, r31
    1fd4:	f8 e0       	ldi	r31, 0x08	; 8
    1fd6:	ff 06       	cpc	r15, r31
    1fd8:	49 f4       	brne	.+18     	; 0x1fec <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    1fda:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    1fde:	84 fd       	sbrc	r24, 4
    1fe0:	a5 c0       	rjmp	.+330    	; 0x212c <usart_init_spi+0x3ce>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    1fe2:	0f 2e       	mov	r0, r31
    1fe4:	f1 e1       	ldi	r31, 0x11	; 17
    1fe6:	df 2e       	mov	r13, r31
    1fe8:	f0 2d       	mov	r31, r0
    1fea:	a4 c0       	rjmp	.+328    	; 0x2134 <usart_init_spi+0x3d6>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1fec:	80 3b       	cpi	r24, 0xB0	; 176
    1fee:	38 e0       	ldi	r19, 0x08	; 8
    1ff0:	93 07       	cpc	r25, r19
    1ff2:	91 f0       	breq	.+36     	; 0x2018 <usart_init_spi+0x2ba>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    1ff4:	80 3a       	cpi	r24, 0xA0	; 160
    1ff6:	e9 e0       	ldi	r30, 0x09	; 9
    1ff8:	9e 07       	cpc	r25, r30
    1ffa:	49 f4       	brne	.+18     	; 0x200e <usart_init_spi+0x2b0>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1ffc:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    2000:	34 fd       	sbrc	r19, 4
    2002:	9b c0       	rjmp	.+310    	; 0x213a <usart_init_spi+0x3dc>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    2004:	0f 2e       	mov	r0, r31
    2006:	f9 e1       	ldi	r31, 0x19	; 25
    2008:	df 2e       	mov	r13, r31
    200a:	f0 2d       	mov	r31, r0
    200c:	16 c0       	rjmp	.+44     	; 0x203a <usart_init_spi+0x2dc>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    200e:	80 3b       	cpi	r24, 0xB0	; 176
    2010:	f9 e0       	ldi	r31, 0x09	; 9
    2012:	9f 07       	cpc	r25, r31
    2014:	f1 f0       	breq	.+60     	; 0x2052 <usart_init_spi+0x2f4>
    2016:	04 c0       	rjmp	.+8      	; 0x2020 <usart_init_spi+0x2c2>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    2018:	0f 2e       	mov	r0, r31
    201a:	f5 e1       	ldi	r31, 0x15	; 21
    201c:	df 2e       	mov	r13, r31
    201e:	f0 2d       	mov	r31, r0
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    2020:	80 3a       	cpi	r24, 0xA0	; 160
    2022:	3a e0       	ldi	r19, 0x0A	; 10
    2024:	93 07       	cpc	r25, r19
    2026:	49 f4       	brne	.+18     	; 0x203a <usart_init_spi+0x2dc>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    2028:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    202c:	84 fd       	sbrc	r24, 4
    202e:	8a c0       	rjmp	.+276    	; 0x2144 <usart_init_spi+0x3e6>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    2030:	0f 2e       	mov	r0, r31
    2032:	f1 e2       	ldi	r31, 0x21	; 33
    2034:	df 2e       	mov	r13, r31
    2036:	f0 2d       	mov	r31, r0
    2038:	15 c0       	rjmp	.+42     	; 0x2064 <usart_init_spi+0x306>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    203a:	80 3a       	cpi	r24, 0xA0	; 160
    203c:	9b 40       	sbci	r25, 0x0B	; 11
    203e:	91 f4       	brne	.+36     	; 0x2064 <usart_init_spi+0x306>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    2040:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    2044:	84 fd       	sbrc	r24, 4
    2046:	0a c0       	rjmp	.+20     	; 0x205c <usart_init_spi+0x2fe>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    2048:	0f 2e       	mov	r0, r31
    204a:	f9 e2       	ldi	r31, 0x29	; 41
    204c:	df 2e       	mov	r13, r31
    204e:	f0 2d       	mov	r31, r0
    2050:	09 c0       	rjmp	.+18     	; 0x2064 <usart_init_spi+0x306>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    2052:	0f 2e       	mov	r0, r31
    2054:	fd e1       	ldi	r31, 0x1D	; 29
    2056:	df 2e       	mov	r13, r31
    2058:	f0 2d       	mov	r31, r0
    205a:	04 c0       	rjmp	.+8      	; 0x2064 <usart_init_spi+0x306>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    205c:	0f 2e       	mov	r0, r31
    205e:	fd e2       	ldi	r31, 0x2D	; 45
    2060:	df 2e       	mov	r13, r31
    2062:	f0 2d       	mov	r31, r0
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2064:	ed 2d       	mov	r30, r13
    2066:	e6 95       	lsr	r30
    2068:	e6 95       	lsr	r30
    206a:	e6 95       	lsr	r30
    206c:	30 e2       	ldi	r19, 0x20	; 32
    206e:	e3 9f       	mul	r30, r19
    2070:	f0 01       	movw	r30, r0
    2072:	11 24       	eor	r1, r1
    2074:	fa 5f       	subi	r31, 0xFA	; 250
    2076:	3d 2d       	mov	r19, r13
    2078:	37 70       	andi	r19, 0x07	; 7
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    207a:	81 e0       	ldi	r24, 0x01	; 1
    207c:	90 e0       	ldi	r25, 0x00	; 0
    207e:	03 2e       	mov	r0, r19
    2080:	02 c0       	rjmp	.+4      	; 0x2086 <usart_init_spi+0x328>
    2082:	88 0f       	add	r24, r24
    2084:	99 1f       	adc	r25, r25
    2086:	0a 94       	dec	r0
    2088:	e2 f7       	brpl	.-8      	; 0x2082 <usart_init_spi+0x324>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    208a:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    208c:	22 30       	cpi	r18, 0x02	; 2
    208e:	10 f0       	brcs	.+4      	; 0x2094 <usart_init_spi+0x336>
    2090:	40 e0       	ldi	r20, 0x00	; 0
    2092:	01 c0       	rjmp	.+2      	; 0x2096 <usart_init_spi+0x338>
    2094:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    2096:	df 01       	movw	r26, r30
    2098:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    209a:	a3 0f       	add	r26, r19
    209c:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    209e:	9f b7       	in	r25, 0x3f	; 63
    20a0:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    20a2:	f8 94       	cli
	return flags;
    20a4:	39 81       	ldd	r19, Y+1	; 0x01
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    20a6:	2c 91       	ld	r18, X
    20a8:	27 70       	andi	r18, 0x07	; 7
    20aa:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    20ac:	9c 91       	ld	r25, X
    20ae:	94 2b       	or	r25, r20
    20b0:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    20b2:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    20b4:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    20b6:	f7 01       	movw	r30, r14
    20b8:	85 81       	ldd	r24, Z+5	; 0x05
    20ba:	80 6c       	ori	r24, 0xC0	; 192
    20bc:	85 83       	std	Z+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    20be:	f8 01       	movw	r30, r16
    20c0:	84 81       	ldd	r24, Z+4	; 0x04
    20c2:	8d 7f       	andi	r24, 0xFD	; 253
    20c4:	81 30       	cpi	r24, 0x01	; 1
    20c6:	29 f4       	brne	.+10     	; 0x20d2 <usart_init_spi+0x374>
		usart->CTRLC |= USART_UCPHA_bm;
    20c8:	f7 01       	movw	r30, r14
    20ca:	85 81       	ldd	r24, Z+5	; 0x05
    20cc:	82 60       	ori	r24, 0x02	; 2
    20ce:	85 83       	std	Z+5, r24	; 0x05
    20d0:	04 c0       	rjmp	.+8      	; 0x20da <usart_init_spi+0x37c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    20d2:	f7 01       	movw	r30, r14
    20d4:	85 81       	ldd	r24, Z+5	; 0x05
    20d6:	8d 7f       	andi	r24, 0xFD	; 253
    20d8:	85 83       	std	Z+5, r24	; 0x05
	}
	if (opt->data_order) {
    20da:	f8 01       	movw	r30, r16
    20dc:	85 81       	ldd	r24, Z+5	; 0x05
    20de:	88 23       	and	r24, r24
    20e0:	29 f0       	breq	.+10     	; 0x20ec <usart_init_spi+0x38e>
		(usart)->CTRLC |= USART_DORD_bm;
    20e2:	f7 01       	movw	r30, r14
    20e4:	85 81       	ldd	r24, Z+5	; 0x05
    20e6:	84 60       	ori	r24, 0x04	; 4
    20e8:	85 83       	std	Z+5, r24	; 0x05
    20ea:	04 c0       	rjmp	.+8      	; 0x20f4 <usart_init_spi+0x396>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    20ec:	f7 01       	movw	r30, r14
    20ee:	85 81       	ldd	r24, Z+5	; 0x05
    20f0:	8b 7f       	andi	r24, 0xFB	; 251
    20f2:	85 83       	std	Z+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    20f4:	f8 01       	movw	r30, r16
    20f6:	40 81       	ld	r20, Z
    20f8:	51 81       	ldd	r21, Z+1	; 0x01
    20fa:	62 81       	ldd	r22, Z+2	; 0x02
    20fc:	73 81       	ldd	r23, Z+3	; 0x03
    20fe:	00 e8       	ldi	r16, 0x80	; 128
    2100:	14 e8       	ldi	r17, 0x84	; 132
    2102:	2e e1       	ldi	r18, 0x1E	; 30
    2104:	30 e0       	ldi	r19, 0x00	; 0
    2106:	c7 01       	movw	r24, r14
    2108:	f8 dd       	rcall	.-1040   	; 0x1cfa <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    210a:	f7 01       	movw	r30, r14
    210c:	84 81       	ldd	r24, Z+4	; 0x04
    210e:	88 60       	ori	r24, 0x08	; 8
    2110:	84 83       	std	Z+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    2112:	84 81       	ldd	r24, Z+4	; 0x04
    2114:	80 61       	ori	r24, 0x10	; 16
    2116:	84 83       	std	Z+4, r24	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    2118:	1a c0       	rjmp	.+52     	; 0x214e <usart_init_spi+0x3f0>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    211a:	f7 01       	movw	r30, r14
    211c:	84 81       	ldd	r24, Z+4	; 0x04
    211e:	8f 7e       	andi	r24, 0xEF	; 239
    2120:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    2122:	f8 01       	movw	r30, r16
    2124:	24 81       	ldd	r18, Z+4	; 0x04
    2126:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    2128:	c7 01       	movw	r24, r14
    212a:	60 cf       	rjmp	.-320    	; 0x1fec <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    212c:	0f 2e       	mov	r0, r31
    212e:	f5 e1       	ldi	r31, 0x15	; 21
    2130:	df 2e       	mov	r13, r31
    2132:	f0 2d       	mov	r31, r0
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    2134:	80 ea       	ldi	r24, 0xA0	; 160
    2136:	98 e0       	ldi	r25, 0x08	; 8
    2138:	6a cf       	rjmp	.-300    	; 0x200e <usart_init_spi+0x2b0>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    213a:	0f 2e       	mov	r0, r31
    213c:	fd e1       	ldi	r31, 0x1D	; 29
    213e:	df 2e       	mov	r13, r31
    2140:	f0 2d       	mov	r31, r0
    2142:	7b cf       	rjmp	.-266    	; 0x203a <usart_init_spi+0x2dc>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    2144:	0f 2e       	mov	r0, r31
    2146:	f5 e2       	ldi	r31, 0x25	; 37
    2148:	df 2e       	mov	r13, r31
    214a:	f0 2d       	mov	r31, r0
    214c:	8b cf       	rjmp	.-234    	; 0x2064 <usart_init_spi+0x306>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    214e:	0f 90       	pop	r0
    2150:	df 91       	pop	r29
    2152:	cf 91       	pop	r28
    2154:	1f 91       	pop	r17
    2156:	0f 91       	pop	r16
    2158:	ff 90       	pop	r15
    215a:	ef 90       	pop	r14
    215c:	df 90       	pop	r13
    215e:	08 95       	ret

00002160 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2160:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2162:	03 96       	adiw	r24, 0x03	; 3
    2164:	81 83       	std	Z+1, r24	; 0x01
    2166:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2168:	2f ef       	ldi	r18, 0xFF	; 255
    216a:	3f ef       	ldi	r19, 0xFF	; 255
    216c:	23 83       	std	Z+3, r18	; 0x03
    216e:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2170:	85 83       	std	Z+5, r24	; 0x05
    2172:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2174:	87 83       	std	Z+7, r24	; 0x07
    2176:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2178:	10 82       	st	Z, r1
    217a:	08 95       	ret

0000217c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    217c:	fc 01       	movw	r30, r24
    217e:	10 86       	std	Z+8, r1	; 0x08
    2180:	11 86       	std	Z+9, r1	; 0x09
    2182:	08 95       	ret

00002184 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2184:	cf 93       	push	r28
    2186:	df 93       	push	r29
    2188:	9c 01       	movw	r18, r24
    218a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    218c:	dc 01       	movw	r26, r24
    218e:	11 96       	adiw	r26, 0x01	; 1
    2190:	cd 91       	ld	r28, X+
    2192:	dc 91       	ld	r29, X
    2194:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2196:	c2 83       	std	Z+2, r28	; 0x02
    2198:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    219a:	8c 81       	ldd	r24, Y+4	; 0x04
    219c:	9d 81       	ldd	r25, Y+5	; 0x05
    219e:	84 83       	std	Z+4, r24	; 0x04
    21a0:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    21a2:	8c 81       	ldd	r24, Y+4	; 0x04
    21a4:	9d 81       	ldd	r25, Y+5	; 0x05
    21a6:	dc 01       	movw	r26, r24
    21a8:	12 96       	adiw	r26, 0x02	; 2
    21aa:	6d 93       	st	X+, r22
    21ac:	7c 93       	st	X, r23
    21ae:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    21b0:	6c 83       	std	Y+4, r22	; 0x04
    21b2:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    21b4:	20 87       	std	Z+8, r18	; 0x08
    21b6:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    21b8:	f9 01       	movw	r30, r18
    21ba:	80 81       	ld	r24, Z
    21bc:	8f 5f       	subi	r24, 0xFF	; 255
    21be:	80 83       	st	Z, r24
}
    21c0:	df 91       	pop	r29
    21c2:	cf 91       	pop	r28
    21c4:	08 95       	ret

000021c6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    21c6:	cf 93       	push	r28
    21c8:	df 93       	push	r29
    21ca:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    21cc:	48 81       	ld	r20, Y
    21ce:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    21d0:	4f 3f       	cpi	r20, 0xFF	; 255
    21d2:	2f ef       	ldi	r18, 0xFF	; 255
    21d4:	52 07       	cpc	r21, r18
    21d6:	21 f4       	brne	.+8      	; 0x21e0 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    21d8:	fc 01       	movw	r30, r24
    21da:	a7 81       	ldd	r26, Z+7	; 0x07
    21dc:	b0 85       	ldd	r27, Z+8	; 0x08
    21de:	0d c0       	rjmp	.+26     	; 0x21fa <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    21e0:	dc 01       	movw	r26, r24
    21e2:	13 96       	adiw	r26, 0x03	; 3
    21e4:	01 c0       	rjmp	.+2      	; 0x21e8 <vListInsert+0x22>
    21e6:	df 01       	movw	r26, r30
    21e8:	12 96       	adiw	r26, 0x02	; 2
    21ea:	ed 91       	ld	r30, X+
    21ec:	fc 91       	ld	r31, X
    21ee:	13 97       	sbiw	r26, 0x03	; 3
    21f0:	20 81       	ld	r18, Z
    21f2:	31 81       	ldd	r19, Z+1	; 0x01
    21f4:	42 17       	cp	r20, r18
    21f6:	53 07       	cpc	r21, r19
    21f8:	b0 f7       	brcc	.-20     	; 0x21e6 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    21fa:	12 96       	adiw	r26, 0x02	; 2
    21fc:	ed 91       	ld	r30, X+
    21fe:	fc 91       	ld	r31, X
    2200:	13 97       	sbiw	r26, 0x03	; 3
    2202:	ea 83       	std	Y+2, r30	; 0x02
    2204:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2206:	c4 83       	std	Z+4, r28	; 0x04
    2208:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    220a:	ac 83       	std	Y+4, r26	; 0x04
    220c:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    220e:	12 96       	adiw	r26, 0x02	; 2
    2210:	cd 93       	st	X+, r28
    2212:	dc 93       	st	X, r29
    2214:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2216:	88 87       	std	Y+8, r24	; 0x08
    2218:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    221a:	fc 01       	movw	r30, r24
    221c:	20 81       	ld	r18, Z
    221e:	2f 5f       	subi	r18, 0xFF	; 255
    2220:	20 83       	st	Z, r18
}
    2222:	df 91       	pop	r29
    2224:	cf 91       	pop	r28
    2226:	08 95       	ret

00002228 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2228:	cf 93       	push	r28
    222a:	df 93       	push	r29
    222c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    222e:	a0 85       	ldd	r26, Z+8	; 0x08
    2230:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2232:	c2 81       	ldd	r28, Z+2	; 0x02
    2234:	d3 81       	ldd	r29, Z+3	; 0x03
    2236:	84 81       	ldd	r24, Z+4	; 0x04
    2238:	95 81       	ldd	r25, Z+5	; 0x05
    223a:	8c 83       	std	Y+4, r24	; 0x04
    223c:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    223e:	c4 81       	ldd	r28, Z+4	; 0x04
    2240:	d5 81       	ldd	r29, Z+5	; 0x05
    2242:	82 81       	ldd	r24, Z+2	; 0x02
    2244:	93 81       	ldd	r25, Z+3	; 0x03
    2246:	8a 83       	std	Y+2, r24	; 0x02
    2248:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    224a:	11 96       	adiw	r26, 0x01	; 1
    224c:	8d 91       	ld	r24, X+
    224e:	9c 91       	ld	r25, X
    2250:	12 97       	sbiw	r26, 0x02	; 2
    2252:	e8 17       	cp	r30, r24
    2254:	f9 07       	cpc	r31, r25
    2256:	31 f4       	brne	.+12     	; 0x2264 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2258:	84 81       	ldd	r24, Z+4	; 0x04
    225a:	95 81       	ldd	r25, Z+5	; 0x05
    225c:	11 96       	adiw	r26, 0x01	; 1
    225e:	8d 93       	st	X+, r24
    2260:	9c 93       	st	X, r25
    2262:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2264:	10 86       	std	Z+8, r1	; 0x08
    2266:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    2268:	8c 91       	ld	r24, X
    226a:	81 50       	subi	r24, 0x01	; 1
    226c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    226e:	8c 91       	ld	r24, X
}
    2270:	df 91       	pop	r29
    2272:	cf 91       	pop	r28
    2274:	08 95       	ret

00002276 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2276:	0f 93       	push	r16
    2278:	1f 93       	push	r17
    227a:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    227c:	71 e1       	ldi	r23, 0x11	; 17
    227e:	fc 01       	movw	r30, r24
    2280:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    2282:	31 97       	sbiw	r30, 0x01	; 1
    2284:	62 e2       	ldi	r22, 0x22	; 34
    2286:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    2288:	31 97       	sbiw	r30, 0x01	; 1
    228a:	23 e3       	ldi	r18, 0x33	; 51
    228c:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    228e:	01 2e       	mov	r0, r17
    2290:	00 0c       	add	r0, r0
    2292:	22 0b       	sbc	r18, r18
    2294:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2296:	31 97       	sbiw	r30, 0x01	; 1
    2298:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    229a:	31 97       	sbiw	r30, 0x01	; 1
    229c:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    229e:	31 97       	sbiw	r30, 0x01	; 1
    22a0:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    22a2:	31 97       	sbiw	r30, 0x01	; 1
    22a4:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    22a6:	31 97       	sbiw	r30, 0x01	; 1
    22a8:	20 e8       	ldi	r18, 0x80	; 128
    22aa:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    22ac:	31 97       	sbiw	r30, 0x01	; 1
    22ae:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    22b0:	31 97       	sbiw	r30, 0x01	; 1
    22b2:	22 e0       	ldi	r18, 0x02	; 2
    22b4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    22b6:	31 97       	sbiw	r30, 0x01	; 1
    22b8:	23 e0       	ldi	r18, 0x03	; 3
    22ba:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    22bc:	31 97       	sbiw	r30, 0x01	; 1
    22be:	24 e0       	ldi	r18, 0x04	; 4
    22c0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    22c2:	31 97       	sbiw	r30, 0x01	; 1
    22c4:	25 e0       	ldi	r18, 0x05	; 5
    22c6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    22c8:	31 97       	sbiw	r30, 0x01	; 1
    22ca:	26 e0       	ldi	r18, 0x06	; 6
    22cc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    22ce:	31 97       	sbiw	r30, 0x01	; 1
    22d0:	27 e0       	ldi	r18, 0x07	; 7
    22d2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    22d4:	31 97       	sbiw	r30, 0x01	; 1
    22d6:	28 e0       	ldi	r18, 0x08	; 8
    22d8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    22da:	31 97       	sbiw	r30, 0x01	; 1
    22dc:	29 e0       	ldi	r18, 0x09	; 9
    22de:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    22e0:	31 97       	sbiw	r30, 0x01	; 1
    22e2:	20 e1       	ldi	r18, 0x10	; 16
    22e4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    22e6:	31 97       	sbiw	r30, 0x01	; 1
    22e8:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    22ea:	31 97       	sbiw	r30, 0x01	; 1
    22ec:	22 e1       	ldi	r18, 0x12	; 18
    22ee:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    22f0:	31 97       	sbiw	r30, 0x01	; 1
    22f2:	23 e1       	ldi	r18, 0x13	; 19
    22f4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    22f6:	31 97       	sbiw	r30, 0x01	; 1
    22f8:	24 e1       	ldi	r18, 0x14	; 20
    22fa:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    22fc:	31 97       	sbiw	r30, 0x01	; 1
    22fe:	25 e1       	ldi	r18, 0x15	; 21
    2300:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    2302:	31 97       	sbiw	r30, 0x01	; 1
    2304:	26 e1       	ldi	r18, 0x16	; 22
    2306:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    2308:	31 97       	sbiw	r30, 0x01	; 1
    230a:	27 e1       	ldi	r18, 0x17	; 23
    230c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    230e:	31 97       	sbiw	r30, 0x01	; 1
    2310:	28 e1       	ldi	r18, 0x18	; 24
    2312:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    2314:	31 97       	sbiw	r30, 0x01	; 1
    2316:	29 e1       	ldi	r18, 0x19	; 25
    2318:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    231a:	31 97       	sbiw	r30, 0x01	; 1
    231c:	20 e2       	ldi	r18, 0x20	; 32
    231e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    2320:	31 97       	sbiw	r30, 0x01	; 1
    2322:	21 e2       	ldi	r18, 0x21	; 33
    2324:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    2326:	31 97       	sbiw	r30, 0x01	; 1
    2328:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    232a:	31 97       	sbiw	r30, 0x01	; 1
    232c:	23 e2       	ldi	r18, 0x23	; 35
    232e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    2330:	31 97       	sbiw	r30, 0x01	; 1
    2332:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    2334:	31 97       	sbiw	r30, 0x01	; 1
    2336:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    2338:	31 97       	sbiw	r30, 0x01	; 1
    233a:	26 e2       	ldi	r18, 0x26	; 38
    233c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    233e:	31 97       	sbiw	r30, 0x01	; 1
    2340:	27 e2       	ldi	r18, 0x27	; 39
    2342:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    2344:	31 97       	sbiw	r30, 0x01	; 1
    2346:	28 e2       	ldi	r18, 0x28	; 40
    2348:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    234a:	31 97       	sbiw	r30, 0x01	; 1
    234c:	29 e2       	ldi	r18, 0x29	; 41
    234e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    2350:	31 97       	sbiw	r30, 0x01	; 1
    2352:	20 e3       	ldi	r18, 0x30	; 48
    2354:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    2356:	31 97       	sbiw	r30, 0x01	; 1
    2358:	21 e3       	ldi	r18, 0x31	; 49
    235a:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    235c:	87 97       	sbiw	r24, 0x27	; 39
    235e:	1f 91       	pop	r17
    2360:	0f 91       	pop	r16
    2362:	08 95       	ret

00002364 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    2364:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    2366:	e0 e7       	ldi	r30, 0x70	; 112
    2368:	f0 e0       	ldi	r31, 0x00	; 0
    236a:	83 81       	ldd	r24, Z+3	; 0x03
    236c:	8a 7f       	andi	r24, 0xFA	; 250
    236e:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    2370:	e0 e0       	ldi	r30, 0x00	; 0
    2372:	f8 e0       	ldi	r31, 0x08	; 8
    2374:	80 e0       	ldi	r24, 0x00	; 0
    2376:	9a ef       	ldi	r25, 0xFA	; 250
    2378:	86 a3       	std	Z+38, r24	; 0x26
    237a:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    237c:	91 e0       	ldi	r25, 0x01	; 1
    237e:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    2380:	a0 ea       	ldi	r26, 0xA0	; 160
    2382:	b0 e0       	ldi	r27, 0x00	; 0
    2384:	12 96       	adiw	r26, 0x02	; 2
    2386:	8c 91       	ld	r24, X
    2388:	12 97       	sbiw	r26, 0x02	; 2
    238a:	81 60       	ori	r24, 0x01	; 1
    238c:	12 96       	adiw	r26, 0x02	; 2
    238e:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    2390:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    2392:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    2394:	a0 91 bc 22 	lds	r26, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2398:	b0 91 bd 22 	lds	r27, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    239c:	0d 90       	ld	r0, X+
    239e:	0d be       	out	0x3d, r0	; 61
    23a0:	0d 90       	ld	r0, X+
    23a2:	0e be       	out	0x3e, r0	; 62
    23a4:	ff 91       	pop	r31
    23a6:	ef 91       	pop	r30
    23a8:	df 91       	pop	r29
    23aa:	cf 91       	pop	r28
    23ac:	bf 91       	pop	r27
    23ae:	af 91       	pop	r26
    23b0:	9f 91       	pop	r25
    23b2:	8f 91       	pop	r24
    23b4:	7f 91       	pop	r23
    23b6:	6f 91       	pop	r22
    23b8:	5f 91       	pop	r21
    23ba:	4f 91       	pop	r20
    23bc:	3f 91       	pop	r19
    23be:	2f 91       	pop	r18
    23c0:	1f 91       	pop	r17
    23c2:	0f 91       	pop	r16
    23c4:	ff 90       	pop	r15
    23c6:	ef 90       	pop	r14
    23c8:	df 90       	pop	r13
    23ca:	cf 90       	pop	r12
    23cc:	bf 90       	pop	r11
    23ce:	af 90       	pop	r10
    23d0:	9f 90       	pop	r9
    23d2:	8f 90       	pop	r8
    23d4:	7f 90       	pop	r7
    23d6:	6f 90       	pop	r6
    23d8:	5f 90       	pop	r5
    23da:	4f 90       	pop	r4
    23dc:	3f 90       	pop	r3
    23de:	2f 90       	pop	r2
    23e0:	1f 90       	pop	r1
    23e2:	0f 90       	pop	r0
    23e4:	0f be       	out	0x3f, r0	; 63
    23e6:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    23e8:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    23ea:	81 e0       	ldi	r24, 0x01	; 1
    23ec:	08 95       	ret

000023ee <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    23ee:	0f 92       	push	r0
    23f0:	0f b6       	in	r0, 0x3f	; 63
    23f2:	f8 94       	cli
    23f4:	0f 92       	push	r0
    23f6:	1f 92       	push	r1
    23f8:	11 24       	eor	r1, r1
    23fa:	2f 92       	push	r2
    23fc:	3f 92       	push	r3
    23fe:	4f 92       	push	r4
    2400:	5f 92       	push	r5
    2402:	6f 92       	push	r6
    2404:	7f 92       	push	r7
    2406:	8f 92       	push	r8
    2408:	9f 92       	push	r9
    240a:	af 92       	push	r10
    240c:	bf 92       	push	r11
    240e:	cf 92       	push	r12
    2410:	df 92       	push	r13
    2412:	ef 92       	push	r14
    2414:	ff 92       	push	r15
    2416:	0f 93       	push	r16
    2418:	1f 93       	push	r17
    241a:	2f 93       	push	r18
    241c:	3f 93       	push	r19
    241e:	4f 93       	push	r20
    2420:	5f 93       	push	r21
    2422:	6f 93       	push	r22
    2424:	7f 93       	push	r23
    2426:	8f 93       	push	r24
    2428:	9f 93       	push	r25
    242a:	af 93       	push	r26
    242c:	bf 93       	push	r27
    242e:	cf 93       	push	r28
    2430:	df 93       	push	r29
    2432:	ef 93       	push	r30
    2434:	ff 93       	push	r31
    2436:	a0 91 bc 22 	lds	r26, 0x22BC	; 0x8022bc <pxCurrentTCB>
    243a:	b0 91 bd 22 	lds	r27, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    243e:	0d b6       	in	r0, 0x3d	; 61
    2440:	0d 92       	st	X+, r0
    2442:	0e b6       	in	r0, 0x3e	; 62
    2444:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    2446:	f5 d5       	rcall	.+3050   	; 0x3032 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    2448:	a0 91 bc 22 	lds	r26, 0x22BC	; 0x8022bc <pxCurrentTCB>
    244c:	b0 91 bd 22 	lds	r27, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2450:	0d 90       	ld	r0, X+
    2452:	0d be       	out	0x3d, r0	; 61
    2454:	0d 90       	ld	r0, X+
    2456:	0e be       	out	0x3e, r0	; 62
    2458:	ff 91       	pop	r31
    245a:	ef 91       	pop	r30
    245c:	df 91       	pop	r29
    245e:	cf 91       	pop	r28
    2460:	bf 91       	pop	r27
    2462:	af 91       	pop	r26
    2464:	9f 91       	pop	r25
    2466:	8f 91       	pop	r24
    2468:	7f 91       	pop	r23
    246a:	6f 91       	pop	r22
    246c:	5f 91       	pop	r21
    246e:	4f 91       	pop	r20
    2470:	3f 91       	pop	r19
    2472:	2f 91       	pop	r18
    2474:	1f 91       	pop	r17
    2476:	0f 91       	pop	r16
    2478:	ff 90       	pop	r15
    247a:	ef 90       	pop	r14
    247c:	df 90       	pop	r13
    247e:	cf 90       	pop	r12
    2480:	bf 90       	pop	r11
    2482:	af 90       	pop	r10
    2484:	9f 90       	pop	r9
    2486:	8f 90       	pop	r8
    2488:	7f 90       	pop	r7
    248a:	6f 90       	pop	r6
    248c:	5f 90       	pop	r5
    248e:	4f 90       	pop	r4
    2490:	3f 90       	pop	r3
    2492:	2f 90       	pop	r2
    2494:	1f 90       	pop	r1
    2496:	0f 90       	pop	r0
    2498:	0f be       	out	0x3f, r0	; 63
    249a:	0f 90       	pop	r0

    asm volatile ( "ret" );
    249c:	08 95       	ret

0000249e <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    249e:	0f 92       	push	r0
    24a0:	0f b6       	in	r0, 0x3f	; 63
    24a2:	f8 94       	cli
    24a4:	0f 92       	push	r0
    24a6:	1f 92       	push	r1
    24a8:	11 24       	eor	r1, r1
    24aa:	2f 92       	push	r2
    24ac:	3f 92       	push	r3
    24ae:	4f 92       	push	r4
    24b0:	5f 92       	push	r5
    24b2:	6f 92       	push	r6
    24b4:	7f 92       	push	r7
    24b6:	8f 92       	push	r8
    24b8:	9f 92       	push	r9
    24ba:	af 92       	push	r10
    24bc:	bf 92       	push	r11
    24be:	cf 92       	push	r12
    24c0:	df 92       	push	r13
    24c2:	ef 92       	push	r14
    24c4:	ff 92       	push	r15
    24c6:	0f 93       	push	r16
    24c8:	1f 93       	push	r17
    24ca:	2f 93       	push	r18
    24cc:	3f 93       	push	r19
    24ce:	4f 93       	push	r20
    24d0:	5f 93       	push	r21
    24d2:	6f 93       	push	r22
    24d4:	7f 93       	push	r23
    24d6:	8f 93       	push	r24
    24d8:	9f 93       	push	r25
    24da:	af 93       	push	r26
    24dc:	bf 93       	push	r27
    24de:	cf 93       	push	r28
    24e0:	df 93       	push	r29
    24e2:	ef 93       	push	r30
    24e4:	ff 93       	push	r31
    24e6:	a0 91 bc 22 	lds	r26, 0x22BC	; 0x8022bc <pxCurrentTCB>
    24ea:	b0 91 bd 22 	lds	r27, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    24ee:	0d b6       	in	r0, 0x3d	; 61
    24f0:	0d 92       	st	X+, r0
    24f2:	0e b6       	in	r0, 0x3e	; 62
    24f4:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    24f6:	68 d4       	rcall	.+2256   	; 0x2dc8 <xTaskIncrementTick>
    24f8:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    24fa:	9b d5       	rcall	.+2870   	; 0x3032 <vTaskSwitchContext>
    24fc:	a0 91 bc 22 	lds	r26, 0x22BC	; 0x8022bc <pxCurrentTCB>
        }
        portRESTORE_CONTEXT();
    2500:	b0 91 bd 22 	lds	r27, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2504:	0d 90       	ld	r0, X+
    2506:	0d be       	out	0x3d, r0	; 61
    2508:	0d 90       	ld	r0, X+
    250a:	0e be       	out	0x3e, r0	; 62
    250c:	ff 91       	pop	r31
    250e:	ef 91       	pop	r30
    2510:	df 91       	pop	r29
    2512:	cf 91       	pop	r28
    2514:	bf 91       	pop	r27
    2516:	af 91       	pop	r26
    2518:	9f 91       	pop	r25
    251a:	8f 91       	pop	r24
    251c:	7f 91       	pop	r23
    251e:	6f 91       	pop	r22
    2520:	5f 91       	pop	r21
    2522:	4f 91       	pop	r20
    2524:	3f 91       	pop	r19
    2526:	2f 91       	pop	r18
    2528:	1f 91       	pop	r17
    252a:	0f 91       	pop	r16
    252c:	ff 90       	pop	r15
    252e:	ef 90       	pop	r14
    2530:	df 90       	pop	r13
    2532:	cf 90       	pop	r12
    2534:	bf 90       	pop	r11
    2536:	af 90       	pop	r10
    2538:	9f 90       	pop	r9
    253a:	8f 90       	pop	r8
    253c:	7f 90       	pop	r7
    253e:	6f 90       	pop	r6
    2540:	5f 90       	pop	r5
    2542:	4f 90       	pop	r4
    2544:	3f 90       	pop	r3
    2546:	2f 90       	pop	r2
    2548:	1f 90       	pop	r1
    254a:	0f 90       	pop	r0
    254c:	0f be       	out	0x3f, r0	; 63
    254e:	0f 90       	pop	r0
    2550:	18 95       	reti

00002552 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2552:	cf 93       	push	r28
    2554:	df 93       	push	r29
    2556:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    2558:	27 d4       	rcall	.+2126   	; 0x2da8 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    255a:	ce 01       	movw	r24, r28
    255c:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2560:	ec 01       	movw	r28, r24
    2562:	ea d4       	rcall	.+2516   	; 0x2f38 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2564:	ce 01       	movw	r24, r28
    2566:	df 91       	pop	r29
    2568:	cf 91       	pop	r28
    256a:	08 95       	ret

0000256c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    256c:	cf 93       	push	r28
    256e:	df 93       	push	r29
	if( pv )
    2570:	00 97       	sbiw	r24, 0x00	; 0
    2572:	31 f0       	breq	.+12     	; 0x2580 <vPortFree+0x14>
    2574:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    2576:	18 d4       	rcall	.+2096   	; 0x2da8 <vTaskSuspendAll>
		{
			free( pv );
    2578:	ce 01       	movw	r24, r28
    257a:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    257e:	dc d4       	rcall	.+2488   	; 0x2f38 <xTaskResumeAll>
	}
}
    2580:	df 91       	pop	r29
    2582:	cf 91       	pop	r28
    2584:	08 95       	ret

00002586 <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2586:	0f b6       	in	r0, 0x3f	; 63
    2588:	f8 94       	cli
    258a:	0f 92       	push	r0
    258c:	fc 01       	movw	r30, r24
    258e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2590:	0f 90       	pop	r0
    2592:	0f be       	out	0x3f, r0	; 63
    2594:	81 e0       	ldi	r24, 0x01	; 1
    2596:	91 11       	cpse	r25, r1
    2598:	80 e0       	ldi	r24, 0x00	; 0
    259a:	08 95       	ret

0000259c <prvCopyDataToQueue>:
    259c:	0f 93       	push	r16
    259e:	1f 93       	push	r17
    25a0:	cf 93       	push	r28
    25a2:	df 93       	push	r29
    25a4:	ec 01       	movw	r28, r24
    25a6:	04 2f       	mov	r16, r20
    25a8:	1a 8d       	ldd	r17, Y+26	; 0x1a
    25aa:	4c 8d       	ldd	r20, Y+28	; 0x1c
    25ac:	44 23       	and	r20, r20
    25ae:	b9 f1       	breq	.+110    	; 0x261e <prvCopyDataToQueue+0x82>
    25b0:	01 11       	cpse	r16, r1
    25b2:	16 c0       	rjmp	.+44     	; 0x25e0 <prvCopyDataToQueue+0x44>
    25b4:	50 e0       	ldi	r21, 0x00	; 0
    25b6:	8a 81       	ldd	r24, Y+2	; 0x02
    25b8:	9b 81       	ldd	r25, Y+3	; 0x03
    25ba:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <memcpy>
    25be:	2c 8d       	ldd	r18, Y+28	; 0x1c
    25c0:	8a 81       	ldd	r24, Y+2	; 0x02
    25c2:	9b 81       	ldd	r25, Y+3	; 0x03
    25c4:	82 0f       	add	r24, r18
    25c6:	91 1d       	adc	r25, r1
    25c8:	8a 83       	std	Y+2, r24	; 0x02
    25ca:	9b 83       	std	Y+3, r25	; 0x03
    25cc:	2c 81       	ldd	r18, Y+4	; 0x04
    25ce:	3d 81       	ldd	r19, Y+5	; 0x05
    25d0:	82 17       	cp	r24, r18
    25d2:	93 07       	cpc	r25, r19
    25d4:	20 f1       	brcs	.+72     	; 0x261e <prvCopyDataToQueue+0x82>
    25d6:	88 81       	ld	r24, Y
    25d8:	99 81       	ldd	r25, Y+1	; 0x01
    25da:	8a 83       	std	Y+2, r24	; 0x02
    25dc:	9b 83       	std	Y+3, r25	; 0x03
    25de:	1f c0       	rjmp	.+62     	; 0x261e <prvCopyDataToQueue+0x82>
    25e0:	50 e0       	ldi	r21, 0x00	; 0
    25e2:	8e 81       	ldd	r24, Y+6	; 0x06
    25e4:	9f 81       	ldd	r25, Y+7	; 0x07
    25e6:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <memcpy>
    25ea:	8c 8d       	ldd	r24, Y+28	; 0x1c
    25ec:	90 e0       	ldi	r25, 0x00	; 0
    25ee:	91 95       	neg	r25
    25f0:	81 95       	neg	r24
    25f2:	91 09       	sbc	r25, r1
    25f4:	2e 81       	ldd	r18, Y+6	; 0x06
    25f6:	3f 81       	ldd	r19, Y+7	; 0x07
    25f8:	28 0f       	add	r18, r24
    25fa:	39 1f       	adc	r19, r25
    25fc:	2e 83       	std	Y+6, r18	; 0x06
    25fe:	3f 83       	std	Y+7, r19	; 0x07
    2600:	48 81       	ld	r20, Y
    2602:	59 81       	ldd	r21, Y+1	; 0x01
    2604:	24 17       	cp	r18, r20
    2606:	35 07       	cpc	r19, r21
    2608:	30 f4       	brcc	.+12     	; 0x2616 <prvCopyDataToQueue+0x7a>
    260a:	2c 81       	ldd	r18, Y+4	; 0x04
    260c:	3d 81       	ldd	r19, Y+5	; 0x05
    260e:	82 0f       	add	r24, r18
    2610:	93 1f       	adc	r25, r19
    2612:	8e 83       	std	Y+6, r24	; 0x06
    2614:	9f 83       	std	Y+7, r25	; 0x07
    2616:	02 30       	cpi	r16, 0x02	; 2
    2618:	11 f4       	brne	.+4      	; 0x261e <prvCopyDataToQueue+0x82>
    261a:	11 11       	cpse	r17, r1
    261c:	11 50       	subi	r17, 0x01	; 1
    261e:	1f 5f       	subi	r17, 0xFF	; 255
    2620:	1a 8f       	std	Y+26, r17	; 0x1a
    2622:	80 e0       	ldi	r24, 0x00	; 0
    2624:	df 91       	pop	r29
    2626:	cf 91       	pop	r28
    2628:	1f 91       	pop	r17
    262a:	0f 91       	pop	r16
    262c:	08 95       	ret

0000262e <prvCopyDataFromQueue>:
    262e:	fc 01       	movw	r30, r24
    2630:	44 8d       	ldd	r20, Z+28	; 0x1c
    2632:	44 23       	and	r20, r20
    2634:	a9 f0       	breq	.+42     	; 0x2660 <prvCopyDataFromQueue+0x32>
    2636:	50 e0       	ldi	r21, 0x00	; 0
    2638:	26 81       	ldd	r18, Z+6	; 0x06
    263a:	37 81       	ldd	r19, Z+7	; 0x07
    263c:	24 0f       	add	r18, r20
    263e:	35 1f       	adc	r19, r21
    2640:	26 83       	std	Z+6, r18	; 0x06
    2642:	37 83       	std	Z+7, r19	; 0x07
    2644:	84 81       	ldd	r24, Z+4	; 0x04
    2646:	95 81       	ldd	r25, Z+5	; 0x05
    2648:	28 17       	cp	r18, r24
    264a:	39 07       	cpc	r19, r25
    264c:	20 f0       	brcs	.+8      	; 0x2656 <prvCopyDataFromQueue+0x28>
    264e:	80 81       	ld	r24, Z
    2650:	91 81       	ldd	r25, Z+1	; 0x01
    2652:	86 83       	std	Z+6, r24	; 0x06
    2654:	97 83       	std	Z+7, r25	; 0x07
    2656:	cb 01       	movw	r24, r22
    2658:	66 81       	ldd	r22, Z+6	; 0x06
    265a:	77 81       	ldd	r23, Z+7	; 0x07
    265c:	0c 94 7c 20 	jmp	0x40f8	; 0x40f8 <memcpy>
    2660:	08 95       	ret

00002662 <prvUnlockQueue>:
    2662:	ef 92       	push	r14
    2664:	ff 92       	push	r15
    2666:	0f 93       	push	r16
    2668:	1f 93       	push	r17
    266a:	cf 93       	push	r28
    266c:	8c 01       	movw	r16, r24
    266e:	0f b6       	in	r0, 0x3f	; 63
    2670:	f8 94       	cli
    2672:	0f 92       	push	r0
    2674:	fc 01       	movw	r30, r24
    2676:	c6 8d       	ldd	r28, Z+30	; 0x1e
    2678:	1c 16       	cp	r1, r28
    267a:	9c f4       	brge	.+38     	; 0x26a2 <prvUnlockQueue+0x40>
    267c:	81 89       	ldd	r24, Z+17	; 0x11
    267e:	81 11       	cpse	r24, r1
    2680:	06 c0       	rjmp	.+12     	; 0x268e <prvUnlockQueue+0x2c>
    2682:	0f c0       	rjmp	.+30     	; 0x26a2 <prvUnlockQueue+0x40>
    2684:	f8 01       	movw	r30, r16
    2686:	81 89       	ldd	r24, Z+17	; 0x11
    2688:	81 11       	cpse	r24, r1
    268a:	05 c0       	rjmp	.+10     	; 0x2696 <prvUnlockQueue+0x34>
    268c:	0a c0       	rjmp	.+20     	; 0x26a2 <prvUnlockQueue+0x40>
    268e:	78 01       	movw	r14, r16
    2690:	f1 e1       	ldi	r31, 0x11	; 17
    2692:	ef 0e       	add	r14, r31
    2694:	f1 1c       	adc	r15, r1
    2696:	c7 01       	movw	r24, r14
    2698:	59 d5       	rcall	.+2738   	; 0x314c <xTaskRemoveFromEventList>
    269a:	81 11       	cpse	r24, r1
    269c:	d3 d5       	rcall	.+2982   	; 0x3244 <vTaskMissedYield>
    269e:	c1 50       	subi	r28, 0x01	; 1
    26a0:	89 f7       	brne	.-30     	; 0x2684 <prvUnlockQueue+0x22>
    26a2:	8f ef       	ldi	r24, 0xFF	; 255
    26a4:	f8 01       	movw	r30, r16
    26a6:	86 8f       	std	Z+30, r24	; 0x1e
    26a8:	0f 90       	pop	r0
    26aa:	0f be       	out	0x3f, r0	; 63
    26ac:	0f b6       	in	r0, 0x3f	; 63
    26ae:	f8 94       	cli
    26b0:	0f 92       	push	r0
    26b2:	c5 8d       	ldd	r28, Z+29	; 0x1d
    26b4:	1c 16       	cp	r1, r28
    26b6:	9c f4       	brge	.+38     	; 0x26de <prvUnlockQueue+0x7c>
    26b8:	80 85       	ldd	r24, Z+8	; 0x08
    26ba:	81 11       	cpse	r24, r1
    26bc:	06 c0       	rjmp	.+12     	; 0x26ca <prvUnlockQueue+0x68>
    26be:	0f c0       	rjmp	.+30     	; 0x26de <prvUnlockQueue+0x7c>
    26c0:	f8 01       	movw	r30, r16
    26c2:	80 85       	ldd	r24, Z+8	; 0x08
    26c4:	81 11       	cpse	r24, r1
    26c6:	05 c0       	rjmp	.+10     	; 0x26d2 <prvUnlockQueue+0x70>
    26c8:	0a c0       	rjmp	.+20     	; 0x26de <prvUnlockQueue+0x7c>
    26ca:	78 01       	movw	r14, r16
    26cc:	f8 e0       	ldi	r31, 0x08	; 8
    26ce:	ef 0e       	add	r14, r31
    26d0:	f1 1c       	adc	r15, r1
    26d2:	c7 01       	movw	r24, r14
    26d4:	3b d5       	rcall	.+2678   	; 0x314c <xTaskRemoveFromEventList>
    26d6:	81 11       	cpse	r24, r1
    26d8:	b5 d5       	rcall	.+2922   	; 0x3244 <vTaskMissedYield>
    26da:	c1 50       	subi	r28, 0x01	; 1
    26dc:	89 f7       	brne	.-30     	; 0x26c0 <prvUnlockQueue+0x5e>
    26de:	8f ef       	ldi	r24, 0xFF	; 255
    26e0:	f8 01       	movw	r30, r16
    26e2:	85 8f       	std	Z+29, r24	; 0x1d
    26e4:	0f 90       	pop	r0
    26e6:	0f be       	out	0x3f, r0	; 63
    26e8:	cf 91       	pop	r28
    26ea:	1f 91       	pop	r17
    26ec:	0f 91       	pop	r16
    26ee:	ff 90       	pop	r15
    26f0:	ef 90       	pop	r14
    26f2:	08 95       	ret

000026f4 <xQueueGenericReset>:
    26f4:	cf 93       	push	r28
    26f6:	df 93       	push	r29
    26f8:	ec 01       	movw	r28, r24
    26fa:	0f b6       	in	r0, 0x3f	; 63
    26fc:	f8 94       	cli
    26fe:	0f 92       	push	r0
    2700:	e8 81       	ld	r30, Y
    2702:	f9 81       	ldd	r31, Y+1	; 0x01
    2704:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2706:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2708:	90 e0       	ldi	r25, 0x00	; 0
    270a:	30 e0       	ldi	r19, 0x00	; 0
    270c:	82 9f       	mul	r24, r18
    270e:	a0 01       	movw	r20, r0
    2710:	83 9f       	mul	r24, r19
    2712:	50 0d       	add	r21, r0
    2714:	92 9f       	mul	r25, r18
    2716:	50 0d       	add	r21, r0
    2718:	11 24       	eor	r1, r1
    271a:	4e 0f       	add	r20, r30
    271c:	5f 1f       	adc	r21, r31
    271e:	4c 83       	std	Y+4, r20	; 0x04
    2720:	5d 83       	std	Y+5, r21	; 0x05
    2722:	1a 8e       	std	Y+26, r1	; 0x1a
    2724:	ea 83       	std	Y+2, r30	; 0x02
    2726:	fb 83       	std	Y+3, r31	; 0x03
    2728:	01 97       	sbiw	r24, 0x01	; 1
    272a:	82 9f       	mul	r24, r18
    272c:	a0 01       	movw	r20, r0
    272e:	83 9f       	mul	r24, r19
    2730:	50 0d       	add	r21, r0
    2732:	92 9f       	mul	r25, r18
    2734:	50 0d       	add	r21, r0
    2736:	11 24       	eor	r1, r1
    2738:	cf 01       	movw	r24, r30
    273a:	84 0f       	add	r24, r20
    273c:	95 1f       	adc	r25, r21
    273e:	8e 83       	std	Y+6, r24	; 0x06
    2740:	9f 83       	std	Y+7, r25	; 0x07
    2742:	8f ef       	ldi	r24, 0xFF	; 255
    2744:	8d 8f       	std	Y+29, r24	; 0x1d
    2746:	8e 8f       	std	Y+30, r24	; 0x1e
    2748:	61 11       	cpse	r22, r1
    274a:	0a c0       	rjmp	.+20     	; 0x2760 <xQueueGenericReset+0x6c>
    274c:	88 85       	ldd	r24, Y+8	; 0x08
    274e:	88 23       	and	r24, r24
    2750:	69 f0       	breq	.+26     	; 0x276c <xQueueGenericReset+0x78>
    2752:	ce 01       	movw	r24, r28
    2754:	08 96       	adiw	r24, 0x08	; 8
    2756:	fa d4       	rcall	.+2548   	; 0x314c <xTaskRemoveFromEventList>
    2758:	88 23       	and	r24, r24
    275a:	41 f0       	breq	.+16     	; 0x276c <xQueueGenericReset+0x78>
    275c:	48 de       	rcall	.-880    	; 0x23ee <vPortYield>
    275e:	06 c0       	rjmp	.+12     	; 0x276c <xQueueGenericReset+0x78>
    2760:	ce 01       	movw	r24, r28
    2762:	08 96       	adiw	r24, 0x08	; 8
    2764:	fd dc       	rcall	.-1542   	; 0x2160 <vListInitialise>
    2766:	ce 01       	movw	r24, r28
    2768:	41 96       	adiw	r24, 0x11	; 17
    276a:	fa dc       	rcall	.-1548   	; 0x2160 <vListInitialise>
    276c:	0f 90       	pop	r0
    276e:	0f be       	out	0x3f, r0	; 63
    2770:	81 e0       	ldi	r24, 0x01	; 1
    2772:	df 91       	pop	r29
    2774:	cf 91       	pop	r28
    2776:	08 95       	ret

00002778 <xQueueGenericCreate>:
    2778:	0f 93       	push	r16
    277a:	1f 93       	push	r17
    277c:	cf 93       	push	r28
    277e:	df 93       	push	r29
    2780:	08 2f       	mov	r16, r24
    2782:	16 2f       	mov	r17, r22
    2784:	86 9f       	mul	r24, r22
    2786:	c0 01       	movw	r24, r0
    2788:	11 24       	eor	r1, r1
    278a:	4f 96       	adiw	r24, 0x1f	; 31
    278c:	e2 de       	rcall	.-572    	; 0x2552 <pvPortMalloc>
    278e:	ec 01       	movw	r28, r24
    2790:	00 97       	sbiw	r24, 0x00	; 0
    2792:	69 f0       	breq	.+26     	; 0x27ae <xQueueGenericCreate+0x36>
    2794:	11 11       	cpse	r17, r1
    2796:	03 c0       	rjmp	.+6      	; 0x279e <xQueueGenericCreate+0x26>
    2798:	88 83       	st	Y, r24
    279a:	99 83       	std	Y+1, r25	; 0x01
    279c:	03 c0       	rjmp	.+6      	; 0x27a4 <xQueueGenericCreate+0x2c>
    279e:	4f 96       	adiw	r24, 0x1f	; 31
    27a0:	88 83       	st	Y, r24
    27a2:	99 83       	std	Y+1, r25	; 0x01
    27a4:	0b 8f       	std	Y+27, r16	; 0x1b
    27a6:	1c 8f       	std	Y+28, r17	; 0x1c
    27a8:	61 e0       	ldi	r22, 0x01	; 1
    27aa:	ce 01       	movw	r24, r28
    27ac:	a3 df       	rcall	.-186    	; 0x26f4 <xQueueGenericReset>
    27ae:	ce 01       	movw	r24, r28
    27b0:	df 91       	pop	r29
    27b2:	cf 91       	pop	r28
    27b4:	1f 91       	pop	r17
    27b6:	0f 91       	pop	r16
    27b8:	08 95       	ret

000027ba <xQueueGenericSend>:
    27ba:	af 92       	push	r10
    27bc:	bf 92       	push	r11
    27be:	cf 92       	push	r12
    27c0:	df 92       	push	r13
    27c2:	ef 92       	push	r14
    27c4:	ff 92       	push	r15
    27c6:	0f 93       	push	r16
    27c8:	1f 93       	push	r17
    27ca:	cf 93       	push	r28
    27cc:	df 93       	push	r29
    27ce:	cd b7       	in	r28, 0x3d	; 61
    27d0:	de b7       	in	r29, 0x3e	; 62
    27d2:	25 97       	sbiw	r28, 0x05	; 5
    27d4:	cd bf       	out	0x3d, r28	; 61
    27d6:	de bf       	out	0x3e, r29	; 62
    27d8:	8c 01       	movw	r16, r24
    27da:	6b 01       	movw	r12, r22
    27dc:	4c 83       	std	Y+4, r20	; 0x04
    27de:	5d 83       	std	Y+5, r21	; 0x05
    27e0:	a2 2e       	mov	r10, r18
    27e2:	b1 2c       	mov	r11, r1
    27e4:	7c 01       	movw	r14, r24
    27e6:	88 e0       	ldi	r24, 0x08	; 8
    27e8:	e8 0e       	add	r14, r24
    27ea:	f1 1c       	adc	r15, r1
    27ec:	0f b6       	in	r0, 0x3f	; 63
    27ee:	f8 94       	cli
    27f0:	0f 92       	push	r0
    27f2:	f8 01       	movw	r30, r16
    27f4:	92 8d       	ldd	r25, Z+26	; 0x1a
    27f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    27f8:	98 17       	cp	r25, r24
    27fa:	18 f0       	brcs	.+6      	; 0x2802 <xQueueGenericSend+0x48>
    27fc:	f2 e0       	ldi	r31, 0x02	; 2
    27fe:	af 12       	cpse	r10, r31
    2800:	15 c0       	rjmp	.+42     	; 0x282c <xQueueGenericSend+0x72>
    2802:	4a 2d       	mov	r20, r10
    2804:	b6 01       	movw	r22, r12
    2806:	c8 01       	movw	r24, r16
    2808:	c9 de       	rcall	.-622    	; 0x259c <prvCopyDataToQueue>
    280a:	f8 01       	movw	r30, r16
    280c:	91 89       	ldd	r25, Z+17	; 0x11
    280e:	99 23       	and	r25, r25
    2810:	39 f0       	breq	.+14     	; 0x2820 <xQueueGenericSend+0x66>
    2812:	c8 01       	movw	r24, r16
    2814:	41 96       	adiw	r24, 0x11	; 17
    2816:	9a d4       	rcall	.+2356   	; 0x314c <xTaskRemoveFromEventList>
    2818:	88 23       	and	r24, r24
    281a:	21 f0       	breq	.+8      	; 0x2824 <xQueueGenericSend+0x6a>
    281c:	e8 dd       	rcall	.-1072   	; 0x23ee <vPortYield>
    281e:	02 c0       	rjmp	.+4      	; 0x2824 <xQueueGenericSend+0x6a>
    2820:	81 11       	cpse	r24, r1
    2822:	e5 dd       	rcall	.-1078   	; 0x23ee <vPortYield>
    2824:	0f 90       	pop	r0
    2826:	0f be       	out	0x3f, r0	; 63
    2828:	81 e0       	ldi	r24, 0x01	; 1
    282a:	46 c0       	rjmp	.+140    	; 0x28b8 <xQueueGenericSend+0xfe>
    282c:	8c 81       	ldd	r24, Y+4	; 0x04
    282e:	9d 81       	ldd	r25, Y+5	; 0x05
    2830:	89 2b       	or	r24, r25
    2832:	21 f4       	brne	.+8      	; 0x283c <xQueueGenericSend+0x82>
    2834:	0f 90       	pop	r0
    2836:	0f be       	out	0x3f, r0	; 63
    2838:	80 e0       	ldi	r24, 0x00	; 0
    283a:	3e c0       	rjmp	.+124    	; 0x28b8 <xQueueGenericSend+0xfe>
    283c:	b1 10       	cpse	r11, r1
    283e:	05 c0       	rjmp	.+10     	; 0x284a <xQueueGenericSend+0x90>
    2840:	ce 01       	movw	r24, r28
    2842:	01 96       	adiw	r24, 0x01	; 1
    2844:	c9 d4       	rcall	.+2450   	; 0x31d8 <vTaskInternalSetTimeOutState>
    2846:	bb 24       	eor	r11, r11
    2848:	b3 94       	inc	r11
    284a:	0f 90       	pop	r0
    284c:	0f be       	out	0x3f, r0	; 63
    284e:	ac d2       	rcall	.+1368   	; 0x2da8 <vTaskSuspendAll>
    2850:	0f b6       	in	r0, 0x3f	; 63
    2852:	f8 94       	cli
    2854:	0f 92       	push	r0
    2856:	f8 01       	movw	r30, r16
    2858:	85 8d       	ldd	r24, Z+29	; 0x1d
    285a:	8f 3f       	cpi	r24, 0xFF	; 255
    285c:	09 f4       	brne	.+2      	; 0x2860 <xQueueGenericSend+0xa6>
    285e:	15 8e       	std	Z+29, r1	; 0x1d
    2860:	f8 01       	movw	r30, r16
    2862:	86 8d       	ldd	r24, Z+30	; 0x1e
    2864:	8f 3f       	cpi	r24, 0xFF	; 255
    2866:	09 f4       	brne	.+2      	; 0x286a <xQueueGenericSend+0xb0>
    2868:	16 8e       	std	Z+30, r1	; 0x1e
    286a:	0f 90       	pop	r0
    286c:	0f be       	out	0x3f, r0	; 63
    286e:	be 01       	movw	r22, r28
    2870:	6c 5f       	subi	r22, 0xFC	; 252
    2872:	7f 4f       	sbci	r23, 0xFF	; 255
    2874:	ce 01       	movw	r24, r28
    2876:	01 96       	adiw	r24, 0x01	; 1
    2878:	ba d4       	rcall	.+2420   	; 0x31ee <xTaskCheckForTimeOut>
    287a:	81 11       	cpse	r24, r1
    287c:	19 c0       	rjmp	.+50     	; 0x28b0 <xQueueGenericSend+0xf6>
    287e:	0f b6       	in	r0, 0x3f	; 63
    2880:	f8 94       	cli
    2882:	0f 92       	push	r0
    2884:	f8 01       	movw	r30, r16
    2886:	92 8d       	ldd	r25, Z+26	; 0x1a
    2888:	0f 90       	pop	r0
    288a:	0f be       	out	0x3f, r0	; 63
    288c:	83 8d       	ldd	r24, Z+27	; 0x1b
    288e:	98 13       	cpse	r25, r24
    2890:	0b c0       	rjmp	.+22     	; 0x28a8 <xQueueGenericSend+0xee>
    2892:	6c 81       	ldd	r22, Y+4	; 0x04
    2894:	7d 81       	ldd	r23, Y+5	; 0x05
    2896:	c7 01       	movw	r24, r14
    2898:	32 d4       	rcall	.+2148   	; 0x30fe <vTaskPlaceOnEventList>
    289a:	c8 01       	movw	r24, r16
    289c:	e2 de       	rcall	.-572    	; 0x2662 <prvUnlockQueue>
    289e:	4c d3       	rcall	.+1688   	; 0x2f38 <xTaskResumeAll>
    28a0:	81 11       	cpse	r24, r1
    28a2:	a4 cf       	rjmp	.-184    	; 0x27ec <xQueueGenericSend+0x32>
    28a4:	a4 dd       	rcall	.-1208   	; 0x23ee <vPortYield>
    28a6:	a2 cf       	rjmp	.-188    	; 0x27ec <xQueueGenericSend+0x32>
    28a8:	c8 01       	movw	r24, r16
    28aa:	db de       	rcall	.-586    	; 0x2662 <prvUnlockQueue>
    28ac:	45 d3       	rcall	.+1674   	; 0x2f38 <xTaskResumeAll>
    28ae:	9e cf       	rjmp	.-196    	; 0x27ec <xQueueGenericSend+0x32>
    28b0:	c8 01       	movw	r24, r16
    28b2:	d7 de       	rcall	.-594    	; 0x2662 <prvUnlockQueue>
    28b4:	41 d3       	rcall	.+1666   	; 0x2f38 <xTaskResumeAll>
    28b6:	80 e0       	ldi	r24, 0x00	; 0
    28b8:	25 96       	adiw	r28, 0x05	; 5
    28ba:	cd bf       	out	0x3d, r28	; 61
    28bc:	de bf       	out	0x3e, r29	; 62
    28be:	df 91       	pop	r29
    28c0:	cf 91       	pop	r28
    28c2:	1f 91       	pop	r17
    28c4:	0f 91       	pop	r16
    28c6:	ff 90       	pop	r15
    28c8:	ef 90       	pop	r14
    28ca:	df 90       	pop	r13
    28cc:	cf 90       	pop	r12
    28ce:	bf 90       	pop	r11
    28d0:	af 90       	pop	r10
    28d2:	08 95       	ret

000028d4 <xQueueGenericSendFromISR>:
    28d4:	ef 92       	push	r14
    28d6:	ff 92       	push	r15
    28d8:	0f 93       	push	r16
    28da:	1f 93       	push	r17
    28dc:	cf 93       	push	r28
    28de:	df 93       	push	r29
    28e0:	8a 01       	movw	r16, r20
    28e2:	fc 01       	movw	r30, r24
    28e4:	52 8d       	ldd	r21, Z+26	; 0x1a
    28e6:	33 8d       	ldd	r19, Z+27	; 0x1b
    28e8:	53 17       	cp	r21, r19
    28ea:	10 f0       	brcs	.+4      	; 0x28f0 <xQueueGenericSendFromISR+0x1c>
    28ec:	22 30       	cpi	r18, 0x02	; 2
    28ee:	f1 f4       	brne	.+60     	; 0x292c <xQueueGenericSendFromISR+0x58>
    28f0:	42 2f       	mov	r20, r18
    28f2:	78 01       	movw	r14, r16
    28f4:	ec 01       	movw	r28, r24
    28f6:	1e 8d       	ldd	r17, Y+30	; 0x1e
    28f8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28fa:	ce 01       	movw	r24, r28
    28fc:	4f de       	rcall	.-866    	; 0x259c <prvCopyDataToQueue>
    28fe:	1f 3f       	cpi	r17, 0xFF	; 255
    2900:	79 f4       	brne	.+30     	; 0x2920 <xQueueGenericSendFromISR+0x4c>
    2902:	89 89       	ldd	r24, Y+17	; 0x11
    2904:	88 23       	and	r24, r24
    2906:	a1 f0       	breq	.+40     	; 0x2930 <xQueueGenericSendFromISR+0x5c>
    2908:	ce 01       	movw	r24, r28
    290a:	41 96       	adiw	r24, 0x11	; 17
    290c:	1f d4       	rcall	.+2110   	; 0x314c <xTaskRemoveFromEventList>
    290e:	88 23       	and	r24, r24
    2910:	89 f0       	breq	.+34     	; 0x2934 <xQueueGenericSendFromISR+0x60>
    2912:	e1 14       	cp	r14, r1
    2914:	f1 04       	cpc	r15, r1
    2916:	81 f0       	breq	.+32     	; 0x2938 <xQueueGenericSendFromISR+0x64>
    2918:	81 e0       	ldi	r24, 0x01	; 1
    291a:	f7 01       	movw	r30, r14
    291c:	80 83       	st	Z, r24
    291e:	0d c0       	rjmp	.+26     	; 0x293a <xQueueGenericSendFromISR+0x66>
    2920:	ff 24       	eor	r15, r15
    2922:	f3 94       	inc	r15
    2924:	f1 0e       	add	r15, r17
    2926:	fe 8e       	std	Y+30, r15	; 0x1e
    2928:	81 e0       	ldi	r24, 0x01	; 1
    292a:	07 c0       	rjmp	.+14     	; 0x293a <xQueueGenericSendFromISR+0x66>
    292c:	80 e0       	ldi	r24, 0x00	; 0
    292e:	05 c0       	rjmp	.+10     	; 0x293a <xQueueGenericSendFromISR+0x66>
    2930:	81 e0       	ldi	r24, 0x01	; 1
    2932:	03 c0       	rjmp	.+6      	; 0x293a <xQueueGenericSendFromISR+0x66>
    2934:	81 e0       	ldi	r24, 0x01	; 1
    2936:	01 c0       	rjmp	.+2      	; 0x293a <xQueueGenericSendFromISR+0x66>
    2938:	81 e0       	ldi	r24, 0x01	; 1
    293a:	df 91       	pop	r29
    293c:	cf 91       	pop	r28
    293e:	1f 91       	pop	r17
    2940:	0f 91       	pop	r16
    2942:	ff 90       	pop	r15
    2944:	ef 90       	pop	r14
    2946:	08 95       	ret

00002948 <xQueueReceive>:
    2948:	af 92       	push	r10
    294a:	bf 92       	push	r11
    294c:	cf 92       	push	r12
    294e:	df 92       	push	r13
    2950:	ef 92       	push	r14
    2952:	ff 92       	push	r15
    2954:	0f 93       	push	r16
    2956:	1f 93       	push	r17
    2958:	cf 93       	push	r28
    295a:	df 93       	push	r29
    295c:	cd b7       	in	r28, 0x3d	; 61
    295e:	de b7       	in	r29, 0x3e	; 62
    2960:	25 97       	sbiw	r28, 0x05	; 5
    2962:	cd bf       	out	0x3d, r28	; 61
    2964:	de bf       	out	0x3e, r29	; 62
    2966:	8c 01       	movw	r16, r24
    2968:	5b 01       	movw	r10, r22
    296a:	4c 83       	std	Y+4, r20	; 0x04
    296c:	5d 83       	std	Y+5, r21	; 0x05
    296e:	e1 2c       	mov	r14, r1
    2970:	6c 01       	movw	r12, r24
    2972:	81 e1       	ldi	r24, 0x11	; 17
    2974:	c8 0e       	add	r12, r24
    2976:	d1 1c       	adc	r13, r1
    2978:	0f b6       	in	r0, 0x3f	; 63
    297a:	f8 94       	cli
    297c:	0f 92       	push	r0
    297e:	f8 01       	movw	r30, r16
    2980:	f2 8c       	ldd	r15, Z+26	; 0x1a
    2982:	ff 20       	and	r15, r15
    2984:	91 f0       	breq	.+36     	; 0x29aa <xQueueReceive+0x62>
    2986:	b5 01       	movw	r22, r10
    2988:	c8 01       	movw	r24, r16
    298a:	51 de       	rcall	.-862    	; 0x262e <prvCopyDataFromQueue>
    298c:	fa 94       	dec	r15
    298e:	f8 01       	movw	r30, r16
    2990:	f2 8e       	std	Z+26, r15	; 0x1a
    2992:	80 85       	ldd	r24, Z+8	; 0x08
    2994:	88 23       	and	r24, r24
    2996:	29 f0       	breq	.+10     	; 0x29a2 <xQueueReceive+0x5a>
    2998:	c8 01       	movw	r24, r16
    299a:	08 96       	adiw	r24, 0x08	; 8
    299c:	d7 d3       	rcall	.+1966   	; 0x314c <xTaskRemoveFromEventList>
    299e:	81 11       	cpse	r24, r1
    29a0:	26 dd       	rcall	.-1460   	; 0x23ee <vPortYield>
    29a2:	0f 90       	pop	r0
    29a4:	0f be       	out	0x3f, r0	; 63
    29a6:	81 e0       	ldi	r24, 0x01	; 1
    29a8:	45 c0       	rjmp	.+138    	; 0x2a34 <xQueueReceive+0xec>
    29aa:	8c 81       	ldd	r24, Y+4	; 0x04
    29ac:	9d 81       	ldd	r25, Y+5	; 0x05
    29ae:	89 2b       	or	r24, r25
    29b0:	21 f4       	brne	.+8      	; 0x29ba <xQueueReceive+0x72>
    29b2:	0f 90       	pop	r0
    29b4:	0f be       	out	0x3f, r0	; 63
    29b6:	80 e0       	ldi	r24, 0x00	; 0
    29b8:	3d c0       	rjmp	.+122    	; 0x2a34 <xQueueReceive+0xec>
    29ba:	e1 10       	cpse	r14, r1
    29bc:	05 c0       	rjmp	.+10     	; 0x29c8 <xQueueReceive+0x80>
    29be:	ce 01       	movw	r24, r28
    29c0:	01 96       	adiw	r24, 0x01	; 1
    29c2:	0a d4       	rcall	.+2068   	; 0x31d8 <vTaskInternalSetTimeOutState>
    29c4:	ee 24       	eor	r14, r14
    29c6:	e3 94       	inc	r14
    29c8:	0f 90       	pop	r0
    29ca:	0f be       	out	0x3f, r0	; 63
    29cc:	ed d1       	rcall	.+986    	; 0x2da8 <vTaskSuspendAll>
    29ce:	0f b6       	in	r0, 0x3f	; 63
    29d0:	f8 94       	cli
    29d2:	0f 92       	push	r0
    29d4:	f8 01       	movw	r30, r16
    29d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    29d8:	8f 3f       	cpi	r24, 0xFF	; 255
    29da:	09 f4       	brne	.+2      	; 0x29de <xQueueReceive+0x96>
    29dc:	15 8e       	std	Z+29, r1	; 0x1d
    29de:	f8 01       	movw	r30, r16
    29e0:	86 8d       	ldd	r24, Z+30	; 0x1e
    29e2:	8f 3f       	cpi	r24, 0xFF	; 255
    29e4:	09 f4       	brne	.+2      	; 0x29e8 <xQueueReceive+0xa0>
    29e6:	16 8e       	std	Z+30, r1	; 0x1e
    29e8:	0f 90       	pop	r0
    29ea:	0f be       	out	0x3f, r0	; 63
    29ec:	be 01       	movw	r22, r28
    29ee:	6c 5f       	subi	r22, 0xFC	; 252
    29f0:	7f 4f       	sbci	r23, 0xFF	; 255
    29f2:	ce 01       	movw	r24, r28
    29f4:	01 96       	adiw	r24, 0x01	; 1
    29f6:	fb d3       	rcall	.+2038   	; 0x31ee <xTaskCheckForTimeOut>
    29f8:	81 11       	cpse	r24, r1
    29fa:	13 c0       	rjmp	.+38     	; 0x2a22 <xQueueReceive+0xda>
    29fc:	c8 01       	movw	r24, r16
    29fe:	c3 dd       	rcall	.-1146   	; 0x2586 <prvIsQueueEmpty>
    2a00:	88 23       	and	r24, r24
    2a02:	59 f0       	breq	.+22     	; 0x2a1a <xQueueReceive+0xd2>
    2a04:	6c 81       	ldd	r22, Y+4	; 0x04
    2a06:	7d 81       	ldd	r23, Y+5	; 0x05
    2a08:	c6 01       	movw	r24, r12
    2a0a:	79 d3       	rcall	.+1778   	; 0x30fe <vTaskPlaceOnEventList>
    2a0c:	c8 01       	movw	r24, r16
    2a0e:	29 de       	rcall	.-942    	; 0x2662 <prvUnlockQueue>
    2a10:	93 d2       	rcall	.+1318   	; 0x2f38 <xTaskResumeAll>
    2a12:	81 11       	cpse	r24, r1
    2a14:	b1 cf       	rjmp	.-158    	; 0x2978 <xQueueReceive+0x30>
    2a16:	eb dc       	rcall	.-1578   	; 0x23ee <vPortYield>
    2a18:	af cf       	rjmp	.-162    	; 0x2978 <xQueueReceive+0x30>
    2a1a:	c8 01       	movw	r24, r16
    2a1c:	22 de       	rcall	.-956    	; 0x2662 <prvUnlockQueue>
    2a1e:	8c d2       	rcall	.+1304   	; 0x2f38 <xTaskResumeAll>
    2a20:	ab cf       	rjmp	.-170    	; 0x2978 <xQueueReceive+0x30>
    2a22:	c8 01       	movw	r24, r16
    2a24:	1e de       	rcall	.-964    	; 0x2662 <prvUnlockQueue>
    2a26:	88 d2       	rcall	.+1296   	; 0x2f38 <xTaskResumeAll>
    2a28:	c8 01       	movw	r24, r16
    2a2a:	ad dd       	rcall	.-1190   	; 0x2586 <prvIsQueueEmpty>
    2a2c:	88 23       	and	r24, r24
    2a2e:	09 f4       	brne	.+2      	; 0x2a32 <xQueueReceive+0xea>
    2a30:	a3 cf       	rjmp	.-186    	; 0x2978 <xQueueReceive+0x30>
    2a32:	80 e0       	ldi	r24, 0x00	; 0
    2a34:	25 96       	adiw	r28, 0x05	; 5
    2a36:	cd bf       	out	0x3d, r28	; 61
    2a38:	de bf       	out	0x3e, r29	; 62
    2a3a:	df 91       	pop	r29
    2a3c:	cf 91       	pop	r28
    2a3e:	1f 91       	pop	r17
    2a40:	0f 91       	pop	r16
    2a42:	ff 90       	pop	r15
    2a44:	ef 90       	pop	r14
    2a46:	df 90       	pop	r13
    2a48:	cf 90       	pop	r12
    2a4a:	bf 90       	pop	r11
    2a4c:	af 90       	pop	r10
    2a4e:	08 95       	ret

00002a50 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    2a50:	cf 93       	push	r28
    2a52:	df 93       	push	r29
    2a54:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    2a56:	0f b6       	in	r0, 0x3f	; 63
    2a58:	f8 94       	cli
    2a5a:	0f 92       	push	r0
    2a5c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2a5e:	8f 3f       	cpi	r24, 0xFF	; 255
    2a60:	09 f4       	brne	.+2      	; 0x2a64 <vQueueWaitForMessageRestricted+0x14>
    2a62:	1d 8e       	std	Y+29, r1	; 0x1d
    2a64:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2a66:	8f 3f       	cpi	r24, 0xFF	; 255
    2a68:	09 f4       	brne	.+2      	; 0x2a6c <vQueueWaitForMessageRestricted+0x1c>
    2a6a:	1e 8e       	std	Y+30, r1	; 0x1e
    2a6c:	0f 90       	pop	r0
    2a6e:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2a70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2a72:	81 11       	cpse	r24, r1
    2a74:	03 c0       	rjmp	.+6      	; 0x2a7c <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2a76:	ce 01       	movw	r24, r28
    2a78:	41 96       	adiw	r24, 0x11	; 17
    2a7a:	51 d3       	rcall	.+1698   	; 0x311e <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    2a7c:	ce 01       	movw	r24, r28
    2a7e:	f1 dd       	rcall	.-1054   	; 0x2662 <prvUnlockQueue>
	}
    2a80:	df 91       	pop	r29
    2a82:	cf 91       	pop	r28
    2a84:	08 95       	ret

00002a86 <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    2a86:	e0 91 7b 22 	lds	r30, 0x227B	; 0x80227b <pxDelayedTaskList>
    2a8a:	f0 91 7c 22 	lds	r31, 0x227C	; 0x80227c <pxDelayedTaskList+0x1>
    2a8e:	80 81       	ld	r24, Z
    2a90:	81 11       	cpse	r24, r1
    2a92:	07 c0       	rjmp	.+14     	; 0x2aa2 <prvResetNextTaskUnblockTime+0x1c>
    2a94:	8f ef       	ldi	r24, 0xFF	; 255
    2a96:	9f ef       	ldi	r25, 0xFF	; 255
    2a98:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <xNextTaskUnblockTime>
    2a9c:	90 93 65 22 	sts	0x2265, r25	; 0x802265 <xNextTaskUnblockTime+0x1>
    2aa0:	08 95       	ret
    2aa2:	e0 91 7b 22 	lds	r30, 0x227B	; 0x80227b <pxDelayedTaskList>
    2aa6:	f0 91 7c 22 	lds	r31, 0x227C	; 0x80227c <pxDelayedTaskList+0x1>
    2aaa:	05 80       	ldd	r0, Z+5	; 0x05
    2aac:	f6 81       	ldd	r31, Z+6	; 0x06
    2aae:	e0 2d       	mov	r30, r0
    2ab0:	06 80       	ldd	r0, Z+6	; 0x06
    2ab2:	f7 81       	ldd	r31, Z+7	; 0x07
    2ab4:	e0 2d       	mov	r30, r0
    2ab6:	82 81       	ldd	r24, Z+2	; 0x02
    2ab8:	93 81       	ldd	r25, Z+3	; 0x03
    2aba:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <xNextTaskUnblockTime>
    2abe:	90 93 65 22 	sts	0x2265, r25	; 0x802265 <xNextTaskUnblockTime+0x1>
    2ac2:	08 95       	ret

00002ac4 <prvIdleTask>:
    2ac4:	cf e8       	ldi	r28, 0x8F	; 143
    2ac6:	d2 e2       	ldi	r29, 0x22	; 34
    2ac8:	88 81       	ld	r24, Y
    2aca:	82 30       	cpi	r24, 0x02	; 2
    2acc:	e8 f3       	brcs	.-6      	; 0x2ac8 <prvIdleTask+0x4>
    2ace:	8f dc       	rcall	.-1762   	; 0x23ee <vPortYield>
    2ad0:	fb cf       	rjmp	.-10     	; 0x2ac8 <prvIdleTask+0x4>

00002ad2 <prvAddCurrentTaskToDelayedList>:
    2ad2:	0f 93       	push	r16
    2ad4:	1f 93       	push	r17
    2ad6:	cf 93       	push	r28
    2ad8:	df 93       	push	r29
    2ada:	ec 01       	movw	r28, r24
    2adc:	00 91 6d 22 	lds	r16, 0x226D	; 0x80226d <xTickCount>
    2ae0:	10 91 6e 22 	lds	r17, 0x226E	; 0x80226e <xTickCount+0x1>
    2ae4:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2ae8:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2aec:	02 96       	adiw	r24, 0x02	; 2
    2aee:	9c db       	rcall	.-2248   	; 0x2228 <uxListRemove>
    2af0:	c0 0f       	add	r28, r16
    2af2:	d1 1f       	adc	r29, r17
    2af4:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2af8:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2afc:	c2 83       	std	Z+2, r28	; 0x02
    2afe:	d3 83       	std	Z+3, r29	; 0x03
    2b00:	c0 17       	cp	r28, r16
    2b02:	d1 07       	cpc	r29, r17
    2b04:	60 f4       	brcc	.+24     	; 0x2b1e <prvAddCurrentTaskToDelayedList+0x4c>
    2b06:	60 91 bc 22 	lds	r22, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2b0a:	70 91 bd 22 	lds	r23, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2b0e:	80 91 79 22 	lds	r24, 0x2279	; 0x802279 <pxOverflowDelayedTaskList>
    2b12:	90 91 7a 22 	lds	r25, 0x227A	; 0x80227a <pxOverflowDelayedTaskList+0x1>
    2b16:	6e 5f       	subi	r22, 0xFE	; 254
    2b18:	7f 4f       	sbci	r23, 0xFF	; 255
    2b1a:	55 db       	rcall	.-2390   	; 0x21c6 <vListInsert>
    2b1c:	16 c0       	rjmp	.+44     	; 0x2b4a <prvAddCurrentTaskToDelayedList+0x78>
    2b1e:	60 91 bc 22 	lds	r22, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2b22:	70 91 bd 22 	lds	r23, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2b26:	80 91 7b 22 	lds	r24, 0x227B	; 0x80227b <pxDelayedTaskList>
    2b2a:	90 91 7c 22 	lds	r25, 0x227C	; 0x80227c <pxDelayedTaskList+0x1>
    2b2e:	6e 5f       	subi	r22, 0xFE	; 254
    2b30:	7f 4f       	sbci	r23, 0xFF	; 255
    2b32:	49 db       	rcall	.-2414   	; 0x21c6 <vListInsert>
    2b34:	80 91 64 22 	lds	r24, 0x2264	; 0x802264 <xNextTaskUnblockTime>
    2b38:	90 91 65 22 	lds	r25, 0x2265	; 0x802265 <xNextTaskUnblockTime+0x1>
    2b3c:	c8 17       	cp	r28, r24
    2b3e:	d9 07       	cpc	r29, r25
    2b40:	20 f4       	brcc	.+8      	; 0x2b4a <prvAddCurrentTaskToDelayedList+0x78>
    2b42:	c0 93 64 22 	sts	0x2264, r28	; 0x802264 <xNextTaskUnblockTime>
    2b46:	d0 93 65 22 	sts	0x2265, r29	; 0x802265 <xNextTaskUnblockTime+0x1>
    2b4a:	df 91       	pop	r29
    2b4c:	cf 91       	pop	r28
    2b4e:	1f 91       	pop	r17
    2b50:	0f 91       	pop	r16
    2b52:	08 95       	ret

00002b54 <xTaskCreate>:
    2b54:	4f 92       	push	r4
    2b56:	5f 92       	push	r5
    2b58:	6f 92       	push	r6
    2b5a:	7f 92       	push	r7
    2b5c:	8f 92       	push	r8
    2b5e:	9f 92       	push	r9
    2b60:	af 92       	push	r10
    2b62:	bf 92       	push	r11
    2b64:	cf 92       	push	r12
    2b66:	df 92       	push	r13
    2b68:	ef 92       	push	r14
    2b6a:	ff 92       	push	r15
    2b6c:	0f 93       	push	r16
    2b6e:	1f 93       	push	r17
    2b70:	cf 93       	push	r28
    2b72:	df 93       	push	r29
    2b74:	4c 01       	movw	r8, r24
    2b76:	6b 01       	movw	r12, r22
    2b78:	5a 01       	movw	r10, r20
    2b7a:	29 01       	movw	r4, r18
    2b7c:	ca 01       	movw	r24, r20
    2b7e:	e9 dc       	rcall	.-1582   	; 0x2552 <pvPortMalloc>
    2b80:	3c 01       	movw	r6, r24
    2b82:	89 2b       	or	r24, r25
    2b84:	09 f4       	brne	.+2      	; 0x2b88 <xTaskCreate+0x34>
    2b86:	d3 c0       	rjmp	.+422    	; 0x2d2e <xTaskCreate+0x1da>
    2b88:	86 e2       	ldi	r24, 0x26	; 38
    2b8a:	90 e0       	ldi	r25, 0x00	; 0
    2b8c:	e2 dc       	rcall	.-1596   	; 0x2552 <pvPortMalloc>
    2b8e:	ec 01       	movw	r28, r24
    2b90:	89 2b       	or	r24, r25
    2b92:	59 f0       	breq	.+22     	; 0x2baa <xTaskCreate+0x56>
    2b94:	6f 8a       	std	Y+23, r6	; 0x17
    2b96:	78 8e       	std	Y+24, r7	; 0x18
    2b98:	81 e0       	ldi	r24, 0x01	; 1
    2b9a:	a8 1a       	sub	r10, r24
    2b9c:	b1 08       	sbc	r11, r1
    2b9e:	a6 0c       	add	r10, r6
    2ba0:	b7 1c       	adc	r11, r7
    2ba2:	c1 14       	cp	r12, r1
    2ba4:	d1 04       	cpc	r13, r1
    2ba6:	21 f4       	brne	.+8      	; 0x2bb0 <xTaskCreate+0x5c>
    2ba8:	1f c0       	rjmp	.+62     	; 0x2be8 <xTaskCreate+0x94>
    2baa:	c3 01       	movw	r24, r6
    2bac:	df dc       	rcall	.-1602   	; 0x256c <vPortFree>
    2bae:	bf c0       	rjmp	.+382    	; 0x2d2e <xTaskCreate+0x1da>
    2bb0:	d6 01       	movw	r26, r12
    2bb2:	8c 91       	ld	r24, X
    2bb4:	89 8f       	std	Y+25, r24	; 0x19
    2bb6:	8c 91       	ld	r24, X
    2bb8:	88 23       	and	r24, r24
    2bba:	a1 f0       	breq	.+40     	; 0x2be4 <xTaskCreate+0x90>
    2bbc:	ae 01       	movw	r20, r28
    2bbe:	46 5e       	subi	r20, 0xE6	; 230
    2bc0:	5f 4f       	sbci	r21, 0xFF	; 255
    2bc2:	f6 01       	movw	r30, r12
    2bc4:	31 96       	adiw	r30, 0x01	; 1
    2bc6:	b8 e0       	ldi	r27, 0x08	; 8
    2bc8:	cb 0e       	add	r12, r27
    2bca:	d1 1c       	adc	r13, r1
    2bcc:	cf 01       	movw	r24, r30
    2bce:	21 91       	ld	r18, Z+
    2bd0:	da 01       	movw	r26, r20
    2bd2:	2d 93       	st	X+, r18
    2bd4:	ad 01       	movw	r20, r26
    2bd6:	dc 01       	movw	r26, r24
    2bd8:	8c 91       	ld	r24, X
    2bda:	88 23       	and	r24, r24
    2bdc:	19 f0       	breq	.+6      	; 0x2be4 <xTaskCreate+0x90>
    2bde:	ce 16       	cp	r12, r30
    2be0:	df 06       	cpc	r13, r31
    2be2:	a1 f7       	brne	.-24     	; 0x2bcc <xTaskCreate+0x78>
    2be4:	18 a2       	std	Y+32, r1	; 0x20
    2be6:	01 c0       	rjmp	.+2      	; 0x2bea <xTaskCreate+0x96>
    2be8:	19 8e       	std	Y+25, r1	; 0x19
    2bea:	05 30       	cpi	r16, 0x05	; 5
    2bec:	08 f0       	brcs	.+2      	; 0x2bf0 <xTaskCreate+0x9c>
    2bee:	04 e0       	ldi	r16, 0x04	; 4
    2bf0:	0e 8b       	std	Y+22, r16	; 0x16
    2bf2:	6e 01       	movw	r12, r28
    2bf4:	b2 e0       	ldi	r27, 0x02	; 2
    2bf6:	cb 0e       	add	r12, r27
    2bf8:	d1 1c       	adc	r13, r1
    2bfa:	c6 01       	movw	r24, r12
    2bfc:	bf da       	rcall	.-2690   	; 0x217c <vListInitialiseItem>
    2bfe:	ce 01       	movw	r24, r28
    2c00:	0c 96       	adiw	r24, 0x0c	; 12
    2c02:	bc da       	rcall	.-2696   	; 0x217c <vListInitialiseItem>
    2c04:	c8 87       	std	Y+8, r28	; 0x08
    2c06:	d9 87       	std	Y+9, r29	; 0x09
    2c08:	85 e0       	ldi	r24, 0x05	; 5
    2c0a:	90 e0       	ldi	r25, 0x00	; 0
    2c0c:	80 1b       	sub	r24, r16
    2c0e:	91 09       	sbc	r25, r1
    2c10:	8c 87       	std	Y+12, r24	; 0x0c
    2c12:	9d 87       	std	Y+13, r25	; 0x0d
    2c14:	ca 8b       	std	Y+18, r28	; 0x12
    2c16:	db 8b       	std	Y+19, r29	; 0x13
    2c18:	19 a2       	std	Y+33, r1	; 0x21
    2c1a:	1a a2       	std	Y+34, r1	; 0x22
    2c1c:	1b a2       	std	Y+35, r1	; 0x23
    2c1e:	1c a2       	std	Y+36, r1	; 0x24
    2c20:	1d a2       	std	Y+37, r1	; 0x25
    2c22:	a2 01       	movw	r20, r4
    2c24:	b4 01       	movw	r22, r8
    2c26:	c5 01       	movw	r24, r10
    2c28:	26 db       	rcall	.-2484   	; 0x2276 <pxPortInitialiseStack>
    2c2a:	88 83       	st	Y, r24
    2c2c:	99 83       	std	Y+1, r25	; 0x01
    2c2e:	e1 14       	cp	r14, r1
    2c30:	f1 04       	cpc	r15, r1
    2c32:	19 f0       	breq	.+6      	; 0x2c3a <xTaskCreate+0xe6>
    2c34:	f7 01       	movw	r30, r14
    2c36:	c0 83       	st	Z, r28
    2c38:	d1 83       	std	Z+1, r29	; 0x01
    2c3a:	0f b6       	in	r0, 0x3f	; 63
    2c3c:	f8 94       	cli
    2c3e:	0f 92       	push	r0
    2c40:	80 91 6f 22 	lds	r24, 0x226F	; 0x80226f <uxCurrentNumberOfTasks>
    2c44:	8f 5f       	subi	r24, 0xFF	; 255
    2c46:	80 93 6f 22 	sts	0x226F, r24	; 0x80226f <uxCurrentNumberOfTasks>
    2c4a:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2c4e:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2c52:	89 2b       	or	r24, r25
    2c54:	69 f5       	brne	.+90     	; 0x2cb0 <xTaskCreate+0x15c>
    2c56:	c0 93 bc 22 	sts	0x22BC, r28	; 0x8022bc <pxCurrentTCB>
    2c5a:	d0 93 bd 22 	sts	0x22BD, r29	; 0x8022bd <pxCurrentTCB+0x1>
    2c5e:	80 91 6f 22 	lds	r24, 0x226F	; 0x80226f <uxCurrentNumberOfTasks>
    2c62:	81 30       	cpi	r24, 0x01	; 1
    2c64:	a9 f5       	brne	.+106    	; 0x2cd0 <xTaskCreate+0x17c>
    2c66:	0f e8       	ldi	r16, 0x8F	; 143
    2c68:	12 e2       	ldi	r17, 0x22	; 34
    2c6a:	0f 2e       	mov	r0, r31
    2c6c:	fc eb       	ldi	r31, 0xBC	; 188
    2c6e:	ef 2e       	mov	r14, r31
    2c70:	f2 e2       	ldi	r31, 0x22	; 34
    2c72:	ff 2e       	mov	r15, r31
    2c74:	f0 2d       	mov	r31, r0
    2c76:	c8 01       	movw	r24, r16
    2c78:	73 da       	rcall	.-2842   	; 0x2160 <vListInitialise>
    2c7a:	07 5f       	subi	r16, 0xF7	; 247
    2c7c:	1f 4f       	sbci	r17, 0xFF	; 255
    2c7e:	0e 15       	cp	r16, r14
    2c80:	1f 05       	cpc	r17, r15
    2c82:	c9 f7       	brne	.-14     	; 0x2c76 <xTaskCreate+0x122>
    2c84:	86 e8       	ldi	r24, 0x86	; 134
    2c86:	92 e2       	ldi	r25, 0x22	; 34
    2c88:	6b da       	rcall	.-2858   	; 0x2160 <vListInitialise>
    2c8a:	8d e7       	ldi	r24, 0x7D	; 125
    2c8c:	92 e2       	ldi	r25, 0x22	; 34
    2c8e:	68 da       	rcall	.-2864   	; 0x2160 <vListInitialise>
    2c90:	80 e7       	ldi	r24, 0x70	; 112
    2c92:	92 e2       	ldi	r25, 0x22	; 34
    2c94:	65 da       	rcall	.-2870   	; 0x2160 <vListInitialise>
    2c96:	86 e8       	ldi	r24, 0x86	; 134
    2c98:	92 e2       	ldi	r25, 0x22	; 34
    2c9a:	80 93 7b 22 	sts	0x227B, r24	; 0x80227b <pxDelayedTaskList>
    2c9e:	90 93 7c 22 	sts	0x227C, r25	; 0x80227c <pxDelayedTaskList+0x1>
    2ca2:	8d e7       	ldi	r24, 0x7D	; 125
    2ca4:	92 e2       	ldi	r25, 0x22	; 34
    2ca6:	80 93 79 22 	sts	0x2279, r24	; 0x802279 <pxOverflowDelayedTaskList>
    2caa:	90 93 7a 22 	sts	0x227A, r25	; 0x80227a <pxOverflowDelayedTaskList+0x1>
    2cae:	10 c0       	rjmp	.+32     	; 0x2cd0 <xTaskCreate+0x17c>
    2cb0:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <xSchedulerRunning>
    2cb4:	81 11       	cpse	r24, r1
    2cb6:	0c c0       	rjmp	.+24     	; 0x2cd0 <xTaskCreate+0x17c>
    2cb8:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2cbc:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2cc0:	96 89       	ldd	r25, Z+22	; 0x16
    2cc2:	8e 89       	ldd	r24, Y+22	; 0x16
    2cc4:	89 17       	cp	r24, r25
    2cc6:	20 f0       	brcs	.+8      	; 0x2cd0 <xTaskCreate+0x17c>
    2cc8:	c0 93 bc 22 	sts	0x22BC, r28	; 0x8022bc <pxCurrentTCB>
    2ccc:	d0 93 bd 22 	sts	0x22BD, r29	; 0x8022bd <pxCurrentTCB+0x1>
    2cd0:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <uxTaskNumber>
    2cd4:	8f 5f       	subi	r24, 0xFF	; 255
    2cd6:	80 93 66 22 	sts	0x2266, r24	; 0x802266 <uxTaskNumber>
    2cda:	8e 89       	ldd	r24, Y+22	; 0x16
    2cdc:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <uxTopReadyPriority>
    2ce0:	98 17       	cp	r25, r24
    2ce2:	10 f4       	brcc	.+4      	; 0x2ce8 <xTaskCreate+0x194>
    2ce4:	80 93 6c 22 	sts	0x226C, r24	; 0x80226c <uxTopReadyPriority>
    2ce8:	90 e0       	ldi	r25, 0x00	; 0
    2cea:	9c 01       	movw	r18, r24
    2cec:	22 0f       	add	r18, r18
    2cee:	33 1f       	adc	r19, r19
    2cf0:	22 0f       	add	r18, r18
    2cf2:	33 1f       	adc	r19, r19
    2cf4:	22 0f       	add	r18, r18
    2cf6:	33 1f       	adc	r19, r19
    2cf8:	82 0f       	add	r24, r18
    2cfa:	93 1f       	adc	r25, r19
    2cfc:	b6 01       	movw	r22, r12
    2cfe:	81 57       	subi	r24, 0x71	; 113
    2d00:	9d 4d       	sbci	r25, 0xDD	; 221
    2d02:	40 da       	rcall	.-2944   	; 0x2184 <vListInsertEnd>
    2d04:	0f 90       	pop	r0
    2d06:	0f be       	out	0x3f, r0	; 63
    2d08:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <xSchedulerRunning>
    2d0c:	88 23       	and	r24, r24
    2d0e:	59 f0       	breq	.+22     	; 0x2d26 <xTaskCreate+0x1d2>
    2d10:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2d14:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2d18:	96 89       	ldd	r25, Z+22	; 0x16
    2d1a:	8e 89       	ldd	r24, Y+22	; 0x16
    2d1c:	98 17       	cp	r25, r24
    2d1e:	28 f4       	brcc	.+10     	; 0x2d2a <xTaskCreate+0x1d6>
    2d20:	66 db       	rcall	.-2356   	; 0x23ee <vPortYield>
    2d22:	81 e0       	ldi	r24, 0x01	; 1
    2d24:	05 c0       	rjmp	.+10     	; 0x2d30 <xTaskCreate+0x1dc>
    2d26:	81 e0       	ldi	r24, 0x01	; 1
    2d28:	03 c0       	rjmp	.+6      	; 0x2d30 <xTaskCreate+0x1dc>
    2d2a:	81 e0       	ldi	r24, 0x01	; 1
    2d2c:	01 c0       	rjmp	.+2      	; 0x2d30 <xTaskCreate+0x1dc>
    2d2e:	8f ef       	ldi	r24, 0xFF	; 255
    2d30:	df 91       	pop	r29
    2d32:	cf 91       	pop	r28
    2d34:	1f 91       	pop	r17
    2d36:	0f 91       	pop	r16
    2d38:	ff 90       	pop	r15
    2d3a:	ef 90       	pop	r14
    2d3c:	df 90       	pop	r13
    2d3e:	cf 90       	pop	r12
    2d40:	bf 90       	pop	r11
    2d42:	af 90       	pop	r10
    2d44:	9f 90       	pop	r9
    2d46:	8f 90       	pop	r8
    2d48:	7f 90       	pop	r7
    2d4a:	6f 90       	pop	r6
    2d4c:	5f 90       	pop	r5
    2d4e:	4f 90       	pop	r4
    2d50:	08 95       	ret

00002d52 <vTaskStartScheduler>:
    2d52:	ef 92       	push	r14
    2d54:	ff 92       	push	r15
    2d56:	0f 93       	push	r16
    2d58:	0f 2e       	mov	r0, r31
    2d5a:	f2 e6       	ldi	r31, 0x62	; 98
    2d5c:	ef 2e       	mov	r14, r31
    2d5e:	f2 e2       	ldi	r31, 0x22	; 34
    2d60:	ff 2e       	mov	r15, r31
    2d62:	f0 2d       	mov	r31, r0
    2d64:	00 e0       	ldi	r16, 0x00	; 0
    2d66:	20 e0       	ldi	r18, 0x00	; 0
    2d68:	30 e0       	ldi	r19, 0x00	; 0
    2d6a:	45 e5       	ldi	r20, 0x55	; 85
    2d6c:	50 e0       	ldi	r21, 0x00	; 0
    2d6e:	64 e1       	ldi	r22, 0x14	; 20
    2d70:	70 e2       	ldi	r23, 0x20	; 32
    2d72:	82 e6       	ldi	r24, 0x62	; 98
    2d74:	95 e1       	ldi	r25, 0x15	; 21
    2d76:	ee de       	rcall	.-548    	; 0x2b54 <xTaskCreate>
    2d78:	81 30       	cpi	r24, 0x01	; 1
    2d7a:	91 f4       	brne	.+36     	; 0x2da0 <vTaskStartScheduler+0x4e>
    2d7c:	cc d2       	rcall	.+1432   	; 0x3316 <xTimerCreateTimerTask>
    2d7e:	81 30       	cpi	r24, 0x01	; 1
    2d80:	79 f4       	brne	.+30     	; 0x2da0 <vTaskStartScheduler+0x4e>
    2d82:	f8 94       	cli
    2d84:	8f ef       	ldi	r24, 0xFF	; 255
    2d86:	9f ef       	ldi	r25, 0xFF	; 255
    2d88:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <xNextTaskUnblockTime>
    2d8c:	90 93 65 22 	sts	0x2265, r25	; 0x802265 <xNextTaskUnblockTime+0x1>
    2d90:	81 e0       	ldi	r24, 0x01	; 1
    2d92:	80 93 6b 22 	sts	0x226B, r24	; 0x80226b <xSchedulerRunning>
    2d96:	10 92 6d 22 	sts	0x226D, r1	; 0x80226d <xTickCount>
    2d9a:	10 92 6e 22 	sts	0x226E, r1	; 0x80226e <xTickCount+0x1>
    2d9e:	e2 da       	rcall	.-2620   	; 0x2364 <xPortStartScheduler>
    2da0:	0f 91       	pop	r16
    2da2:	ff 90       	pop	r15
    2da4:	ef 90       	pop	r14
    2da6:	08 95       	ret

00002da8 <vTaskSuspendAll>:
    2da8:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <uxSchedulerSuspended>
    2dac:	8f 5f       	subi	r24, 0xFF	; 255
    2dae:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <uxSchedulerSuspended>
    2db2:	08 95       	ret

00002db4 <xTaskGetTickCount>:
    2db4:	0f b6       	in	r0, 0x3f	; 63
    2db6:	f8 94       	cli
    2db8:	0f 92       	push	r0
    2dba:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <xTickCount>
    2dbe:	90 91 6e 22 	lds	r25, 0x226E	; 0x80226e <xTickCount+0x1>
    2dc2:	0f 90       	pop	r0
    2dc4:	0f be       	out	0x3f, r0	; 63
    2dc6:	08 95       	ret

00002dc8 <xTaskIncrementTick>:
    2dc8:	df 92       	push	r13
    2dca:	ef 92       	push	r14
    2dcc:	ff 92       	push	r15
    2dce:	0f 93       	push	r16
    2dd0:	1f 93       	push	r17
    2dd2:	cf 93       	push	r28
    2dd4:	df 93       	push	r29
    2dd6:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <uxSchedulerSuspended>
    2dda:	81 11       	cpse	r24, r1
    2ddc:	9a c0       	rjmp	.+308    	; 0x2f12 <xTaskIncrementTick+0x14a>
    2dde:	e0 90 6d 22 	lds	r14, 0x226D	; 0x80226d <xTickCount>
    2de2:	f0 90 6e 22 	lds	r15, 0x226E	; 0x80226e <xTickCount+0x1>
    2de6:	8f ef       	ldi	r24, 0xFF	; 255
    2de8:	e8 1a       	sub	r14, r24
    2dea:	f8 0a       	sbc	r15, r24
    2dec:	e0 92 6d 22 	sts	0x226D, r14	; 0x80226d <xTickCount>
    2df0:	f0 92 6e 22 	sts	0x226E, r15	; 0x80226e <xTickCount+0x1>
    2df4:	e1 14       	cp	r14, r1
    2df6:	f1 04       	cpc	r15, r1
    2df8:	b1 f4       	brne	.+44     	; 0x2e26 <xTaskIncrementTick+0x5e>
    2dfa:	80 91 7b 22 	lds	r24, 0x227B	; 0x80227b <pxDelayedTaskList>
    2dfe:	90 91 7c 22 	lds	r25, 0x227C	; 0x80227c <pxDelayedTaskList+0x1>
    2e02:	20 91 79 22 	lds	r18, 0x2279	; 0x802279 <pxOverflowDelayedTaskList>
    2e06:	30 91 7a 22 	lds	r19, 0x227A	; 0x80227a <pxOverflowDelayedTaskList+0x1>
    2e0a:	20 93 7b 22 	sts	0x227B, r18	; 0x80227b <pxDelayedTaskList>
    2e0e:	30 93 7c 22 	sts	0x227C, r19	; 0x80227c <pxDelayedTaskList+0x1>
    2e12:	80 93 79 22 	sts	0x2279, r24	; 0x802279 <pxOverflowDelayedTaskList>
    2e16:	90 93 7a 22 	sts	0x227A, r25	; 0x80227a <pxOverflowDelayedTaskList+0x1>
    2e1a:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <xNumOfOverflows>
    2e1e:	8f 5f       	subi	r24, 0xFF	; 255
    2e20:	80 93 67 22 	sts	0x2267, r24	; 0x802267 <xNumOfOverflows>
    2e24:	30 de       	rcall	.-928    	; 0x2a86 <prvResetNextTaskUnblockTime>
    2e26:	80 91 64 22 	lds	r24, 0x2264	; 0x802264 <xNextTaskUnblockTime>
    2e2a:	90 91 65 22 	lds	r25, 0x2265	; 0x802265 <xNextTaskUnblockTime+0x1>
    2e2e:	e8 16       	cp	r14, r24
    2e30:	f9 06       	cpc	r15, r25
    2e32:	10 f4       	brcc	.+4      	; 0x2e38 <xTaskIncrementTick+0x70>
    2e34:	d1 2c       	mov	r13, r1
    2e36:	4f c0       	rjmp	.+158    	; 0x2ed6 <xTaskIncrementTick+0x10e>
    2e38:	d1 2c       	mov	r13, r1
    2e3a:	e0 91 7b 22 	lds	r30, 0x227B	; 0x80227b <pxDelayedTaskList>
    2e3e:	f0 91 7c 22 	lds	r31, 0x227C	; 0x80227c <pxDelayedTaskList+0x1>
    2e42:	80 81       	ld	r24, Z
    2e44:	81 11       	cpse	r24, r1
    2e46:	07 c0       	rjmp	.+14     	; 0x2e56 <xTaskIncrementTick+0x8e>
    2e48:	8f ef       	ldi	r24, 0xFF	; 255
    2e4a:	9f ef       	ldi	r25, 0xFF	; 255
    2e4c:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <xNextTaskUnblockTime>
    2e50:	90 93 65 22 	sts	0x2265, r25	; 0x802265 <xNextTaskUnblockTime+0x1>
    2e54:	40 c0       	rjmp	.+128    	; 0x2ed6 <xTaskIncrementTick+0x10e>
    2e56:	e0 91 7b 22 	lds	r30, 0x227B	; 0x80227b <pxDelayedTaskList>
    2e5a:	f0 91 7c 22 	lds	r31, 0x227C	; 0x80227c <pxDelayedTaskList+0x1>
    2e5e:	05 80       	ldd	r0, Z+5	; 0x05
    2e60:	f6 81       	ldd	r31, Z+6	; 0x06
    2e62:	e0 2d       	mov	r30, r0
    2e64:	c6 81       	ldd	r28, Z+6	; 0x06
    2e66:	d7 81       	ldd	r29, Z+7	; 0x07
    2e68:	8a 81       	ldd	r24, Y+2	; 0x02
    2e6a:	9b 81       	ldd	r25, Y+3	; 0x03
    2e6c:	e8 16       	cp	r14, r24
    2e6e:	f9 06       	cpc	r15, r25
    2e70:	28 f4       	brcc	.+10     	; 0x2e7c <xTaskIncrementTick+0xb4>
    2e72:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <xNextTaskUnblockTime>
    2e76:	90 93 65 22 	sts	0x2265, r25	; 0x802265 <xNextTaskUnblockTime+0x1>
    2e7a:	2d c0       	rjmp	.+90     	; 0x2ed6 <xTaskIncrementTick+0x10e>
    2e7c:	8e 01       	movw	r16, r28
    2e7e:	0e 5f       	subi	r16, 0xFE	; 254
    2e80:	1f 4f       	sbci	r17, 0xFF	; 255
    2e82:	c8 01       	movw	r24, r16
    2e84:	d1 d9       	rcall	.-3166   	; 0x2228 <uxListRemove>
    2e86:	8c 89       	ldd	r24, Y+20	; 0x14
    2e88:	9d 89       	ldd	r25, Y+21	; 0x15
    2e8a:	89 2b       	or	r24, r25
    2e8c:	19 f0       	breq	.+6      	; 0x2e94 <xTaskIncrementTick+0xcc>
    2e8e:	ce 01       	movw	r24, r28
    2e90:	0c 96       	adiw	r24, 0x0c	; 12
    2e92:	ca d9       	rcall	.-3180   	; 0x2228 <uxListRemove>
    2e94:	8e 89       	ldd	r24, Y+22	; 0x16
    2e96:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <uxTopReadyPriority>
    2e9a:	98 17       	cp	r25, r24
    2e9c:	10 f4       	brcc	.+4      	; 0x2ea2 <xTaskIncrementTick+0xda>
    2e9e:	80 93 6c 22 	sts	0x226C, r24	; 0x80226c <uxTopReadyPriority>
    2ea2:	90 e0       	ldi	r25, 0x00	; 0
    2ea4:	9c 01       	movw	r18, r24
    2ea6:	22 0f       	add	r18, r18
    2ea8:	33 1f       	adc	r19, r19
    2eaa:	22 0f       	add	r18, r18
    2eac:	33 1f       	adc	r19, r19
    2eae:	22 0f       	add	r18, r18
    2eb0:	33 1f       	adc	r19, r19
    2eb2:	82 0f       	add	r24, r18
    2eb4:	93 1f       	adc	r25, r19
    2eb6:	b8 01       	movw	r22, r16
    2eb8:	81 57       	subi	r24, 0x71	; 113
    2eba:	9d 4d       	sbci	r25, 0xDD	; 221
    2ebc:	63 d9       	rcall	.-3386   	; 0x2184 <vListInsertEnd>
    2ebe:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2ec2:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2ec6:	9e 89       	ldd	r25, Y+22	; 0x16
    2ec8:	86 89       	ldd	r24, Z+22	; 0x16
    2eca:	98 17       	cp	r25, r24
    2ecc:	08 f4       	brcc	.+2      	; 0x2ed0 <xTaskIncrementTick+0x108>
    2ece:	b5 cf       	rjmp	.-150    	; 0x2e3a <xTaskIncrementTick+0x72>
    2ed0:	dd 24       	eor	r13, r13
    2ed2:	d3 94       	inc	r13
    2ed4:	b2 cf       	rjmp	.-156    	; 0x2e3a <xTaskIncrementTick+0x72>
    2ed6:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2eda:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2ede:	86 89       	ldd	r24, Z+22	; 0x16
    2ee0:	90 e0       	ldi	r25, 0x00	; 0
    2ee2:	fc 01       	movw	r30, r24
    2ee4:	ee 0f       	add	r30, r30
    2ee6:	ff 1f       	adc	r31, r31
    2ee8:	ee 0f       	add	r30, r30
    2eea:	ff 1f       	adc	r31, r31
    2eec:	ee 0f       	add	r30, r30
    2eee:	ff 1f       	adc	r31, r31
    2ef0:	8e 0f       	add	r24, r30
    2ef2:	9f 1f       	adc	r25, r31
    2ef4:	fc 01       	movw	r30, r24
    2ef6:	e1 57       	subi	r30, 0x71	; 113
    2ef8:	fd 4d       	sbci	r31, 0xDD	; 221
    2efa:	80 81       	ld	r24, Z
    2efc:	82 30       	cpi	r24, 0x02	; 2
    2efe:	10 f0       	brcs	.+4      	; 0x2f04 <xTaskIncrementTick+0x13c>
    2f00:	dd 24       	eor	r13, r13
    2f02:	d3 94       	inc	r13
    2f04:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <xYieldPending>
    2f08:	88 23       	and	r24, r24
    2f0a:	69 f0       	breq	.+26     	; 0x2f26 <xTaskIncrementTick+0x15e>
    2f0c:	dd 24       	eor	r13, r13
    2f0e:	d3 94       	inc	r13
    2f10:	0a c0       	rjmp	.+20     	; 0x2f26 <xTaskIncrementTick+0x15e>
    2f12:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xPendedTicks>
    2f16:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <xPendedTicks+0x1>
    2f1a:	01 96       	adiw	r24, 0x01	; 1
    2f1c:	80 93 69 22 	sts	0x2269, r24	; 0x802269 <xPendedTicks>
    2f20:	90 93 6a 22 	sts	0x226A, r25	; 0x80226a <xPendedTicks+0x1>
    2f24:	d1 2c       	mov	r13, r1
    2f26:	8d 2d       	mov	r24, r13
    2f28:	df 91       	pop	r29
    2f2a:	cf 91       	pop	r28
    2f2c:	1f 91       	pop	r17
    2f2e:	0f 91       	pop	r16
    2f30:	ff 90       	pop	r15
    2f32:	ef 90       	pop	r14
    2f34:	df 90       	pop	r13
    2f36:	08 95       	ret

00002f38 <xTaskResumeAll>:
    2f38:	df 92       	push	r13
    2f3a:	ef 92       	push	r14
    2f3c:	ff 92       	push	r15
    2f3e:	0f 93       	push	r16
    2f40:	1f 93       	push	r17
    2f42:	cf 93       	push	r28
    2f44:	df 93       	push	r29
    2f46:	0f b6       	in	r0, 0x3f	; 63
    2f48:	f8 94       	cli
    2f4a:	0f 92       	push	r0
    2f4c:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <uxSchedulerSuspended>
    2f50:	81 50       	subi	r24, 0x01	; 1
    2f52:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <uxSchedulerSuspended>
    2f56:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <uxSchedulerSuspended>
    2f5a:	81 11       	cpse	r24, r1
    2f5c:	5d c0       	rjmp	.+186    	; 0x3018 <xTaskResumeAll+0xe0>
    2f5e:	80 91 6f 22 	lds	r24, 0x226F	; 0x80226f <uxCurrentNumberOfTasks>
    2f62:	81 11       	cpse	r24, r1
    2f64:	30 c0       	rjmp	.+96     	; 0x2fc6 <xTaskResumeAll+0x8e>
    2f66:	5b c0       	rjmp	.+182    	; 0x301e <xTaskResumeAll+0xe6>
    2f68:	d7 01       	movw	r26, r14
    2f6a:	15 96       	adiw	r26, 0x05	; 5
    2f6c:	ed 91       	ld	r30, X+
    2f6e:	fc 91       	ld	r31, X
    2f70:	16 97       	sbiw	r26, 0x06	; 6
    2f72:	c6 81       	ldd	r28, Z+6	; 0x06
    2f74:	d7 81       	ldd	r29, Z+7	; 0x07
    2f76:	ce 01       	movw	r24, r28
    2f78:	0c 96       	adiw	r24, 0x0c	; 12
    2f7a:	56 d9       	rcall	.-3412   	; 0x2228 <uxListRemove>
    2f7c:	8e 01       	movw	r16, r28
    2f7e:	0e 5f       	subi	r16, 0xFE	; 254
    2f80:	1f 4f       	sbci	r17, 0xFF	; 255
    2f82:	c8 01       	movw	r24, r16
    2f84:	51 d9       	rcall	.-3422   	; 0x2228 <uxListRemove>
    2f86:	8e 89       	ldd	r24, Y+22	; 0x16
    2f88:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <uxTopReadyPriority>
    2f8c:	98 17       	cp	r25, r24
    2f8e:	10 f4       	brcc	.+4      	; 0x2f94 <xTaskResumeAll+0x5c>
    2f90:	80 93 6c 22 	sts	0x226C, r24	; 0x80226c <uxTopReadyPriority>
    2f94:	90 e0       	ldi	r25, 0x00	; 0
    2f96:	9c 01       	movw	r18, r24
    2f98:	22 0f       	add	r18, r18
    2f9a:	33 1f       	adc	r19, r19
    2f9c:	22 0f       	add	r18, r18
    2f9e:	33 1f       	adc	r19, r19
    2fa0:	22 0f       	add	r18, r18
    2fa2:	33 1f       	adc	r19, r19
    2fa4:	82 0f       	add	r24, r18
    2fa6:	93 1f       	adc	r25, r19
    2fa8:	b8 01       	movw	r22, r16
    2faa:	81 57       	subi	r24, 0x71	; 113
    2fac:	9d 4d       	sbci	r25, 0xDD	; 221
    2fae:	ea d8       	rcall	.-3628   	; 0x2184 <vListInsertEnd>
    2fb0:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <pxCurrentTCB>
    2fb4:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    2fb8:	9e 89       	ldd	r25, Y+22	; 0x16
    2fba:	86 89       	ldd	r24, Z+22	; 0x16
    2fbc:	98 17       	cp	r25, r24
    2fbe:	68 f0       	brcs	.+26     	; 0x2fda <xTaskResumeAll+0xa2>
    2fc0:	d0 92 68 22 	sts	0x2268, r13	; 0x802268 <xYieldPending>
    2fc4:	0a c0       	rjmp	.+20     	; 0x2fda <xTaskResumeAll+0xa2>
    2fc6:	c0 e0       	ldi	r28, 0x00	; 0
    2fc8:	d0 e0       	ldi	r29, 0x00	; 0
    2fca:	0f 2e       	mov	r0, r31
    2fcc:	f0 e7       	ldi	r31, 0x70	; 112
    2fce:	ef 2e       	mov	r14, r31
    2fd0:	f2 e2       	ldi	r31, 0x22	; 34
    2fd2:	ff 2e       	mov	r15, r31
    2fd4:	f0 2d       	mov	r31, r0
    2fd6:	dd 24       	eor	r13, r13
    2fd8:	d3 94       	inc	r13
    2fda:	f7 01       	movw	r30, r14
    2fdc:	80 81       	ld	r24, Z
    2fde:	81 11       	cpse	r24, r1
    2fe0:	c3 cf       	rjmp	.-122    	; 0x2f68 <xTaskResumeAll+0x30>
    2fe2:	cd 2b       	or	r28, r29
    2fe4:	09 f0       	breq	.+2      	; 0x2fe8 <xTaskResumeAll+0xb0>
    2fe6:	4f dd       	rcall	.-1378   	; 0x2a86 <prvResetNextTaskUnblockTime>
    2fe8:	c0 91 69 22 	lds	r28, 0x2269	; 0x802269 <xPendedTicks>
    2fec:	d0 91 6a 22 	lds	r29, 0x226A	; 0x80226a <xPendedTicks+0x1>
    2ff0:	20 97       	sbiw	r28, 0x00	; 0
    2ff2:	59 f0       	breq	.+22     	; 0x300a <xTaskResumeAll+0xd2>
    2ff4:	11 e0       	ldi	r17, 0x01	; 1
    2ff6:	e8 de       	rcall	.-560    	; 0x2dc8 <xTaskIncrementTick>
    2ff8:	81 11       	cpse	r24, r1
    2ffa:	10 93 68 22 	sts	0x2268, r17	; 0x802268 <xYieldPending>
    2ffe:	21 97       	sbiw	r28, 0x01	; 1
    3000:	d1 f7       	brne	.-12     	; 0x2ff6 <xTaskResumeAll+0xbe>
    3002:	10 92 69 22 	sts	0x2269, r1	; 0x802269 <xPendedTicks>
    3006:	10 92 6a 22 	sts	0x226A, r1	; 0x80226a <xPendedTicks+0x1>
    300a:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <xYieldPending>
    300e:	88 23       	and	r24, r24
    3010:	29 f0       	breq	.+10     	; 0x301c <xTaskResumeAll+0xe4>
    3012:	ed d9       	rcall	.-3110   	; 0x23ee <vPortYield>
    3014:	81 e0       	ldi	r24, 0x01	; 1
    3016:	03 c0       	rjmp	.+6      	; 0x301e <xTaskResumeAll+0xe6>
    3018:	80 e0       	ldi	r24, 0x00	; 0
    301a:	01 c0       	rjmp	.+2      	; 0x301e <xTaskResumeAll+0xe6>
    301c:	80 e0       	ldi	r24, 0x00	; 0
    301e:	0f 90       	pop	r0
    3020:	0f be       	out	0x3f, r0	; 63
    3022:	df 91       	pop	r29
    3024:	cf 91       	pop	r28
    3026:	1f 91       	pop	r17
    3028:	0f 91       	pop	r16
    302a:	ff 90       	pop	r15
    302c:	ef 90       	pop	r14
    302e:	df 90       	pop	r13
    3030:	08 95       	ret

00003032 <vTaskSwitchContext>:
    3032:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <uxSchedulerSuspended>
    3036:	88 23       	and	r24, r24
    3038:	21 f0       	breq	.+8      	; 0x3042 <vTaskSwitchContext+0x10>
    303a:	81 e0       	ldi	r24, 0x01	; 1
    303c:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <xYieldPending>
    3040:	08 95       	ret
    3042:	10 92 68 22 	sts	0x2268, r1	; 0x802268 <xYieldPending>
    3046:	20 91 6c 22 	lds	r18, 0x226C	; 0x80226c <uxTopReadyPriority>
    304a:	82 2f       	mov	r24, r18
    304c:	90 e0       	ldi	r25, 0x00	; 0
    304e:	fc 01       	movw	r30, r24
    3050:	ee 0f       	add	r30, r30
    3052:	ff 1f       	adc	r31, r31
    3054:	ee 0f       	add	r30, r30
    3056:	ff 1f       	adc	r31, r31
    3058:	ee 0f       	add	r30, r30
    305a:	ff 1f       	adc	r31, r31
    305c:	e8 0f       	add	r30, r24
    305e:	f9 1f       	adc	r31, r25
    3060:	e1 57       	subi	r30, 0x71	; 113
    3062:	fd 4d       	sbci	r31, 0xDD	; 221
    3064:	30 81       	ld	r19, Z
    3066:	31 11       	cpse	r19, r1
    3068:	11 c0       	rjmp	.+34     	; 0x308c <vTaskSwitchContext+0x5a>
    306a:	21 50       	subi	r18, 0x01	; 1
    306c:	82 2f       	mov	r24, r18
    306e:	90 e0       	ldi	r25, 0x00	; 0
    3070:	fc 01       	movw	r30, r24
    3072:	ee 0f       	add	r30, r30
    3074:	ff 1f       	adc	r31, r31
    3076:	ee 0f       	add	r30, r30
    3078:	ff 1f       	adc	r31, r31
    307a:	ee 0f       	add	r30, r30
    307c:	ff 1f       	adc	r31, r31
    307e:	e8 0f       	add	r30, r24
    3080:	f9 1f       	adc	r31, r25
    3082:	e1 57       	subi	r30, 0x71	; 113
    3084:	fd 4d       	sbci	r31, 0xDD	; 221
    3086:	30 81       	ld	r19, Z
    3088:	33 23       	and	r19, r19
    308a:	79 f3       	breq	.-34     	; 0x306a <vTaskSwitchContext+0x38>
    308c:	ac 01       	movw	r20, r24
    308e:	44 0f       	add	r20, r20
    3090:	55 1f       	adc	r21, r21
    3092:	44 0f       	add	r20, r20
    3094:	55 1f       	adc	r21, r21
    3096:	44 0f       	add	r20, r20
    3098:	55 1f       	adc	r21, r21
    309a:	48 0f       	add	r20, r24
    309c:	59 1f       	adc	r21, r25
    309e:	da 01       	movw	r26, r20
    30a0:	a1 57       	subi	r26, 0x71	; 113
    30a2:	bd 4d       	sbci	r27, 0xDD	; 221
    30a4:	11 96       	adiw	r26, 0x01	; 1
    30a6:	ed 91       	ld	r30, X+
    30a8:	fc 91       	ld	r31, X
    30aa:	12 97       	sbiw	r26, 0x02	; 2
    30ac:	02 80       	ldd	r0, Z+2	; 0x02
    30ae:	f3 81       	ldd	r31, Z+3	; 0x03
    30b0:	e0 2d       	mov	r30, r0
    30b2:	11 96       	adiw	r26, 0x01	; 1
    30b4:	ed 93       	st	X+, r30
    30b6:	fc 93       	st	X, r31
    30b8:	12 97       	sbiw	r26, 0x02	; 2
    30ba:	4e 56       	subi	r20, 0x6E	; 110
    30bc:	5d 4d       	sbci	r21, 0xDD	; 221
    30be:	e4 17       	cp	r30, r20
    30c0:	f5 07       	cpc	r31, r21
    30c2:	29 f4       	brne	.+10     	; 0x30ce <vTaskSwitchContext+0x9c>
    30c4:	42 81       	ldd	r20, Z+2	; 0x02
    30c6:	53 81       	ldd	r21, Z+3	; 0x03
    30c8:	fd 01       	movw	r30, r26
    30ca:	41 83       	std	Z+1, r20	; 0x01
    30cc:	52 83       	std	Z+2, r21	; 0x02
    30ce:	fc 01       	movw	r30, r24
    30d0:	ee 0f       	add	r30, r30
    30d2:	ff 1f       	adc	r31, r31
    30d4:	ee 0f       	add	r30, r30
    30d6:	ff 1f       	adc	r31, r31
    30d8:	ee 0f       	add	r30, r30
    30da:	ff 1f       	adc	r31, r31
    30dc:	8e 0f       	add	r24, r30
    30de:	9f 1f       	adc	r25, r31
    30e0:	fc 01       	movw	r30, r24
    30e2:	e1 57       	subi	r30, 0x71	; 113
    30e4:	fd 4d       	sbci	r31, 0xDD	; 221
    30e6:	01 80       	ldd	r0, Z+1	; 0x01
    30e8:	f2 81       	ldd	r31, Z+2	; 0x02
    30ea:	e0 2d       	mov	r30, r0
    30ec:	86 81       	ldd	r24, Z+6	; 0x06
    30ee:	97 81       	ldd	r25, Z+7	; 0x07
    30f0:	80 93 bc 22 	sts	0x22BC, r24	; 0x8022bc <pxCurrentTCB>
    30f4:	90 93 bd 22 	sts	0x22BD, r25	; 0x8022bd <pxCurrentTCB+0x1>
    30f8:	20 93 6c 22 	sts	0x226C, r18	; 0x80226c <uxTopReadyPriority>
    30fc:	08 95       	ret

000030fe <vTaskPlaceOnEventList>:
    30fe:	cf 93       	push	r28
    3100:	df 93       	push	r29
    3102:	eb 01       	movw	r28, r22
    3104:	60 91 bc 22 	lds	r22, 0x22BC	; 0x8022bc <pxCurrentTCB>
    3108:	70 91 bd 22 	lds	r23, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    310c:	64 5f       	subi	r22, 0xF4	; 244
    310e:	7f 4f       	sbci	r23, 0xFF	; 255
    3110:	5a d8       	rcall	.-3916   	; 0x21c6 <vListInsert>
    3112:	61 e0       	ldi	r22, 0x01	; 1
    3114:	ce 01       	movw	r24, r28
    3116:	dd dc       	rcall	.-1606   	; 0x2ad2 <prvAddCurrentTaskToDelayedList>
    3118:	df 91       	pop	r29
    311a:	cf 91       	pop	r28
    311c:	08 95       	ret

0000311e <vTaskPlaceOnEventListRestricted>:
    311e:	0f 93       	push	r16
    3120:	1f 93       	push	r17
    3122:	cf 93       	push	r28
    3124:	8b 01       	movw	r16, r22
    3126:	c4 2f       	mov	r28, r20
    3128:	60 91 bc 22 	lds	r22, 0x22BC	; 0x8022bc <pxCurrentTCB>
    312c:	70 91 bd 22 	lds	r23, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    3130:	64 5f       	subi	r22, 0xF4	; 244
    3132:	7f 4f       	sbci	r23, 0xFF	; 255
    3134:	27 d8       	rcall	.-4018   	; 0x2184 <vListInsertEnd>
    3136:	cc 23       	and	r28, r28
    3138:	11 f0       	breq	.+4      	; 0x313e <vTaskPlaceOnEventListRestricted+0x20>
    313a:	0f ef       	ldi	r16, 0xFF	; 255
    313c:	1f ef       	ldi	r17, 0xFF	; 255
    313e:	6c 2f       	mov	r22, r28
    3140:	c8 01       	movw	r24, r16
    3142:	c7 dc       	rcall	.-1650   	; 0x2ad2 <prvAddCurrentTaskToDelayedList>
    3144:	cf 91       	pop	r28
    3146:	1f 91       	pop	r17
    3148:	0f 91       	pop	r16
    314a:	08 95       	ret

0000314c <xTaskRemoveFromEventList>:
    314c:	0f 93       	push	r16
    314e:	1f 93       	push	r17
    3150:	cf 93       	push	r28
    3152:	df 93       	push	r29
    3154:	dc 01       	movw	r26, r24
    3156:	15 96       	adiw	r26, 0x05	; 5
    3158:	ed 91       	ld	r30, X+
    315a:	fc 91       	ld	r31, X
    315c:	16 97       	sbiw	r26, 0x06	; 6
    315e:	c6 81       	ldd	r28, Z+6	; 0x06
    3160:	d7 81       	ldd	r29, Z+7	; 0x07
    3162:	8e 01       	movw	r16, r28
    3164:	04 5f       	subi	r16, 0xF4	; 244
    3166:	1f 4f       	sbci	r17, 0xFF	; 255
    3168:	c8 01       	movw	r24, r16
    316a:	5e d8       	rcall	.-3908   	; 0x2228 <uxListRemove>
    316c:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <uxSchedulerSuspended>
    3170:	81 11       	cpse	r24, r1
    3172:	1b c0       	rjmp	.+54     	; 0x31aa <xTaskRemoveFromEventList+0x5e>
    3174:	0a 50       	subi	r16, 0x0A	; 10
    3176:	11 09       	sbc	r17, r1
    3178:	c8 01       	movw	r24, r16
    317a:	56 d8       	rcall	.-3924   	; 0x2228 <uxListRemove>
    317c:	8e 89       	ldd	r24, Y+22	; 0x16
    317e:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <uxTopReadyPriority>
    3182:	98 17       	cp	r25, r24
    3184:	10 f4       	brcc	.+4      	; 0x318a <xTaskRemoveFromEventList+0x3e>
    3186:	80 93 6c 22 	sts	0x226C, r24	; 0x80226c <uxTopReadyPriority>
    318a:	90 e0       	ldi	r25, 0x00	; 0
    318c:	9c 01       	movw	r18, r24
    318e:	22 0f       	add	r18, r18
    3190:	33 1f       	adc	r19, r19
    3192:	22 0f       	add	r18, r18
    3194:	33 1f       	adc	r19, r19
    3196:	22 0f       	add	r18, r18
    3198:	33 1f       	adc	r19, r19
    319a:	82 0f       	add	r24, r18
    319c:	93 1f       	adc	r25, r19
    319e:	b8 01       	movw	r22, r16
    31a0:	81 57       	subi	r24, 0x71	; 113
    31a2:	9d 4d       	sbci	r25, 0xDD	; 221
    31a4:	0e 94 c2 10 	call	0x2184	; 0x2184 <vListInsertEnd>
    31a8:	05 c0       	rjmp	.+10     	; 0x31b4 <xTaskRemoveFromEventList+0x68>
    31aa:	b8 01       	movw	r22, r16
    31ac:	80 e7       	ldi	r24, 0x70	; 112
    31ae:	92 e2       	ldi	r25, 0x22	; 34
    31b0:	0e 94 c2 10 	call	0x2184	; 0x2184 <vListInsertEnd>
    31b4:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <pxCurrentTCB>
    31b8:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <pxCurrentTCB+0x1>
    31bc:	9e 89       	ldd	r25, Y+22	; 0x16
    31be:	86 89       	ldd	r24, Z+22	; 0x16
    31c0:	89 17       	cp	r24, r25
    31c2:	20 f4       	brcc	.+8      	; 0x31cc <xTaskRemoveFromEventList+0x80>
    31c4:	81 e0       	ldi	r24, 0x01	; 1
    31c6:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <xYieldPending>
    31ca:	01 c0       	rjmp	.+2      	; 0x31ce <xTaskRemoveFromEventList+0x82>
    31cc:	80 e0       	ldi	r24, 0x00	; 0
    31ce:	df 91       	pop	r29
    31d0:	cf 91       	pop	r28
    31d2:	1f 91       	pop	r17
    31d4:	0f 91       	pop	r16
    31d6:	08 95       	ret

000031d8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    31d8:	20 91 67 22 	lds	r18, 0x2267	; 0x802267 <xNumOfOverflows>
    31dc:	fc 01       	movw	r30, r24
    31de:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    31e0:	20 91 6d 22 	lds	r18, 0x226D	; 0x80226d <xTickCount>
    31e4:	30 91 6e 22 	lds	r19, 0x226E	; 0x80226e <xTickCount+0x1>
    31e8:	21 83       	std	Z+1, r18	; 0x01
    31ea:	32 83       	std	Z+2, r19	; 0x02
    31ec:	08 95       	ret

000031ee <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    31ee:	0f b6       	in	r0, 0x3f	; 63
    31f0:	f8 94       	cli
    31f2:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    31f4:	20 91 6d 22 	lds	r18, 0x226D	; 0x80226d <xTickCount>
    31f8:	30 91 6e 22 	lds	r19, 0x226E	; 0x80226e <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    31fc:	dc 01       	movw	r26, r24
    31fe:	11 96       	adiw	r26, 0x01	; 1
    3200:	4d 91       	ld	r20, X+
    3202:	5c 91       	ld	r21, X
    3204:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3206:	e0 91 67 22 	lds	r30, 0x2267	; 0x802267 <xNumOfOverflows>
    320a:	fc 91       	ld	r31, X
    320c:	fe 17       	cp	r31, r30
    320e:	19 f0       	breq	.+6      	; 0x3216 <xTaskCheckForTimeOut+0x28>
    3210:	24 17       	cp	r18, r20
    3212:	35 07       	cpc	r19, r21
    3214:	98 f4       	brcc	.+38     	; 0x323c <xTaskCheckForTimeOut+0x4e>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3216:	24 1b       	sub	r18, r20
    3218:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    321a:	fb 01       	movw	r30, r22
    321c:	40 81       	ld	r20, Z
    321e:	51 81       	ldd	r21, Z+1	; 0x01
    3220:	24 17       	cp	r18, r20
    3222:	35 07       	cpc	r19, r21
    3224:	38 f4       	brcc	.+14     	; 0x3234 <xTaskCheckForTimeOut+0x46>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3226:	42 1b       	sub	r20, r18
    3228:	53 0b       	sbc	r21, r19
    322a:	40 83       	st	Z, r20
    322c:	51 83       	std	Z+1, r21	; 0x01
			vTaskInternalSetTimeOutState( pxTimeOut );
    322e:	d4 df       	rcall	.-88     	; 0x31d8 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3230:	80 e0       	ldi	r24, 0x00	; 0
    3232:	05 c0       	rjmp	.+10     	; 0x323e <xTaskCheckForTimeOut+0x50>
		}
		else
		{
			*pxTicksToWait = 0;
    3234:	10 82       	st	Z, r1
    3236:	11 82       	std	Z+1, r1	; 0x01
			xReturn = pdTRUE;
    3238:	81 e0       	ldi	r24, 0x01	; 1
    323a:	01 c0       	rjmp	.+2      	; 0x323e <xTaskCheckForTimeOut+0x50>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    323c:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    323e:	0f 90       	pop	r0
    3240:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3242:	08 95       	ret

00003244 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    3244:	81 e0       	ldi	r24, 0x01	; 1
    3246:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <xYieldPending>
    324a:	08 95       	ret

0000324c <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    324c:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <xSchedulerRunning>
    3250:	88 23       	and	r24, r24
    3252:	31 f0       	breq	.+12     	; 0x3260 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3254:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <uxSchedulerSuspended>
    3258:	88 23       	and	r24, r24
    325a:	21 f0       	breq	.+8      	; 0x3264 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    325c:	80 e0       	ldi	r24, 0x00	; 0
    325e:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    3260:	81 e0       	ldi	r24, 0x01	; 1
    3262:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    3264:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    3266:	08 95       	ret

00003268 <prvInsertTimerInActiveList>:
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    3268:	fc 01       	movw	r30, r24
    326a:	62 83       	std	Z+2, r22	; 0x02
    326c:	73 83       	std	Z+3, r23	; 0x03
    326e:	80 87       	std	Z+8, r24	; 0x08
    3270:	91 87       	std	Z+9, r25	; 0x09
    3272:	46 17       	cp	r20, r22
    3274:	57 07       	cpc	r21, r23
    3276:	90 f0       	brcs	.+36     	; 0x329c <prvInsertTimerInActiveList+0x34>
    3278:	42 1b       	sub	r20, r18
    327a:	53 0b       	sbc	r21, r19
    327c:	84 85       	ldd	r24, Z+12	; 0x0c
    327e:	95 85       	ldd	r25, Z+13	; 0x0d
    3280:	48 17       	cp	r20, r24
    3282:	59 07       	cpc	r21, r25
    3284:	e0 f4       	brcc	.+56     	; 0x32be <prvInsertTimerInActiveList+0x56>
    3286:	bf 01       	movw	r22, r30
    3288:	6e 5f       	subi	r22, 0xFE	; 254
    328a:	7f 4f       	sbci	r23, 0xFF	; 255
    328c:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <pxOverflowTimerList>
    3290:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <pxOverflowTimerList+0x1>
    3294:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <vListInsert>
    3298:	80 e0       	ldi	r24, 0x00	; 0
    329a:	08 95       	ret
    329c:	42 17       	cp	r20, r18
    329e:	53 07       	cpc	r21, r19
    32a0:	18 f4       	brcc	.+6      	; 0x32a8 <prvInsertTimerInActiveList+0x40>
    32a2:	62 17       	cp	r22, r18
    32a4:	73 07       	cpc	r23, r19
    32a6:	68 f4       	brcc	.+26     	; 0x32c2 <prvInsertTimerInActiveList+0x5a>
    32a8:	bf 01       	movw	r22, r30
    32aa:	6e 5f       	subi	r22, 0xFE	; 254
    32ac:	7f 4f       	sbci	r23, 0xFF	; 255
    32ae:	80 91 c6 22 	lds	r24, 0x22C6	; 0x8022c6 <pxCurrentTimerList>
    32b2:	90 91 c7 22 	lds	r25, 0x22C7	; 0x8022c7 <pxCurrentTimerList+0x1>
    32b6:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <vListInsert>
    32ba:	80 e0       	ldi	r24, 0x00	; 0
    32bc:	08 95       	ret
    32be:	81 e0       	ldi	r24, 0x01	; 1
    32c0:	08 95       	ret
    32c2:	81 e0       	ldi	r24, 0x01	; 1
    32c4:	08 95       	ret

000032c6 <prvCheckForValidListAndQueue>:
    32c6:	0f b6       	in	r0, 0x3f	; 63
    32c8:	f8 94       	cli
    32ca:	0f 92       	push	r0
    32cc:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <xTimerQueue>
    32d0:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <xTimerQueue+0x1>
    32d4:	89 2b       	or	r24, r25
    32d6:	e1 f4       	brne	.+56     	; 0x3310 <prvCheckForValidListAndQueue+0x4a>
    32d8:	81 ed       	ldi	r24, 0xD1	; 209
    32da:	92 e2       	ldi	r25, 0x22	; 34
    32dc:	0e 94 b0 10 	call	0x2160	; 0x2160 <vListInitialise>
    32e0:	88 ec       	ldi	r24, 0xC8	; 200
    32e2:	92 e2       	ldi	r25, 0x22	; 34
    32e4:	0e 94 b0 10 	call	0x2160	; 0x2160 <vListInitialise>
    32e8:	81 ed       	ldi	r24, 0xD1	; 209
    32ea:	92 e2       	ldi	r25, 0x22	; 34
    32ec:	80 93 c6 22 	sts	0x22C6, r24	; 0x8022c6 <pxCurrentTimerList>
    32f0:	90 93 c7 22 	sts	0x22C7, r25	; 0x8022c7 <pxCurrentTimerList+0x1>
    32f4:	88 ec       	ldi	r24, 0xC8	; 200
    32f6:	92 e2       	ldi	r25, 0x22	; 34
    32f8:	80 93 c4 22 	sts	0x22C4, r24	; 0x8022c4 <pxOverflowTimerList>
    32fc:	90 93 c5 22 	sts	0x22C5, r25	; 0x8022c5 <pxOverflowTimerList+0x1>
    3300:	40 e0       	ldi	r20, 0x00	; 0
    3302:	65 e0       	ldi	r22, 0x05	; 5
    3304:	8a e0       	ldi	r24, 0x0A	; 10
    3306:	38 da       	rcall	.-2960   	; 0x2778 <xQueueGenericCreate>
    3308:	80 93 c2 22 	sts	0x22C2, r24	; 0x8022c2 <xTimerQueue>
    330c:	90 93 c3 22 	sts	0x22C3, r25	; 0x8022c3 <xTimerQueue+0x1>
    3310:	0f 90       	pop	r0
    3312:	0f be       	out	0x3f, r0	; 63
    3314:	08 95       	ret

00003316 <xTimerCreateTimerTask>:
    3316:	ef 92       	push	r14
    3318:	ff 92       	push	r15
    331a:	0f 93       	push	r16
    331c:	d4 df       	rcall	.-88     	; 0x32c6 <prvCheckForValidListAndQueue>
    331e:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <xTimerQueue>
    3322:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <xTimerQueue+0x1>
    3326:	89 2b       	or	r24, r25
    3328:	89 f0       	breq	.+34     	; 0x334c <xTimerCreateTimerTask+0x36>
    332a:	0f 2e       	mov	r0, r31
    332c:	f0 ec       	ldi	r31, 0xC0	; 192
    332e:	ef 2e       	mov	r14, r31
    3330:	f2 e2       	ldi	r31, 0x22	; 34
    3332:	ff 2e       	mov	r15, r31
    3334:	f0 2d       	mov	r31, r0
    3336:	03 e0       	ldi	r16, 0x03	; 3
    3338:	20 e0       	ldi	r18, 0x00	; 0
    333a:	30 e0       	ldi	r19, 0x00	; 0
    333c:	45 e5       	ldi	r20, 0x55	; 85
    333e:	50 e0       	ldi	r21, 0x00	; 0
    3340:	69 e1       	ldi	r22, 0x19	; 25
    3342:	70 e2       	ldi	r23, 0x20	; 32
    3344:	8b e5       	ldi	r24, 0x5B	; 91
    3346:	9a e1       	ldi	r25, 0x1A	; 26
    3348:	05 dc       	rcall	.-2038   	; 0x2b54 <xTaskCreate>
    334a:	01 c0       	rjmp	.+2      	; 0x334e <xTimerCreateTimerTask+0x38>
    334c:	80 e0       	ldi	r24, 0x00	; 0
    334e:	0f 91       	pop	r16
    3350:	ff 90       	pop	r15
    3352:	ef 90       	pop	r14
    3354:	08 95       	ret

00003356 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3356:	0f 93       	push	r16
    3358:	1f 93       	push	r17
    335a:	cf 93       	push	r28
    335c:	df 93       	push	r29
    335e:	cd b7       	in	r28, 0x3d	; 61
    3360:	de b7       	in	r29, 0x3e	; 62
    3362:	25 97       	sbiw	r28, 0x05	; 5
    3364:	cd bf       	out	0x3d, r28	; 61
    3366:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    3368:	e0 91 c2 22 	lds	r30, 0x22C2	; 0x8022c2 <xTimerQueue>
    336c:	f0 91 c3 22 	lds	r31, 0x22C3	; 0x8022c3 <xTimerQueue+0x1>
    3370:	30 97       	sbiw	r30, 0x00	; 0
    3372:	51 f1       	breq	.+84     	; 0x33c8 <xTimerGenericCommand+0x72>
    3374:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    3376:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3378:	4a 83       	std	Y+2, r20	; 0x02
    337a:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    337c:	8c 83       	std	Y+4, r24	; 0x04
    337e:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3380:	66 30       	cpi	r22, 0x06	; 6
    3382:	d4 f4       	brge	.+52     	; 0x33b8 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3384:	63 df       	rcall	.-314    	; 0x324c <xTaskGetSchedulerState>
    3386:	82 30       	cpi	r24, 0x02	; 2
    3388:	59 f4       	brne	.+22     	; 0x33a0 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    338a:	20 e0       	ldi	r18, 0x00	; 0
    338c:	a8 01       	movw	r20, r16
    338e:	be 01       	movw	r22, r28
    3390:	6f 5f       	subi	r22, 0xFF	; 255
    3392:	7f 4f       	sbci	r23, 0xFF	; 255
    3394:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <xTimerQueue>
    3398:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <xTimerQueue+0x1>
    339c:	0e da       	rcall	.-3044   	; 0x27ba <xQueueGenericSend>
    339e:	15 c0       	rjmp	.+42     	; 0x33ca <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    33a0:	20 e0       	ldi	r18, 0x00	; 0
    33a2:	40 e0       	ldi	r20, 0x00	; 0
    33a4:	50 e0       	ldi	r21, 0x00	; 0
    33a6:	be 01       	movw	r22, r28
    33a8:	6f 5f       	subi	r22, 0xFF	; 255
    33aa:	7f 4f       	sbci	r23, 0xFF	; 255
    33ac:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <xTimerQueue>
    33b0:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <xTimerQueue+0x1>
    33b4:	02 da       	rcall	.-3068   	; 0x27ba <xQueueGenericSend>
    33b6:	09 c0       	rjmp	.+18     	; 0x33ca <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    33b8:	20 e0       	ldi	r18, 0x00	; 0
    33ba:	ad 01       	movw	r20, r26
    33bc:	be 01       	movw	r22, r28
    33be:	6f 5f       	subi	r22, 0xFF	; 255
    33c0:	7f 4f       	sbci	r23, 0xFF	; 255
    33c2:	cf 01       	movw	r24, r30
    33c4:	87 da       	rcall	.-2802   	; 0x28d4 <xQueueGenericSendFromISR>
    33c6:	01 c0       	rjmp	.+2      	; 0x33ca <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    33c8:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    33ca:	25 96       	adiw	r28, 0x05	; 5
    33cc:	cd bf       	out	0x3d, r28	; 61
    33ce:	de bf       	out	0x3e, r29	; 62
    33d0:	df 91       	pop	r29
    33d2:	cf 91       	pop	r28
    33d4:	1f 91       	pop	r17
    33d6:	0f 91       	pop	r16
    33d8:	08 95       	ret

000033da <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    33da:	af 92       	push	r10
    33dc:	bf 92       	push	r11
    33de:	cf 92       	push	r12
    33e0:	df 92       	push	r13
    33e2:	ef 92       	push	r14
    33e4:	ff 92       	push	r15
    33e6:	0f 93       	push	r16
    33e8:	1f 93       	push	r17
    33ea:	cf 93       	push	r28
    33ec:	df 93       	push	r29
    33ee:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    33f0:	e1 dc       	rcall	.-1598   	; 0x2db4 <xTaskGetTickCount>
    33f2:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    33f4:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <xLastTime.4598>
    33f8:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <xLastTime.4598+0x1>
    33fc:	e8 16       	cp	r14, r24
    33fe:	f9 06       	cpc	r15, r25
    3400:	08 f0       	brcs	.+2      	; 0x3404 <prvSampleTimeNow+0x2a>
    3402:	47 c0       	rjmp	.+142    	; 0x3492 <prvSampleTimeNow+0xb8>
    3404:	2f c0       	rjmp	.+94     	; 0x3464 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3406:	05 80       	ldd	r0, Z+5	; 0x05
    3408:	f6 81       	ldd	r31, Z+6	; 0x06
    340a:	e0 2d       	mov	r30, r0
    340c:	a0 80       	ld	r10, Z
    340e:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3410:	c6 81       	ldd	r28, Z+6	; 0x06
    3412:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3414:	8e 01       	movw	r16, r28
    3416:	0e 5f       	subi	r16, 0xFE	; 254
    3418:	1f 4f       	sbci	r17, 0xFF	; 255
    341a:	c8 01       	movw	r24, r16
    341c:	0e 94 14 11 	call	0x2228	; 0x2228 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3420:	e8 89       	ldd	r30, Y+16	; 0x10
    3422:	f9 89       	ldd	r31, Y+17	; 0x11
    3424:	ce 01       	movw	r24, r28
    3426:	19 95       	eicall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3428:	8a 89       	ldd	r24, Y+18	; 0x12
    342a:	82 ff       	sbrs	r24, 2
    342c:	1b c0       	rjmp	.+54     	; 0x3464 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    342e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3430:	9d 85       	ldd	r25, Y+13	; 0x0d
    3432:	8a 0d       	add	r24, r10
    3434:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    3436:	a8 16       	cp	r10, r24
    3438:	b9 06       	cpc	r11, r25
    343a:	60 f4       	brcc	.+24     	; 0x3454 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    343c:	8a 83       	std	Y+2, r24	; 0x02
    343e:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3440:	c8 87       	std	Y+8, r28	; 0x08
    3442:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3444:	b8 01       	movw	r22, r16
    3446:	80 91 c6 22 	lds	r24, 0x22C6	; 0x8022c6 <pxCurrentTimerList>
    344a:	90 91 c7 22 	lds	r25, 0x22C7	; 0x8022c7 <pxCurrentTimerList+0x1>
    344e:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <vListInsert>
    3452:	08 c0       	rjmp	.+16     	; 0x3464 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3454:	00 e0       	ldi	r16, 0x00	; 0
    3456:	10 e0       	ldi	r17, 0x00	; 0
    3458:	20 e0       	ldi	r18, 0x00	; 0
    345a:	30 e0       	ldi	r19, 0x00	; 0
    345c:	a5 01       	movw	r20, r10
    345e:	60 e0       	ldi	r22, 0x00	; 0
    3460:	ce 01       	movw	r24, r28
    3462:	79 df       	rcall	.-270    	; 0x3356 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3464:	e0 91 c6 22 	lds	r30, 0x22C6	; 0x8022c6 <pxCurrentTimerList>
    3468:	f0 91 c7 22 	lds	r31, 0x22C7	; 0x8022c7 <pxCurrentTimerList+0x1>
    346c:	80 81       	ld	r24, Z
    346e:	81 11       	cpse	r24, r1
    3470:	ca cf       	rjmp	.-108    	; 0x3406 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    3472:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <pxOverflowTimerList>
    3476:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <pxOverflowTimerList+0x1>
    347a:	80 93 c6 22 	sts	0x22C6, r24	; 0x8022c6 <pxCurrentTimerList>
    347e:	90 93 c7 22 	sts	0x22C7, r25	; 0x8022c7 <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    3482:	e0 93 c4 22 	sts	0x22C4, r30	; 0x8022c4 <pxOverflowTimerList>
    3486:	f0 93 c5 22 	sts	0x22C5, r31	; 0x8022c5 <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    348a:	81 e0       	ldi	r24, 0x01	; 1
    348c:	f6 01       	movw	r30, r12
    348e:	80 83       	st	Z, r24
    3490:	02 c0       	rjmp	.+4      	; 0x3496 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3492:	f6 01       	movw	r30, r12
    3494:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    3496:	e0 92 be 22 	sts	0x22BE, r14	; 0x8022be <xLastTime.4598>
    349a:	f0 92 bf 22 	sts	0x22BF, r15	; 0x8022bf <xLastTime.4598+0x1>

	return xTimeNow;
}
    349e:	c7 01       	movw	r24, r14
    34a0:	df 91       	pop	r29
    34a2:	cf 91       	pop	r28
    34a4:	1f 91       	pop	r17
    34a6:	0f 91       	pop	r16
    34a8:	ff 90       	pop	r15
    34aa:	ef 90       	pop	r14
    34ac:	df 90       	pop	r13
    34ae:	cf 90       	pop	r12
    34b0:	bf 90       	pop	r11
    34b2:	af 90       	pop	r10
    34b4:	08 95       	ret

000034b6 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    34b6:	cf 93       	push	r28
    34b8:	df 93       	push	r29
    34ba:	00 d0       	rcall	.+0      	; 0x34bc <prvTimerTask+0x6>
    34bc:	00 d0       	rcall	.+0      	; 0x34be <prvTimerTask+0x8>
    34be:	cd b7       	in	r28, 0x3d	; 61
    34c0:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    34c2:	ce 01       	movw	r24, r28
    34c4:	01 96       	adiw	r24, 0x01	; 1
    34c6:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    34c8:	e8 2e       	mov	r14, r24
    34ca:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    34cc:	e0 91 c6 22 	lds	r30, 0x22C6	; 0x8022c6 <pxCurrentTimerList>
    34d0:	f0 91 c7 22 	lds	r31, 0x22C7	; 0x8022c7 <pxCurrentTimerList+0x1>
    34d4:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    34d6:	88 23       	and	r24, r24
    34d8:	09 f4       	brne	.+2      	; 0x34dc <prvTimerTask+0x26>
    34da:	cf c0       	rjmp	.+414    	; 0x367a <prvTimerTask+0x1c4>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    34dc:	05 80       	ldd	r0, Z+5	; 0x05
    34de:	f6 81       	ldd	r31, Z+6	; 0x06
    34e0:	e0 2d       	mov	r30, r0
    34e2:	c0 80       	ld	r12, Z
    34e4:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    34e6:	60 dc       	rcall	.-1856   	; 0x2da8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    34e8:	c5 01       	movw	r24, r10
    34ea:	77 df       	rcall	.-274    	; 0x33da <prvSampleTimeNow>
    34ec:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    34ee:	89 81       	ldd	r24, Y+1	; 0x01
    34f0:	81 11       	cpse	r24, r1
    34f2:	46 c0       	rjmp	.+140    	; 0x3580 <prvTimerTask+0xca>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    34f4:	0c 15       	cp	r16, r12
    34f6:	1d 05       	cpc	r17, r13
			{
				( void ) xTaskResumeAll();
    34f8:	a0 f1       	brcs	.+104    	; 0x3562 <prvTimerTask+0xac>
    34fa:	1e dd       	rcall	.-1476   	; 0x2f38 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    34fc:	e0 91 c6 22 	lds	r30, 0x22C6	; 0x8022c6 <pxCurrentTimerList>
    3500:	f0 91 c7 22 	lds	r31, 0x22C7	; 0x8022c7 <pxCurrentTimerList+0x1>
    3504:	05 80       	ldd	r0, Z+5	; 0x05
    3506:	f6 81       	ldd	r31, Z+6	; 0x06
    3508:	e0 2d       	mov	r30, r0
    350a:	86 80       	ldd	r8, Z+6	; 0x06
    350c:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    350e:	c4 01       	movw	r24, r8
    3510:	02 96       	adiw	r24, 0x02	; 2
    3512:	0e 94 14 11 	call	0x2228	; 0x2228 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3516:	d4 01       	movw	r26, r8
    3518:	52 96       	adiw	r26, 0x12	; 18
    351a:	8c 91       	ld	r24, X
    351c:	52 97       	sbiw	r26, 0x12	; 18
    351e:	82 ff       	sbrs	r24, 2
    3520:	15 c0       	rjmp	.+42     	; 0x354c <prvTimerTask+0x96>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    3522:	1c 96       	adiw	r26, 0x0c	; 12
    3524:	6d 91       	ld	r22, X+
    3526:	7c 91       	ld	r23, X
    3528:	1d 97       	sbiw	r26, 0x0d	; 13
    352a:	6c 0d       	add	r22, r12
    352c:	7d 1d       	adc	r23, r13
    352e:	96 01       	movw	r18, r12
    3530:	a8 01       	movw	r20, r16
    3532:	c4 01       	movw	r24, r8
    3534:	99 de       	rcall	.-718    	; 0x3268 <prvInsertTimerInActiveList>
    3536:	88 23       	and	r24, r24
    3538:	61 f0       	breq	.+24     	; 0x3552 <prvTimerTask+0x9c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    353a:	00 e0       	ldi	r16, 0x00	; 0
    353c:	10 e0       	ldi	r17, 0x00	; 0
    353e:	20 e0       	ldi	r18, 0x00	; 0
    3540:	30 e0       	ldi	r19, 0x00	; 0
    3542:	a6 01       	movw	r20, r12
    3544:	60 e0       	ldi	r22, 0x00	; 0
    3546:	c4 01       	movw	r24, r8
    3548:	06 df       	rcall	.-500    	; 0x3356 <xTimerGenericCommand>
    354a:	03 c0       	rjmp	.+6      	; 0x3552 <prvTimerTask+0x9c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    354c:	8e 7f       	andi	r24, 0xFE	; 254
    354e:	f4 01       	movw	r30, r8
    3550:	82 8b       	std	Z+18, r24	; 0x12
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3552:	d4 01       	movw	r26, r8
    3554:	50 96       	adiw	r26, 0x10	; 16
    3556:	ed 91       	ld	r30, X+
    3558:	fc 91       	ld	r31, X
    355a:	51 97       	sbiw	r26, 0x11	; 17
    355c:	c4 01       	movw	r24, r8
    355e:	19 95       	eicall
    3560:	80 c0       	rjmp	.+256    	; 0x3662 <prvTimerTask+0x1ac>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3562:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3564:	b6 01       	movw	r22, r12
    3566:	60 1b       	sub	r22, r16
    3568:	71 0b       	sbc	r23, r17
    356a:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <xTimerQueue>
    356e:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <xTimerQueue+0x1>

				if( xTaskResumeAll() == pdFALSE )
    3572:	6e da       	rcall	.-2852   	; 0x2a50 <vQueueWaitForMessageRestricted>
    3574:	e1 dc       	rcall	.-1598   	; 0x2f38 <xTaskResumeAll>
    3576:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    3578:	74 c0       	rjmp	.+232    	; 0x3662 <prvTimerTask+0x1ac>
    357a:	0e 94 f7 11 	call	0x23ee	; 0x23ee <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    357e:	71 c0       	rjmp	.+226    	; 0x3662 <prvTimerTask+0x1ac>
    3580:	db dc       	rcall	.-1610   	; 0x2f38 <xTaskResumeAll>
    3582:	6f c0       	rjmp	.+222    	; 0x3662 <prvTimerTask+0x1ac>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3584:	89 81       	ldd	r24, Y+1	; 0x01
    3586:	88 23       	and	r24, r24
    3588:	0c f4       	brge	.+2      	; 0x358c <prvTimerTask+0xd6>
    358a:	6b c0       	rjmp	.+214    	; 0x3662 <prvTimerTask+0x1ac>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    358c:	cc 80       	ldd	r12, Y+4	; 0x04
    358e:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    3590:	f6 01       	movw	r30, r12
    3592:	82 85       	ldd	r24, Z+10	; 0x0a
    3594:	93 85       	ldd	r25, Z+11	; 0x0b
    3596:	89 2b       	or	r24, r25
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3598:	21 f0       	breq	.+8      	; 0x35a2 <prvTimerTask+0xec>
    359a:	c6 01       	movw	r24, r12
    359c:	02 96       	adiw	r24, 0x02	; 2
    359e:	0e 94 14 11 	call	0x2228	; 0x2228 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    35a2:	ce 01       	movw	r24, r28
    35a4:	06 96       	adiw	r24, 0x06	; 6
    35a6:	19 df       	rcall	.-462    	; 0x33da <prvSampleTimeNow>
    35a8:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    35aa:	e9 81       	ldd	r30, Y+1	; 0x01
    35ac:	0e 2e       	mov	r0, r30
    35ae:	00 0c       	add	r0, r0
    35b0:	ff 0b       	sbc	r31, r31
    35b2:	ea 30       	cpi	r30, 0x0A	; 10
    35b4:	f1 05       	cpc	r31, r1
    35b6:	08 f0       	brcs	.+2      	; 0x35ba <prvTimerTask+0x104>
    35b8:	54 c0       	rjmp	.+168    	; 0x3662 <prvTimerTask+0x1ac>
    35ba:	88 27       	eor	r24, r24
    35bc:	e2 50       	subi	r30, 0x02	; 2
    35be:	ff 4f       	sbci	r31, 0xFF	; 255
    35c0:	8f 4f       	sbci	r24, 0xFF	; 255
    35c2:	5d c4       	rjmp	.+2234   	; 0x3e7e <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    35c4:	d6 01       	movw	r26, r12
    35c6:	52 96       	adiw	r26, 0x12	; 18
    35c8:	8c 91       	ld	r24, X
    35ca:	52 97       	sbiw	r26, 0x12	; 18
    35cc:	81 60       	ori	r24, 0x01	; 1
    35ce:	52 96       	adiw	r26, 0x12	; 18
    35d0:	8c 93       	st	X, r24
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    35d2:	52 97       	sbiw	r26, 0x12	; 18
    35d4:	2a 81       	ldd	r18, Y+2	; 0x02
    35d6:	3b 81       	ldd	r19, Y+3	; 0x03
    35d8:	1c 96       	adiw	r26, 0x0c	; 12
    35da:	6d 91       	ld	r22, X+
    35dc:	7c 91       	ld	r23, X
    35de:	1d 97       	sbiw	r26, 0x0d	; 13
    35e0:	62 0f       	add	r22, r18
    35e2:	73 1f       	adc	r23, r19
    35e4:	c6 01       	movw	r24, r12
    35e6:	40 de       	rcall	.-896    	; 0x3268 <prvInsertTimerInActiveList>
    35e8:	88 23       	and	r24, r24
    35ea:	d9 f1       	breq	.+118    	; 0x3662 <prvTimerTask+0x1ac>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    35ec:	d6 01       	movw	r26, r12
    35ee:	50 96       	adiw	r26, 0x10	; 16
    35f0:	ed 91       	ld	r30, X+
    35f2:	fc 91       	ld	r31, X
    35f4:	51 97       	sbiw	r26, 0x11	; 17
    35f6:	c6 01       	movw	r24, r12
    35f8:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    35fa:	f6 01       	movw	r30, r12
    35fc:	82 89       	ldd	r24, Z+18	; 0x12
    35fe:	82 ff       	sbrs	r24, 2
    3600:	30 c0       	rjmp	.+96     	; 0x3662 <prvTimerTask+0x1ac>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3602:	4a 81       	ldd	r20, Y+2	; 0x02
    3604:	5b 81       	ldd	r21, Y+3	; 0x03
    3606:	84 85       	ldd	r24, Z+12	; 0x0c
    3608:	95 85       	ldd	r25, Z+13	; 0x0d
    360a:	48 0f       	add	r20, r24
    360c:	59 1f       	adc	r21, r25
    360e:	00 e0       	ldi	r16, 0x00	; 0
    3610:	10 e0       	ldi	r17, 0x00	; 0
    3612:	20 e0       	ldi	r18, 0x00	; 0
    3614:	30 e0       	ldi	r19, 0x00	; 0
    3616:	60 e0       	ldi	r22, 0x00	; 0
    3618:	c6 01       	movw	r24, r12
    361a:	9d de       	rcall	.-710    	; 0x3356 <xTimerGenericCommand>
    361c:	22 c0       	rjmp	.+68     	; 0x3662 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    361e:	d6 01       	movw	r26, r12
    3620:	52 96       	adiw	r26, 0x12	; 18
    3622:	8c 91       	ld	r24, X
    3624:	52 97       	sbiw	r26, 0x12	; 18
    3626:	8e 7f       	andi	r24, 0xFE	; 254
    3628:	52 96       	adiw	r26, 0x12	; 18
    362a:	8c 93       	st	X, r24
    362c:	1a c0       	rjmp	.+52     	; 0x3662 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    362e:	f6 01       	movw	r30, r12
    3630:	82 89       	ldd	r24, Z+18	; 0x12
    3632:	81 60       	ori	r24, 0x01	; 1
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3634:	82 8b       	std	Z+18, r24	; 0x12
    3636:	6a 81       	ldd	r22, Y+2	; 0x02
    3638:	7b 81       	ldd	r23, Y+3	; 0x03
    363a:	64 87       	std	Z+12, r22	; 0x0c
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    363c:	75 87       	std	Z+13, r23	; 0x0d
    363e:	64 0f       	add	r22, r20
    3640:	75 1f       	adc	r23, r21
    3642:	9a 01       	movw	r18, r20
    3644:	c6 01       	movw	r24, r12
    3646:	10 de       	rcall	.-992    	; 0x3268 <prvInsertTimerInActiveList>
    3648:	0c c0       	rjmp	.+24     	; 0x3662 <prvTimerTask+0x1ac>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    364a:	d6 01       	movw	r26, r12
    364c:	52 96       	adiw	r26, 0x12	; 18
    364e:	8c 91       	ld	r24, X
    3650:	81 fd       	sbrc	r24, 1
    3652:	04 c0       	rjmp	.+8      	; 0x365c <prvTimerTask+0x1a6>
						{
							vPortFree( pxTimer );
    3654:	c6 01       	movw	r24, r12
    3656:	0e 94 b6 12 	call	0x256c	; 0x256c <vPortFree>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    365a:	03 c0       	rjmp	.+6      	; 0x3662 <prvTimerTask+0x1ac>
    365c:	8e 7f       	andi	r24, 0xFE	; 254
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    365e:	f6 01       	movw	r30, r12
    3660:	82 8b       	std	Z+18, r24	; 0x12
    3662:	40 e0       	ldi	r20, 0x00	; 0
    3664:	50 e0       	ldi	r21, 0x00	; 0
    3666:	6e 2d       	mov	r22, r14
    3668:	7f 2d       	mov	r23, r15
    366a:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <xTimerQueue>
    366e:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <xTimerQueue+0x1>
    3672:	6a d9       	rcall	.-3372   	; 0x2948 <xQueueReceive>
    3674:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3676:	86 cf       	rjmp	.-244    	; 0x3584 <prvTimerTask+0xce>
    3678:	29 cf       	rjmp	.-430    	; 0x34cc <prvTimerTask+0x16>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    367a:	96 db       	rcall	.-2260   	; 0x2da8 <vTaskSuspendAll>
    367c:	c5 01       	movw	r24, r10
    367e:	ad de       	rcall	.-678    	; 0x33da <prvSampleTimeNow>
    3680:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    3682:	89 81       	ldd	r24, Y+1	; 0x01
    3684:	81 11       	cpse	r24, r1
    3686:	7c cf       	rjmp	.-264    	; 0x3580 <prvTimerTask+0xca>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3688:	e0 91 c4 22 	lds	r30, 0x22C4	; 0x8022c4 <pxOverflowTimerList>
    368c:	f0 91 c5 22 	lds	r31, 0x22C5	; 0x8022c5 <pxOverflowTimerList+0x1>
    3690:	80 81       	ld	r24, Z
    3692:	41 e0       	ldi	r20, 0x01	; 1
    3694:	81 11       	cpse	r24, r1
    3696:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    3698:	c1 2c       	mov	r12, r1
    369a:	d1 2c       	mov	r13, r1
    369c:	63 cf       	rjmp	.-314    	; 0x3564 <prvTimerTask+0xae>

0000369e <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
    369e:	04 c0       	rjmp	.+8      	; 0x36a8 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
    36a0:	61 50       	subi	r22, 0x01	; 1
    36a2:	71 09       	sbc	r23, r1
    36a4:	81 09       	sbc	r24, r1
    36a6:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
    36a8:	61 15       	cp	r22, r1
    36aa:	71 05       	cpc	r23, r1
    36ac:	81 05       	cpc	r24, r1
    36ae:	91 05       	cpc	r25, r1
    36b0:	b9 f7       	brne	.-18     	; 0x36a0 <__portable_avr_delay_cycles+0x2>
    36b2:	08 95       	ret

000036b4 <sendChar>:
	USARTC0_CTRLB = USART_TXEN_bm | USART_RXEN_bm;
}

static void sendChar(char c) {
	
	while( !(USARTC0_STATUS & USART_DREIF_bm) ); //Wait until DATA buffer is empty
    36b4:	e1 ea       	ldi	r30, 0xA1	; 161
    36b6:	f8 e0       	ldi	r31, 0x08	; 8
    36b8:	90 81       	ld	r25, Z
    36ba:	95 ff       	sbrs	r25, 5
    36bc:	fd cf       	rjmp	.-6      	; 0x36b8 <sendChar+0x4>
	
	USARTC0_DATA = c;
    36be:	80 93 a0 08 	sts	0x08A0, r24	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    36c2:	08 95       	ret

000036c4 <control_led>:
		TCC0.CCA = PWM_ON; // Activate buzzer
		PORTC.OUTSET = PIN_BUZZER;
	}
}

static portTASK_FUNCTION_PROTO(control_led, p_) {
    36c4:	cf 93       	push	r28
    36c6:	df 93       	push	r29
    36c8:	1f 92       	push	r1
    36ca:	cd b7       	in	r28, 0x3d	; 61
    36cc:	de b7       	in	r29, 0x3e	; 62

// Function to read ADC value
static uint16_t adc_read(void) {
	uint16_t result;

	adc_enable(&MY_ADC);                          // Enable ADC
    36ce:	e1 2c       	mov	r14, r1
    36d0:	68 94       	set
    36d2:	ff 24       	eor	r15, r15
    36d4:	f1 f8       	bld	r15, 1
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    36d6:	77 24       	eor	r7, r7
    36d8:	73 94       	inc	r7

	// Add energy (Power  Time, where Time is 1 second)
	total_energy += power;
	
	// Convert total_energy to string with two decimal places
	snprintf(strbufusart, sizeof(strbufusart), "%.2f", total_energy);
    36da:	0f 2e       	mov	r0, r31
    36dc:	f9 ec       	ldi	r31, 0xC9	; 201
    36de:	6f 2e       	mov	r6, r31
    36e0:	f0 2d       	mov	r31, r0
    36e2:	0f 2e       	mov	r0, r31
    36e4:	fa ed       	ldi	r31, 0xDA	; 218
    36e6:	8f 2e       	mov	r8, r31
    36e8:	f2 e2       	ldi	r31, 0x22	; 34
    36ea:	9f 2e       	mov	r9, r31
    36ec:	f0 2d       	mov	r31, r0

		// Calculate energy and check thresholds
		calculate_energy_and_check(current_mA);

		// Display the current value in milliamps
		snprintf(strbuf, sizeof(strbuf), "Current: %4d mA", current_mA);
    36ee:	0f 2e       	mov	r0, r31
    36f0:	f7 ea       	ldi	r31, 0xA7	; 167
    36f2:	af 2e       	mov	r10, r31
    36f4:	f3 e2       	ldi	r31, 0x23	; 35
    36f6:	bf 2e       	mov	r11, r31
    36f8:	f0 2d       	mov	r31, r0

// Function to read ADC value
static uint16_t adc_read(void) {
	uint16_t result;

	adc_enable(&MY_ADC);                          // Enable ADC
    36fa:	c7 01       	movw	r24, r14
    36fc:	0e 94 36 08 	call	0x106c	; 0x106c <adc_enable>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    3700:	8f b7       	in	r24, 0x3f	; 63
    3702:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    3704:	f8 94       	cli
	return flags;
    3706:	99 81       	ldd	r25, Y+1	; 0x01
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    3708:	f7 01       	movw	r30, r14
    370a:	80 81       	ld	r24, Z
    370c:	84 60       	ori	r24, 0x04	; 4
    370e:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    3710:	9f bf       	out	0x3f, r25	; 63
 *
 * \return Mask with interrupt flags.
 */
static inline uint8_t adc_get_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	return (adc->INTFLAGS >> ADC_CH0IF_bp) & ch_mask;
    3712:	f7 01       	movw	r30, r14
    3714:	86 81       	ldd	r24, Z+6	; 0x06
 * \arg \c ADC_CHn , where \c n specifies the channel. (These can be OR'ed
 * together.)
 */
static inline void adc_wait_for_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	do { } while (adc_get_interrupt_flag(adc, ch_mask) != ch_mask);
    3716:	80 ff       	sbrs	r24, 0
    3718:	fc cf       	rjmp	.-8      	; 0x3712 <control_led+0x4e>
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    371a:	76 82       	std	Z+6, r7	; 0x06
	adc_start_conversion(&MY_ADC, MY_ADC_CH);     // Start ADC conversion
	adc_wait_for_interrupt_flag(&MY_ADC, MY_ADC_CH); // Wait for ADC to finish
	result = adc_get_result(&MY_ADC, MY_ADC_CH);  // Get ADC result
    371c:	c4 a0       	ldd	r12, Z+36	; 0x24
    371e:	d5 a0       	ldd	r13, Z+37	; 0x25
	adc_disable(&MY_ADC);                         // Disable ADC (optional for power saving)
    3720:	c7 01       	movw	r24, r14
    3722:	0e 94 62 08 	call	0x10c4	; 0x10c4 <adc_disable>
}

// Function to convert ADC reading to current in milliamps (mA)
static int convert_adc_to_milliamp(uint16_t adc_value) {
	int16_t adjusted_value = adc_value - 2568; // Subtract baseline (calibration value)
	int current_mA = adjusted_value * 10;      // Each 1 ADC unit corresponds to 10mA
    3726:	c6 01       	movw	r24, r12
    3728:	88 50       	subi	r24, 0x08	; 8
    372a:	9a 40       	sbci	r25, 0x0A	; 10
    372c:	6c 01       	movw	r12, r24
    372e:	cc 0c       	add	r12, r12
    3730:	dd 1c       	adc	r13, r13
    3732:	88 0f       	add	r24, r24
    3734:	99 1f       	adc	r25, r25
    3736:	88 0f       	add	r24, r24
    3738:	99 1f       	adc	r25, r25
    373a:	88 0f       	add	r24, r24
    373c:	99 1f       	adc	r25, r25
    373e:	c8 0e       	add	r12, r24
    3740:	d9 1e       	adc	r13, r25
    3742:	dd 20       	and	r13, r13
    3744:	14 f4       	brge	.+4      	; 0x374a <control_led+0x86>
    3746:	c1 2c       	mov	r12, r1
    3748:	d1 2c       	mov	r13, r1
static void calculate_energy_and_check(int current_mA) {
	// Calculate power in Watts (current in mA to Amps)
	double power = (VCC * current_mA) / 1000.0;

	// Add energy (Power  Time, where Time is 1 second)
	total_energy += power;
    374a:	b6 01       	movw	r22, r12
    374c:	0d 2c       	mov	r0, r13
    374e:	00 0c       	add	r0, r0
    3750:	88 0b       	sbc	r24, r24
    3752:	99 0b       	sbc	r25, r25
    3754:	48 d2       	rcall	.+1168   	; 0x3be6 <__floatsisf>
    3756:	23 e3       	ldi	r18, 0x33	; 51
    3758:	33 e3       	ldi	r19, 0x33	; 51
    375a:	43 e5       	ldi	r20, 0x53	; 83
    375c:	50 e4       	ldi	r21, 0x40	; 64
    375e:	d3 d2       	rcall	.+1446   	; 0x3d06 <__mulsf3>
    3760:	20 e0       	ldi	r18, 0x00	; 0
    3762:	30 e0       	ldi	r19, 0x00	; 0
    3764:	4a e7       	ldi	r20, 0x7A	; 122
    3766:	54 e4       	ldi	r21, 0x44	; 68
    3768:	a3 d1       	rcall	.+838    	; 0x3ab0 <__divsf3>
    376a:	20 91 a3 23 	lds	r18, 0x23A3	; 0x8023a3 <total_energy>
    376e:	30 91 a4 23 	lds	r19, 0x23A4	; 0x8023a4 <total_energy+0x1>
    3772:	40 91 a5 23 	lds	r20, 0x23A5	; 0x8023a5 <total_energy+0x2>
    3776:	50 91 a6 23 	lds	r21, 0x23A6	; 0x8023a6 <total_energy+0x3>
    377a:	36 d1       	rcall	.+620    	; 0x39e8 <__addsf3>
    377c:	26 2f       	mov	r18, r22
    377e:	37 2f       	mov	r19, r23
    3780:	46 2f       	mov	r20, r22
    3782:	57 2f       	mov	r21, r23
    3784:	68 2f       	mov	r22, r24
    3786:	79 2f       	mov	r23, r25
    3788:	40 93 a3 23 	sts	0x23A3, r20	; 0x8023a3 <total_energy>
    378c:	50 93 a4 23 	sts	0x23A4, r21	; 0x8023a4 <total_energy+0x1>
    3790:	60 93 a5 23 	sts	0x23A5, r22	; 0x8023a5 <total_energy+0x2>
    3794:	70 93 a6 23 	sts	0x23A6, r23	; 0x8023a6 <total_energy+0x3>
	
	// Convert total_energy to string with two decimal places
	snprintf(strbufusart, sizeof(strbufusart), "%.2f", total_energy);
    3798:	9f 93       	push	r25
    379a:	8f 93       	push	r24
    379c:	3f 93       	push	r19
    379e:	2f 93       	push	r18
    37a0:	21 e2       	ldi	r18, 0x21	; 33
    37a2:	30 e2       	ldi	r19, 0x20	; 32
    37a4:	3f 93       	push	r19
    37a6:	2f 93       	push	r18
    37a8:	1f 92       	push	r1
    37aa:	6f 92       	push	r6
    37ac:	9f 92       	push	r9
    37ae:	8f 92       	push	r8
    37b0:	ac d4       	rcall	.+2392   	; 0x410a <snprintf>
	USARTC0_DATA = c;
	
}

static void sendString(char *text) {
	while(*text)
    37b2:	f4 01       	movw	r30, r8
    37b4:	80 81       	ld	r24, Z
    37b6:	cd bf       	out	0x3d, r28	; 61
    37b8:	de bf       	out	0x3e, r29	; 62
    37ba:	88 23       	and	r24, r24
    37bc:	41 f0       	breq	.+16     	; 0x37ce <control_led+0x10a>
    37be:	0b ed       	ldi	r16, 0xDB	; 219
	{
		sendChar(*text++);
    37c0:	12 e2       	ldi	r17, 0x22	; 34
    37c2:	78 df       	rcall	.-272    	; 0x36b4 <sendChar>
	USARTC0_DATA = c;
	
}

static void sendString(char *text) {
	while(*text)
    37c4:	f8 01       	movw	r30, r16
    37c6:	81 91       	ld	r24, Z+
    37c8:	8f 01       	movw	r16, r30
    37ca:	81 11       	cpse	r24, r1
    37cc:	fa cf       	rjmp	.-12     	; 0x37c2 <control_led+0xfe>
	// Convert total_energy to string with two decimal places
	snprintf(strbufusart, sizeof(strbufusart), "%.2f", total_energy);
	sendString(strbufusart);  // Send the formatted string over USART

	// Check thresholds
	if (total_energy > ENERGY_THRESHOLD_RELAY) {
    37ce:	20 90 a3 23 	lds	r2, 0x23A3	; 0x8023a3 <total_energy>
    37d2:	30 90 a4 23 	lds	r3, 0x23A4	; 0x8023a4 <total_energy+0x1>
    37d6:	40 90 a5 23 	lds	r4, 0x23A5	; 0x8023a5 <total_energy+0x2>
    37da:	50 90 a6 23 	lds	r5, 0x23A6	; 0x8023a6 <total_energy+0x3>
    37de:	20 e0       	ldi	r18, 0x00	; 0
    37e0:	30 e0       	ldi	r19, 0x00	; 0
    37e2:	40 ec       	ldi	r20, 0xC0	; 192
    37e4:	50 e4       	ldi	r21, 0x40	; 64
    37e6:	c2 01       	movw	r24, r4
    37e8:	b1 01       	movw	r22, r2
    37ea:	89 d2       	rcall	.+1298   	; 0x3cfe <__gesf2>
    37ec:	18 16       	cp	r1, r24
	PORTC.DIRSET = PIN_BUZZER;
}

// Function to disconnect the relay
static void relay_putus(void) {
	PORTC.DIRSET = PIN_RELAY; // Configure relay control pin as output
    37ee:	64 f4       	brge	.+24     	; 0x3808 <control_led+0x144>
    37f0:	82 e0       	ldi	r24, 0x02	; 2
    37f2:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
	sendString(strbufusart);  // Send the formatted string over USART

	// Check thresholds
	if (total_energy > ENERGY_THRESHOLD_RELAY) {
		relay_putus(); // Disconnect the load
		sendChar('0');
    37f6:	80 e3       	ldi	r24, 0x30	; 48
    37f8:	5d df       	rcall	.-326    	; 0x36b4 <sendChar>
		TCC0.CCA = PWM_OFF; // Disable PWM
    37fa:	10 92 28 08 	sts	0x0828, r1	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    37fe:	10 92 29 08 	sts	0x0829, r1	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
		PORTC.OUTCLR = PIN_BUZZER;
    3802:	70 92 46 06 	sts	0x0646, r7	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
	}
	else if (total_energy > ENERGY_THRESHOLD_BUZZER) {
    3806:	13 c0       	rjmp	.+38     	; 0x382e <control_led+0x16a>
    3808:	20 e0       	ldi	r18, 0x00	; 0
    380a:	30 e0       	ldi	r19, 0x00	; 0
    380c:	40 e8       	ldi	r20, 0x80	; 128
    380e:	5f e3       	ldi	r21, 0x3F	; 63
    3810:	c2 01       	movw	r24, r4
    3812:	b1 01       	movw	r22, r2
    3814:	74 d2       	rcall	.+1256   	; 0x3cfe <__gesf2>
    3816:	18 16       	cp	r1, r24
		sendChar('1');
    3818:	54 f4       	brge	.+20     	; 0x382e <control_led+0x16a>
    381a:	81 e3       	ldi	r24, 0x31	; 49
    381c:	4b df       	rcall	.-362    	; 0x36b4 <sendChar>
		TCC0.CCA = PWM_ON; // Activate buzzer
    381e:	28 ec       	ldi	r18, 0xC8	; 200
    3820:	30 e0       	ldi	r19, 0x00	; 0
    3822:	20 93 28 08 	sts	0x0828, r18	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3826:	30 93 29 08 	sts	0x0829, r19	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
		PORTC.OUTSET = PIN_BUZZER;
    382a:	70 92 45 06 	sts	0x0645, r7	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>

		// Calculate energy and check thresholds
		calculate_energy_and_check(current_mA);

		// Display the current value in milliamps
		snprintf(strbuf, sizeof(strbuf), "Current: %4d mA", current_mA);
    382e:	df 92       	push	r13
    3830:	cf 92       	push	r12
    3832:	86 e2       	ldi	r24, 0x26	; 38
    3834:	90 e2       	ldi	r25, 0x20	; 32
    3836:	9f 93       	push	r25
    3838:	8f 93       	push	r24
    383a:	1f 92       	push	r1
    383c:	10 e8       	ldi	r17, 0x80	; 128
    383e:	1f 93       	push	r17
    3840:	bf 92       	push	r11
    3842:	af 92       	push	r10
    3844:	62 d4       	rcall	.+2244   	; 0x410a <snprintf>
		gfx_mono_draw_string(strbuf, 0, 8, &sysfont);
    3846:	26 e0       	ldi	r18, 0x06	; 6
    3848:	30 e2       	ldi	r19, 0x20	; 32
    384a:	48 e0       	ldi	r20, 0x08	; 8
    384c:	60 e0       	ldi	r22, 0x00	; 0
    384e:	c5 01       	movw	r24, r10
    3850:	0e 94 98 06 	call	0xd30	; 0xd30 <gfx_mono_draw_string>
		
		// Display energy in Joules on the LCD
		int display_energy = (int)(total_energy * 100); // Convert to "cents" of Joules
    3854:	20 e0       	ldi	r18, 0x00	; 0
    3856:	30 e0       	ldi	r19, 0x00	; 0
    3858:	48 ec       	ldi	r20, 0xC8	; 200
    385a:	52 e4       	ldi	r21, 0x42	; 66
    385c:	60 91 a3 23 	lds	r22, 0x23A3	; 0x8023a3 <total_energy>
    3860:	70 91 a4 23 	lds	r23, 0x23A4	; 0x8023a4 <total_energy+0x1>
    3864:	80 91 a5 23 	lds	r24, 0x23A5	; 0x8023a5 <total_energy+0x2>
    3868:	90 91 a6 23 	lds	r25, 0x23A6	; 0x8023a6 <total_energy+0x3>
    386c:	4c d2       	rcall	.+1176   	; 0x3d06 <__mulsf3>
		snprintf(strbuf, sizeof(strbuf), "Energy: %d.%02d J", display_energy / 100, display_energy % 100);
    386e:	88 d1       	rcall	.+784    	; 0x3b80 <__fixsfsi>
    3870:	cb 01       	movw	r24, r22
    3872:	64 e6       	ldi	r22, 0x64	; 100
    3874:	70 e0       	ldi	r23, 0x00	; 0
    3876:	ce d2       	rcall	.+1436   	; 0x3e14 <__divmodhi4>
    3878:	9f 93       	push	r25
    387a:	8f 93       	push	r24
    387c:	7f 93       	push	r23
    387e:	6f 93       	push	r22
    3880:	26 e3       	ldi	r18, 0x36	; 54
    3882:	30 e2       	ldi	r19, 0x20	; 32
    3884:	3f 93       	push	r19
    3886:	2f 93       	push	r18
    3888:	1f 92       	push	r1
    388a:	1f 93       	push	r17
    388c:	bf 92       	push	r11
    388e:	af 92       	push	r10
		gfx_mono_draw_string(strbuf, 0, 16, &sysfont);
    3890:	3c d4       	rcall	.+2168   	; 0x410a <snprintf>
    3892:	26 e0       	ldi	r18, 0x06	; 6
    3894:	30 e2       	ldi	r19, 0x20	; 32
    3896:	40 e1       	ldi	r20, 0x10	; 16
    3898:	60 e0       	ldi	r22, 0x00	; 0
    389a:	c5 01       	movw	r24, r10
    389c:	0e 94 98 06 	call	0xd30	; 0xd30 <gfx_mono_draw_string>

		delay_ms(1000);  // Delay for 1 second
    38a0:	66 e1       	ldi	r22, 0x16	; 22
    38a2:	76 e1       	ldi	r23, 0x16	; 22
    38a4:	85 e0       	ldi	r24, 0x05	; 5
    38a6:	90 e0       	ldi	r25, 0x00	; 0
    38a8:	fa de       	rcall	.-524    	; 0x369e <__portable_avr_delay_cycles>
    38aa:	cd bf       	out	0x3d, r28	; 61
    38ac:	de bf       	out	0x3e, r29	; 62
    38ae:	25 cf       	rjmp	.-438    	; 0x36fa <control_led+0x36>

000038b0 <main>:
	}
}


int main(void) {
    38b0:	ef 92       	push	r14
    38b2:	ff 92       	push	r15
    38b4:	0f 93       	push	r16
    38b6:	1f 93       	push	r17
    38b8:	cf 93       	push	r28
    38ba:	df 93       	push	r29
    38bc:	cd b7       	in	r28, 0x3d	; 61
    38be:	de b7       	in	r29, 0x3e	; 62
    38c0:	2b 97       	sbiw	r28, 0x0b	; 11
    38c2:	cd bf       	out	0x3d, r28	; 61
    38c4:	de bf       	out	0x3e, r29	; 62
	// Initialize system clock, board, and peripherals
	sysclk_init();
    38c6:	0e 94 42 04 	call	0x884	; 0x884 <sysclk_init>
	board_init();
    38ca:	0e 94 5d 07 	call	0xeba	; 0xeba <board_init>

// Function to initialize PWM
static void pwm_init(void) {

	// Use a different timer for PWM (e.g., TCC1)
	TCC1.CTRLA = TC_CLKSEL_DIV1024_gc; // Set prescaler
    38ce:	e0 e4       	ldi	r30, 0x40	; 64
    38d0:	f8 e0       	ldi	r31, 0x08	; 8
    38d2:	87 e0       	ldi	r24, 0x07	; 7
    38d4:	80 83       	st	Z, r24
	TCC1.CTRLB = TC_WGMODE_SS_gc | TC1_CCAEN_bm; // Single Slope PWM, Enable Compare A
    38d6:	83 e1       	ldi	r24, 0x13	; 19
    38d8:	81 83       	std	Z+1, r24	; 0x01
	TCC1.PER = 1000; // Set period for desired frequency
    38da:	88 ee       	ldi	r24, 0xE8	; 232
    38dc:	93 e0       	ldi	r25, 0x03	; 3
    38de:	86 a3       	std	Z+38, r24	; 0x26
    38e0:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CCA = PWM_OFF; // Initially set duty cycle to 0
    38e2:	10 a6       	std	Z+40, r1	; 0x28
    38e4:	11 a6       	std	Z+41, r1	; 0x29
	PORTC.DIRSET = PIN0_bm; // Set PC0 as output
    38e6:	11 e0       	ldi	r17, 0x01	; 1
    38e8:	10 93 41 06 	sts	0x0641, r17	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
// Function to initialize ADC
static void adc_init(void) {
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC, &adc_conf);
    38ec:	be 01       	movw	r22, r28
    38ee:	6f 5f       	subi	r22, 0xFF	; 255
    38f0:	7f 4f       	sbci	r23, 0xFF	; 255
    38f2:	80 e0       	ldi	r24, 0x00	; 0
    38f4:	92 e0       	ldi	r25, 0x02	; 2
    38f6:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <adc_read_configuration>
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    38fa:	ae 01       	movw	r20, r28
    38fc:	48 5f       	subi	r20, 0xF8	; 248
    38fe:	5f 4f       	sbci	r21, 0xFF	; 255
    3900:	61 e0       	ldi	r22, 0x01	; 1
    3902:	80 e0       	ldi	r24, 0x00	; 0
    3904:	92 e0       	ldi	r25, 0x02	; 2
    3906:	0e 94 02 0b 	call	0x1604	; 0x1604 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    390a:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    390c:	8b 81       	ldd	r24, Y+3	; 0x03
    390e:	8f 78       	andi	r24, 0x8F	; 143
    3910:	80 62       	ori	r24, 0x20	; 32
    3912:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3914:	89 2f       	mov	r24, r25
    3916:	81 7e       	andi	r24, 0xE1	; 225
    3918:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    391a:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    391c:	82 e0       	ldi	r24, 0x02	; 2
    391e:	8d 83       	std	Y+5, r24	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3920:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3922:	80 e4       	ldi	r24, 0x40	; 64
    3924:	89 87       	std	Y+9, r24	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J2_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC, &adc_conf);
    3926:	be 01       	movw	r22, r28
    3928:	6f 5f       	subi	r22, 0xFF	; 255
    392a:	7f 4f       	sbci	r23, 0xFF	; 255
    392c:	80 e0       	ldi	r24, 0x00	; 0
    392e:	92 e0       	ldi	r25, 0x02	; 2
    3930:	0e 94 18 0a 	call	0x1430	; 0x1430 <adc_write_configuration>
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    3934:	ae 01       	movw	r20, r28
    3936:	48 5f       	subi	r20, 0xF8	; 248
    3938:	5f 4f       	sbci	r21, 0xFF	; 255
    393a:	61 e0       	ldi	r22, 0x01	; 1
    393c:	80 e0       	ldi	r24, 0x00	; 0
    393e:	92 e0       	ldi	r25, 0x02	; 2
    3940:	0e 94 b7 0a 	call	0x156e	; 0x156e <adcch_write_configuration>
	// Initialize system clock, board, and peripherals
	sysclk_init();
	board_init();
	pwm_init();
	adc_init();
	gfx_mono_init();
    3944:	0e 94 24 05 	call	0xa48	; 0xa48 <gfx_mono_st7565r_init>
    3948:	80 e1       	ldi	r24, 0x10	; 16
    394a:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>

	// Turn LCD backlight on
	gpio_set_pin_high(LCD_BACKLIGHT_ENABLE_PIN);
	
	PORTC_OUTSET = PIN3_bm; //PC3 as TX
    394e:	88 e0       	ldi	r24, 0x08	; 8
    3950:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
	PORTC_DIRSET = PIN3_bm; //TX pin as output
    3954:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
	
	PORTC_OUTCLR = PIN2_bm; //PC2 as RX
    3958:	84 e0       	ldi	r24, 0x04	; 4
    395a:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
	PORTC_DIRCLR = PIN2_bm; //RX pin as input
    395e:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x700642>
static void setUpSerial(void) {
	// Baud rate selection
	// BSEL = (2000000 / (2^0 * 16*9600) -1 = 12.0208... ~ 12 -> BSCALE = 0
	// FBAUD = ( (2000000)/(2^0*16(12+1)) = 9615.384 -> mendekati lah ya
	
	USARTC0_BAUDCTRLB = 0; //memastikan BSCALE = 0
    3962:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
	USARTC0_BAUDCTRLA = 0x0C; // 12
    3966:	8c e0       	ldi	r24, 0x0C	; 12
    3968:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
	
	//USARTC0_BAUDCTRLB = 0; //Just to be sure that BSCALE is 0
	//USARTC0_BAUDCTRLA = 0xCF; // 207
	
	//Disable interrupts, just for safety
	USARTC0_CTRLA = 0;
    396c:	10 92 a3 08 	sts	0x08A3, r1	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
	//8 data bits, no parity and 1 stop bit
	USARTC0_CTRLC = USART_CHSIZE_8BIT_gc;
    3970:	83 e0       	ldi	r24, 0x03	; 3
    3972:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
	
	//Enable receive and transmit
	USARTC0_CTRLB = USART_TXEN_bm | USART_RXEN_bm;
    3976:	88 e1       	ldi	r24, 0x18	; 24
    3978:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
		.charlength = USART_SERIAL_CHAR_LENGTH,
		.paritytype = USART_SERIAL_PARITY,
		.stopbits = USART_SERIAL_STOP_BIT
	};
	
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    397c:	6d e0       	ldi	r22, 0x0D	; 13
    397e:	70 e2       	ldi	r23, 0x20	; 32
    3980:	80 ea       	ldi	r24, 0xA0	; 160
    3982:	98 e0       	ldi	r25, 0x08	; 8
    3984:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <usart_init_rs232>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    3988:	10 93 21 06 	sts	0x0621, r17	; 0x800621 <__TEXT_REGION_LENGTH__+0x700621>
	
	ioport_set_pin_dir(J2_PIN0, IOPORT_DIR_OUTPUT);

	/* Create the task */
	xTaskCreate(control_led, "", 1000, NULL, tskIDLE_PRIORITY + 1, NULL);	// higher priority
    398c:	e1 2c       	mov	r14, r1
    398e:	f1 2c       	mov	r15, r1
    3990:	01 e0       	ldi	r16, 0x01	; 1
    3992:	20 e0       	ldi	r18, 0x00	; 0
    3994:	30 e0       	ldi	r19, 0x00	; 0
    3996:	48 ee       	ldi	r20, 0xE8	; 232
    3998:	53 e0       	ldi	r21, 0x03	; 3
    399a:	65 e3       	ldi	r22, 0x35	; 53
    399c:	70 e2       	ldi	r23, 0x20	; 32
    399e:	82 e6       	ldi	r24, 0x62	; 98
    39a0:	9b e1       	ldi	r25, 0x1B	; 27
    39a2:	d8 d8       	rcall	.-3664   	; 0x2b54 <xTaskCreate>
	/* Semaphore */
	xSemaphore = xSemaphoreCreateBinary();
    39a4:	43 e0       	ldi	r20, 0x03	; 3
    39a6:	60 e0       	ldi	r22, 0x00	; 0
    39a8:	81 e0       	ldi	r24, 0x01	; 1
    39aa:	0e 94 bc 13 	call	0x2778	; 0x2778 <xQueueGenericCreate>
	xSemaphoreGive(xSemaphore);
    39ae:	20 e0       	ldi	r18, 0x00	; 0
    39b0:	40 e0       	ldi	r20, 0x00	; 0
    39b2:	50 e0       	ldi	r21, 0x00	; 0
    39b4:	60 e0       	ldi	r22, 0x00	; 0
    39b6:	70 e0       	ldi	r23, 0x00	; 0
    39b8:	0e 94 dd 13 	call	0x27ba	; 0x27ba <xQueueGenericSend>
	
	/* Start the task */
	gfx_mono_draw_string("Embedder", 0, 0, &sysfont);
    39bc:	26 e0       	ldi	r18, 0x06	; 6
    39be:	30 e2       	ldi	r19, 0x20	; 32
    39c0:	40 e0       	ldi	r20, 0x00	; 0
    39c2:	60 e0       	ldi	r22, 0x00	; 0
    39c4:	88 e4       	ldi	r24, 0x48	; 72
    39c6:	90 e2       	ldi	r25, 0x20	; 32
    39c8:	0e 94 98 06 	call	0xd30	; 0xd30 <gfx_mono_draw_string>
	vTaskStartScheduler();
    39cc:	c2 d9       	rcall	.-3196   	; 0x2d52 <vTaskStartScheduler>
    39ce:	80 e0       	ldi	r24, 0x00	; 0
    39d0:	90 e0       	ldi	r25, 0x00	; 0
    39d2:	2b 96       	adiw	r28, 0x0b	; 11
    39d4:	cd bf       	out	0x3d, r28	; 61
    39d6:	de bf       	out	0x3e, r29	; 62
    39d8:	df 91       	pop	r29
    39da:	cf 91       	pop	r28
    39dc:	1f 91       	pop	r17
    39de:	0f 91       	pop	r16
    39e0:	ff 90       	pop	r15
    39e2:	ef 90       	pop	r14
    39e4:	08 95       	ret

000039e6 <__subsf3>:
    39e6:	50 58       	subi	r21, 0x80	; 128

000039e8 <__addsf3>:
    39e8:	bb 27       	eor	r27, r27
    39ea:	aa 27       	eor	r26, r26
    39ec:	0e d0       	rcall	.+28     	; 0x3a0a <__addsf3x>
    39ee:	4d c1       	rjmp	.+666    	; 0x3c8a <__fp_round>
    39f0:	3e d1       	rcall	.+636    	; 0x3c6e <__fp_pscA>
    39f2:	30 f0       	brcs	.+12     	; 0x3a00 <__addsf3+0x18>
    39f4:	43 d1       	rcall	.+646    	; 0x3c7c <__fp_pscB>
    39f6:	20 f0       	brcs	.+8      	; 0x3a00 <__addsf3+0x18>
    39f8:	31 f4       	brne	.+12     	; 0x3a06 <__addsf3+0x1e>
    39fa:	9f 3f       	cpi	r25, 0xFF	; 255
    39fc:	11 f4       	brne	.+4      	; 0x3a02 <__addsf3+0x1a>
    39fe:	1e f4       	brtc	.+6      	; 0x3a06 <__addsf3+0x1e>
    3a00:	33 c1       	rjmp	.+614    	; 0x3c68 <__fp_nan>
    3a02:	0e f4       	brtc	.+2      	; 0x3a06 <__addsf3+0x1e>
    3a04:	e0 95       	com	r30
    3a06:	e7 fb       	bst	r30, 7
    3a08:	29 c1       	rjmp	.+594    	; 0x3c5c <__fp_inf>

00003a0a <__addsf3x>:
    3a0a:	e9 2f       	mov	r30, r25
    3a0c:	4f d1       	rcall	.+670    	; 0x3cac <__fp_split3>
    3a0e:	80 f3       	brcs	.-32     	; 0x39f0 <__addsf3+0x8>
    3a10:	ba 17       	cp	r27, r26
    3a12:	62 07       	cpc	r22, r18
    3a14:	73 07       	cpc	r23, r19
    3a16:	84 07       	cpc	r24, r20
    3a18:	95 07       	cpc	r25, r21
    3a1a:	18 f0       	brcs	.+6      	; 0x3a22 <__addsf3x+0x18>
    3a1c:	71 f4       	brne	.+28     	; 0x3a3a <__addsf3x+0x30>
    3a1e:	9e f5       	brtc	.+102    	; 0x3a86 <__addsf3x+0x7c>
    3a20:	67 c1       	rjmp	.+718    	; 0x3cf0 <__fp_zero>
    3a22:	0e f4       	brtc	.+2      	; 0x3a26 <__addsf3x+0x1c>
    3a24:	e0 95       	com	r30
    3a26:	0b 2e       	mov	r0, r27
    3a28:	ba 2f       	mov	r27, r26
    3a2a:	a0 2d       	mov	r26, r0
    3a2c:	0b 01       	movw	r0, r22
    3a2e:	b9 01       	movw	r22, r18
    3a30:	90 01       	movw	r18, r0
    3a32:	0c 01       	movw	r0, r24
    3a34:	ca 01       	movw	r24, r20
    3a36:	a0 01       	movw	r20, r0
    3a38:	11 24       	eor	r1, r1
    3a3a:	ff 27       	eor	r31, r31
    3a3c:	59 1b       	sub	r21, r25
    3a3e:	99 f0       	breq	.+38     	; 0x3a66 <__addsf3x+0x5c>
    3a40:	59 3f       	cpi	r21, 0xF9	; 249
    3a42:	50 f4       	brcc	.+20     	; 0x3a58 <__addsf3x+0x4e>
    3a44:	50 3e       	cpi	r21, 0xE0	; 224
    3a46:	68 f1       	brcs	.+90     	; 0x3aa2 <__addsf3x+0x98>
    3a48:	1a 16       	cp	r1, r26
    3a4a:	f0 40       	sbci	r31, 0x00	; 0
    3a4c:	a2 2f       	mov	r26, r18
    3a4e:	23 2f       	mov	r18, r19
    3a50:	34 2f       	mov	r19, r20
    3a52:	44 27       	eor	r20, r20
    3a54:	58 5f       	subi	r21, 0xF8	; 248
    3a56:	f3 cf       	rjmp	.-26     	; 0x3a3e <__addsf3x+0x34>
    3a58:	46 95       	lsr	r20
    3a5a:	37 95       	ror	r19
    3a5c:	27 95       	ror	r18
    3a5e:	a7 95       	ror	r26
    3a60:	f0 40       	sbci	r31, 0x00	; 0
    3a62:	53 95       	inc	r21
    3a64:	c9 f7       	brne	.-14     	; 0x3a58 <__addsf3x+0x4e>
    3a66:	7e f4       	brtc	.+30     	; 0x3a86 <__addsf3x+0x7c>
    3a68:	1f 16       	cp	r1, r31
    3a6a:	ba 0b       	sbc	r27, r26
    3a6c:	62 0b       	sbc	r22, r18
    3a6e:	73 0b       	sbc	r23, r19
    3a70:	84 0b       	sbc	r24, r20
    3a72:	ba f0       	brmi	.+46     	; 0x3aa2 <__addsf3x+0x98>
    3a74:	91 50       	subi	r25, 0x01	; 1
    3a76:	a1 f0       	breq	.+40     	; 0x3aa0 <__addsf3x+0x96>
    3a78:	ff 0f       	add	r31, r31
    3a7a:	bb 1f       	adc	r27, r27
    3a7c:	66 1f       	adc	r22, r22
    3a7e:	77 1f       	adc	r23, r23
    3a80:	88 1f       	adc	r24, r24
    3a82:	c2 f7       	brpl	.-16     	; 0x3a74 <__addsf3x+0x6a>
    3a84:	0e c0       	rjmp	.+28     	; 0x3aa2 <__addsf3x+0x98>
    3a86:	ba 0f       	add	r27, r26
    3a88:	62 1f       	adc	r22, r18
    3a8a:	73 1f       	adc	r23, r19
    3a8c:	84 1f       	adc	r24, r20
    3a8e:	48 f4       	brcc	.+18     	; 0x3aa2 <__addsf3x+0x98>
    3a90:	87 95       	ror	r24
    3a92:	77 95       	ror	r23
    3a94:	67 95       	ror	r22
    3a96:	b7 95       	ror	r27
    3a98:	f7 95       	ror	r31
    3a9a:	9e 3f       	cpi	r25, 0xFE	; 254
    3a9c:	08 f0       	brcs	.+2      	; 0x3aa0 <__addsf3x+0x96>
    3a9e:	b3 cf       	rjmp	.-154    	; 0x3a06 <__addsf3+0x1e>
    3aa0:	93 95       	inc	r25
    3aa2:	88 0f       	add	r24, r24
    3aa4:	08 f0       	brcs	.+2      	; 0x3aa8 <__addsf3x+0x9e>
    3aa6:	99 27       	eor	r25, r25
    3aa8:	ee 0f       	add	r30, r30
    3aaa:	97 95       	ror	r25
    3aac:	87 95       	ror	r24
    3aae:	08 95       	ret

00003ab0 <__divsf3>:
    3ab0:	0c d0       	rcall	.+24     	; 0x3aca <__divsf3x>
    3ab2:	eb c0       	rjmp	.+470    	; 0x3c8a <__fp_round>
    3ab4:	e3 d0       	rcall	.+454    	; 0x3c7c <__fp_pscB>
    3ab6:	40 f0       	brcs	.+16     	; 0x3ac8 <__divsf3+0x18>
    3ab8:	da d0       	rcall	.+436    	; 0x3c6e <__fp_pscA>
    3aba:	30 f0       	brcs	.+12     	; 0x3ac8 <__divsf3+0x18>
    3abc:	21 f4       	brne	.+8      	; 0x3ac6 <__divsf3+0x16>
    3abe:	5f 3f       	cpi	r21, 0xFF	; 255
    3ac0:	19 f0       	breq	.+6      	; 0x3ac8 <__divsf3+0x18>
    3ac2:	cc c0       	rjmp	.+408    	; 0x3c5c <__fp_inf>
    3ac4:	51 11       	cpse	r21, r1
    3ac6:	15 c1       	rjmp	.+554    	; 0x3cf2 <__fp_szero>
    3ac8:	cf c0       	rjmp	.+414    	; 0x3c68 <__fp_nan>

00003aca <__divsf3x>:
    3aca:	f0 d0       	rcall	.+480    	; 0x3cac <__fp_split3>
    3acc:	98 f3       	brcs	.-26     	; 0x3ab4 <__divsf3+0x4>

00003ace <__divsf3_pse>:
    3ace:	99 23       	and	r25, r25
    3ad0:	c9 f3       	breq	.-14     	; 0x3ac4 <__divsf3+0x14>
    3ad2:	55 23       	and	r21, r21
    3ad4:	b1 f3       	breq	.-20     	; 0x3ac2 <__divsf3+0x12>
    3ad6:	95 1b       	sub	r25, r21
    3ad8:	55 0b       	sbc	r21, r21
    3ada:	bb 27       	eor	r27, r27
    3adc:	aa 27       	eor	r26, r26
    3ade:	62 17       	cp	r22, r18
    3ae0:	73 07       	cpc	r23, r19
    3ae2:	84 07       	cpc	r24, r20
    3ae4:	38 f0       	brcs	.+14     	; 0x3af4 <__divsf3_pse+0x26>
    3ae6:	9f 5f       	subi	r25, 0xFF	; 255
    3ae8:	5f 4f       	sbci	r21, 0xFF	; 255
    3aea:	22 0f       	add	r18, r18
    3aec:	33 1f       	adc	r19, r19
    3aee:	44 1f       	adc	r20, r20
    3af0:	aa 1f       	adc	r26, r26
    3af2:	a9 f3       	breq	.-22     	; 0x3ade <__divsf3_pse+0x10>
    3af4:	33 d0       	rcall	.+102    	; 0x3b5c <__divsf3_pse+0x8e>
    3af6:	0e 2e       	mov	r0, r30
    3af8:	3a f0       	brmi	.+14     	; 0x3b08 <__divsf3_pse+0x3a>
    3afa:	e0 e8       	ldi	r30, 0x80	; 128
    3afc:	30 d0       	rcall	.+96     	; 0x3b5e <__divsf3_pse+0x90>
    3afe:	91 50       	subi	r25, 0x01	; 1
    3b00:	50 40       	sbci	r21, 0x00	; 0
    3b02:	e6 95       	lsr	r30
    3b04:	00 1c       	adc	r0, r0
    3b06:	ca f7       	brpl	.-14     	; 0x3afa <__divsf3_pse+0x2c>
    3b08:	29 d0       	rcall	.+82     	; 0x3b5c <__divsf3_pse+0x8e>
    3b0a:	fe 2f       	mov	r31, r30
    3b0c:	27 d0       	rcall	.+78     	; 0x3b5c <__divsf3_pse+0x8e>
    3b0e:	66 0f       	add	r22, r22
    3b10:	77 1f       	adc	r23, r23
    3b12:	88 1f       	adc	r24, r24
    3b14:	bb 1f       	adc	r27, r27
    3b16:	26 17       	cp	r18, r22
    3b18:	37 07       	cpc	r19, r23
    3b1a:	48 07       	cpc	r20, r24
    3b1c:	ab 07       	cpc	r26, r27
    3b1e:	b0 e8       	ldi	r27, 0x80	; 128
    3b20:	09 f0       	breq	.+2      	; 0x3b24 <__divsf3_pse+0x56>
    3b22:	bb 0b       	sbc	r27, r27
    3b24:	80 2d       	mov	r24, r0
    3b26:	bf 01       	movw	r22, r30
    3b28:	ff 27       	eor	r31, r31
    3b2a:	93 58       	subi	r25, 0x83	; 131
    3b2c:	5f 4f       	sbci	r21, 0xFF	; 255
    3b2e:	2a f0       	brmi	.+10     	; 0x3b3a <__divsf3_pse+0x6c>
    3b30:	9e 3f       	cpi	r25, 0xFE	; 254
    3b32:	51 05       	cpc	r21, r1
    3b34:	68 f0       	brcs	.+26     	; 0x3b50 <__divsf3_pse+0x82>
    3b36:	92 c0       	rjmp	.+292    	; 0x3c5c <__fp_inf>
    3b38:	dc c0       	rjmp	.+440    	; 0x3cf2 <__fp_szero>
    3b3a:	5f 3f       	cpi	r21, 0xFF	; 255
    3b3c:	ec f3       	brlt	.-6      	; 0x3b38 <__divsf3_pse+0x6a>
    3b3e:	98 3e       	cpi	r25, 0xE8	; 232
    3b40:	dc f3       	brlt	.-10     	; 0x3b38 <__divsf3_pse+0x6a>
    3b42:	86 95       	lsr	r24
    3b44:	77 95       	ror	r23
    3b46:	67 95       	ror	r22
    3b48:	b7 95       	ror	r27
    3b4a:	f7 95       	ror	r31
    3b4c:	9f 5f       	subi	r25, 0xFF	; 255
    3b4e:	c9 f7       	brne	.-14     	; 0x3b42 <__divsf3_pse+0x74>
    3b50:	88 0f       	add	r24, r24
    3b52:	91 1d       	adc	r25, r1
    3b54:	96 95       	lsr	r25
    3b56:	87 95       	ror	r24
    3b58:	97 f9       	bld	r25, 7
    3b5a:	08 95       	ret
    3b5c:	e1 e0       	ldi	r30, 0x01	; 1
    3b5e:	66 0f       	add	r22, r22
    3b60:	77 1f       	adc	r23, r23
    3b62:	88 1f       	adc	r24, r24
    3b64:	bb 1f       	adc	r27, r27
    3b66:	62 17       	cp	r22, r18
    3b68:	73 07       	cpc	r23, r19
    3b6a:	84 07       	cpc	r24, r20
    3b6c:	ba 07       	cpc	r27, r26
    3b6e:	20 f0       	brcs	.+8      	; 0x3b78 <__divsf3_pse+0xaa>
    3b70:	62 1b       	sub	r22, r18
    3b72:	73 0b       	sbc	r23, r19
    3b74:	84 0b       	sbc	r24, r20
    3b76:	ba 0b       	sbc	r27, r26
    3b78:	ee 1f       	adc	r30, r30
    3b7a:	88 f7       	brcc	.-30     	; 0x3b5e <__divsf3_pse+0x90>
    3b7c:	e0 95       	com	r30
    3b7e:	08 95       	ret

00003b80 <__fixsfsi>:
    3b80:	04 d0       	rcall	.+8      	; 0x3b8a <__fixunssfsi>
    3b82:	68 94       	set
    3b84:	b1 11       	cpse	r27, r1
    3b86:	b5 c0       	rjmp	.+362    	; 0x3cf2 <__fp_szero>
    3b88:	08 95       	ret

00003b8a <__fixunssfsi>:
    3b8a:	98 d0       	rcall	.+304    	; 0x3cbc <__fp_splitA>
    3b8c:	88 f0       	brcs	.+34     	; 0x3bb0 <__fixunssfsi+0x26>
    3b8e:	9f 57       	subi	r25, 0x7F	; 127
    3b90:	90 f0       	brcs	.+36     	; 0x3bb6 <__fixunssfsi+0x2c>
    3b92:	b9 2f       	mov	r27, r25
    3b94:	99 27       	eor	r25, r25
    3b96:	b7 51       	subi	r27, 0x17	; 23
    3b98:	a0 f0       	brcs	.+40     	; 0x3bc2 <__fixunssfsi+0x38>
    3b9a:	d1 f0       	breq	.+52     	; 0x3bd0 <__fixunssfsi+0x46>
    3b9c:	66 0f       	add	r22, r22
    3b9e:	77 1f       	adc	r23, r23
    3ba0:	88 1f       	adc	r24, r24
    3ba2:	99 1f       	adc	r25, r25
    3ba4:	1a f0       	brmi	.+6      	; 0x3bac <__fixunssfsi+0x22>
    3ba6:	ba 95       	dec	r27
    3ba8:	c9 f7       	brne	.-14     	; 0x3b9c <__fixunssfsi+0x12>
    3baa:	12 c0       	rjmp	.+36     	; 0x3bd0 <__fixunssfsi+0x46>
    3bac:	b1 30       	cpi	r27, 0x01	; 1
    3bae:	81 f0       	breq	.+32     	; 0x3bd0 <__fixunssfsi+0x46>
    3bb0:	9f d0       	rcall	.+318    	; 0x3cf0 <__fp_zero>
    3bb2:	b1 e0       	ldi	r27, 0x01	; 1
    3bb4:	08 95       	ret
    3bb6:	9c c0       	rjmp	.+312    	; 0x3cf0 <__fp_zero>
    3bb8:	67 2f       	mov	r22, r23
    3bba:	78 2f       	mov	r23, r24
    3bbc:	88 27       	eor	r24, r24
    3bbe:	b8 5f       	subi	r27, 0xF8	; 248
    3bc0:	39 f0       	breq	.+14     	; 0x3bd0 <__fixunssfsi+0x46>
    3bc2:	b9 3f       	cpi	r27, 0xF9	; 249
    3bc4:	cc f3       	brlt	.-14     	; 0x3bb8 <__fixunssfsi+0x2e>
    3bc6:	86 95       	lsr	r24
    3bc8:	77 95       	ror	r23
    3bca:	67 95       	ror	r22
    3bcc:	b3 95       	inc	r27
    3bce:	d9 f7       	brne	.-10     	; 0x3bc6 <__fixunssfsi+0x3c>
    3bd0:	3e f4       	brtc	.+14     	; 0x3be0 <__fixunssfsi+0x56>
    3bd2:	90 95       	com	r25
    3bd4:	80 95       	com	r24
    3bd6:	70 95       	com	r23
    3bd8:	61 95       	neg	r22
    3bda:	7f 4f       	sbci	r23, 0xFF	; 255
    3bdc:	8f 4f       	sbci	r24, 0xFF	; 255
    3bde:	9f 4f       	sbci	r25, 0xFF	; 255
    3be0:	08 95       	ret

00003be2 <__floatunsisf>:
    3be2:	e8 94       	clt
    3be4:	09 c0       	rjmp	.+18     	; 0x3bf8 <__floatsisf+0x12>

00003be6 <__floatsisf>:
    3be6:	97 fb       	bst	r25, 7
    3be8:	3e f4       	brtc	.+14     	; 0x3bf8 <__floatsisf+0x12>
    3bea:	90 95       	com	r25
    3bec:	80 95       	com	r24
    3bee:	70 95       	com	r23
    3bf0:	61 95       	neg	r22
    3bf2:	7f 4f       	sbci	r23, 0xFF	; 255
    3bf4:	8f 4f       	sbci	r24, 0xFF	; 255
    3bf6:	9f 4f       	sbci	r25, 0xFF	; 255
    3bf8:	99 23       	and	r25, r25
    3bfa:	a9 f0       	breq	.+42     	; 0x3c26 <__floatsisf+0x40>
    3bfc:	f9 2f       	mov	r31, r25
    3bfe:	96 e9       	ldi	r25, 0x96	; 150
    3c00:	bb 27       	eor	r27, r27
    3c02:	93 95       	inc	r25
    3c04:	f6 95       	lsr	r31
    3c06:	87 95       	ror	r24
    3c08:	77 95       	ror	r23
    3c0a:	67 95       	ror	r22
    3c0c:	b7 95       	ror	r27
    3c0e:	f1 11       	cpse	r31, r1
    3c10:	f8 cf       	rjmp	.-16     	; 0x3c02 <__floatsisf+0x1c>
    3c12:	fa f4       	brpl	.+62     	; 0x3c52 <__floatsisf+0x6c>
    3c14:	bb 0f       	add	r27, r27
    3c16:	11 f4       	brne	.+4      	; 0x3c1c <__floatsisf+0x36>
    3c18:	60 ff       	sbrs	r22, 0
    3c1a:	1b c0       	rjmp	.+54     	; 0x3c52 <__floatsisf+0x6c>
    3c1c:	6f 5f       	subi	r22, 0xFF	; 255
    3c1e:	7f 4f       	sbci	r23, 0xFF	; 255
    3c20:	8f 4f       	sbci	r24, 0xFF	; 255
    3c22:	9f 4f       	sbci	r25, 0xFF	; 255
    3c24:	16 c0       	rjmp	.+44     	; 0x3c52 <__floatsisf+0x6c>
    3c26:	88 23       	and	r24, r24
    3c28:	11 f0       	breq	.+4      	; 0x3c2e <__floatsisf+0x48>
    3c2a:	96 e9       	ldi	r25, 0x96	; 150
    3c2c:	11 c0       	rjmp	.+34     	; 0x3c50 <__floatsisf+0x6a>
    3c2e:	77 23       	and	r23, r23
    3c30:	21 f0       	breq	.+8      	; 0x3c3a <__floatsisf+0x54>
    3c32:	9e e8       	ldi	r25, 0x8E	; 142
    3c34:	87 2f       	mov	r24, r23
    3c36:	76 2f       	mov	r23, r22
    3c38:	05 c0       	rjmp	.+10     	; 0x3c44 <__floatsisf+0x5e>
    3c3a:	66 23       	and	r22, r22
    3c3c:	71 f0       	breq	.+28     	; 0x3c5a <__floatsisf+0x74>
    3c3e:	96 e8       	ldi	r25, 0x86	; 134
    3c40:	86 2f       	mov	r24, r22
    3c42:	70 e0       	ldi	r23, 0x00	; 0
    3c44:	60 e0       	ldi	r22, 0x00	; 0
    3c46:	2a f0       	brmi	.+10     	; 0x3c52 <__floatsisf+0x6c>
    3c48:	9a 95       	dec	r25
    3c4a:	66 0f       	add	r22, r22
    3c4c:	77 1f       	adc	r23, r23
    3c4e:	88 1f       	adc	r24, r24
    3c50:	da f7       	brpl	.-10     	; 0x3c48 <__floatsisf+0x62>
    3c52:	88 0f       	add	r24, r24
    3c54:	96 95       	lsr	r25
    3c56:	87 95       	ror	r24
    3c58:	97 f9       	bld	r25, 7
    3c5a:	08 95       	ret

00003c5c <__fp_inf>:
    3c5c:	97 f9       	bld	r25, 7
    3c5e:	9f 67       	ori	r25, 0x7F	; 127
    3c60:	80 e8       	ldi	r24, 0x80	; 128
    3c62:	70 e0       	ldi	r23, 0x00	; 0
    3c64:	60 e0       	ldi	r22, 0x00	; 0
    3c66:	08 95       	ret

00003c68 <__fp_nan>:
    3c68:	9f ef       	ldi	r25, 0xFF	; 255
    3c6a:	80 ec       	ldi	r24, 0xC0	; 192
    3c6c:	08 95       	ret

00003c6e <__fp_pscA>:
    3c6e:	00 24       	eor	r0, r0
    3c70:	0a 94       	dec	r0
    3c72:	16 16       	cp	r1, r22
    3c74:	17 06       	cpc	r1, r23
    3c76:	18 06       	cpc	r1, r24
    3c78:	09 06       	cpc	r0, r25
    3c7a:	08 95       	ret

00003c7c <__fp_pscB>:
    3c7c:	00 24       	eor	r0, r0
    3c7e:	0a 94       	dec	r0
    3c80:	12 16       	cp	r1, r18
    3c82:	13 06       	cpc	r1, r19
    3c84:	14 06       	cpc	r1, r20
    3c86:	05 06       	cpc	r0, r21
    3c88:	08 95       	ret

00003c8a <__fp_round>:
    3c8a:	09 2e       	mov	r0, r25
    3c8c:	03 94       	inc	r0
    3c8e:	00 0c       	add	r0, r0
    3c90:	11 f4       	brne	.+4      	; 0x3c96 <__fp_round+0xc>
    3c92:	88 23       	and	r24, r24
    3c94:	52 f0       	brmi	.+20     	; 0x3caa <__fp_round+0x20>
    3c96:	bb 0f       	add	r27, r27
    3c98:	40 f4       	brcc	.+16     	; 0x3caa <__fp_round+0x20>
    3c9a:	bf 2b       	or	r27, r31
    3c9c:	11 f4       	brne	.+4      	; 0x3ca2 <__fp_round+0x18>
    3c9e:	60 ff       	sbrs	r22, 0
    3ca0:	04 c0       	rjmp	.+8      	; 0x3caa <__fp_round+0x20>
    3ca2:	6f 5f       	subi	r22, 0xFF	; 255
    3ca4:	7f 4f       	sbci	r23, 0xFF	; 255
    3ca6:	8f 4f       	sbci	r24, 0xFF	; 255
    3ca8:	9f 4f       	sbci	r25, 0xFF	; 255
    3caa:	08 95       	ret

00003cac <__fp_split3>:
    3cac:	57 fd       	sbrc	r21, 7
    3cae:	90 58       	subi	r25, 0x80	; 128
    3cb0:	44 0f       	add	r20, r20
    3cb2:	55 1f       	adc	r21, r21
    3cb4:	59 f0       	breq	.+22     	; 0x3ccc <__fp_splitA+0x10>
    3cb6:	5f 3f       	cpi	r21, 0xFF	; 255
    3cb8:	71 f0       	breq	.+28     	; 0x3cd6 <__fp_splitA+0x1a>
    3cba:	47 95       	ror	r20

00003cbc <__fp_splitA>:
    3cbc:	88 0f       	add	r24, r24
    3cbe:	97 fb       	bst	r25, 7
    3cc0:	99 1f       	adc	r25, r25
    3cc2:	61 f0       	breq	.+24     	; 0x3cdc <__fp_splitA+0x20>
    3cc4:	9f 3f       	cpi	r25, 0xFF	; 255
    3cc6:	79 f0       	breq	.+30     	; 0x3ce6 <__fp_splitA+0x2a>
    3cc8:	87 95       	ror	r24
    3cca:	08 95       	ret
    3ccc:	12 16       	cp	r1, r18
    3cce:	13 06       	cpc	r1, r19
    3cd0:	14 06       	cpc	r1, r20
    3cd2:	55 1f       	adc	r21, r21
    3cd4:	f2 cf       	rjmp	.-28     	; 0x3cba <__fp_split3+0xe>
    3cd6:	46 95       	lsr	r20
    3cd8:	f1 df       	rcall	.-30     	; 0x3cbc <__fp_splitA>
    3cda:	08 c0       	rjmp	.+16     	; 0x3cec <__fp_splitA+0x30>
    3cdc:	16 16       	cp	r1, r22
    3cde:	17 06       	cpc	r1, r23
    3ce0:	18 06       	cpc	r1, r24
    3ce2:	99 1f       	adc	r25, r25
    3ce4:	f1 cf       	rjmp	.-30     	; 0x3cc8 <__fp_splitA+0xc>
    3ce6:	86 95       	lsr	r24
    3ce8:	71 05       	cpc	r23, r1
    3cea:	61 05       	cpc	r22, r1
    3cec:	08 94       	sec
    3cee:	08 95       	ret

00003cf0 <__fp_zero>:
    3cf0:	e8 94       	clt

00003cf2 <__fp_szero>:
    3cf2:	bb 27       	eor	r27, r27
    3cf4:	66 27       	eor	r22, r22
    3cf6:	77 27       	eor	r23, r23
    3cf8:	cb 01       	movw	r24, r22
    3cfa:	97 f9       	bld	r25, 7
    3cfc:	08 95       	ret

00003cfe <__gesf2>:
    3cfe:	66 d0       	rcall	.+204    	; 0x3dcc <__fp_cmp>
    3d00:	08 f4       	brcc	.+2      	; 0x3d04 <__gesf2+0x6>
    3d02:	8f ef       	ldi	r24, 0xFF	; 255
    3d04:	08 95       	ret

00003d06 <__mulsf3>:
    3d06:	0b d0       	rcall	.+22     	; 0x3d1e <__mulsf3x>
    3d08:	c0 cf       	rjmp	.-128    	; 0x3c8a <__fp_round>
    3d0a:	b1 df       	rcall	.-158    	; 0x3c6e <__fp_pscA>
    3d0c:	28 f0       	brcs	.+10     	; 0x3d18 <__mulsf3+0x12>
    3d0e:	b6 df       	rcall	.-148    	; 0x3c7c <__fp_pscB>
    3d10:	18 f0       	brcs	.+6      	; 0x3d18 <__mulsf3+0x12>
    3d12:	95 23       	and	r25, r21
    3d14:	09 f0       	breq	.+2      	; 0x3d18 <__mulsf3+0x12>
    3d16:	a2 cf       	rjmp	.-188    	; 0x3c5c <__fp_inf>
    3d18:	a7 cf       	rjmp	.-178    	; 0x3c68 <__fp_nan>
    3d1a:	11 24       	eor	r1, r1
    3d1c:	ea cf       	rjmp	.-44     	; 0x3cf2 <__fp_szero>

00003d1e <__mulsf3x>:
    3d1e:	c6 df       	rcall	.-116    	; 0x3cac <__fp_split3>
    3d20:	a0 f3       	brcs	.-24     	; 0x3d0a <__mulsf3+0x4>

00003d22 <__mulsf3_pse>:
    3d22:	95 9f       	mul	r25, r21
    3d24:	d1 f3       	breq	.-12     	; 0x3d1a <__mulsf3+0x14>
    3d26:	95 0f       	add	r25, r21
    3d28:	50 e0       	ldi	r21, 0x00	; 0
    3d2a:	55 1f       	adc	r21, r21
    3d2c:	62 9f       	mul	r22, r18
    3d2e:	f0 01       	movw	r30, r0
    3d30:	72 9f       	mul	r23, r18
    3d32:	bb 27       	eor	r27, r27
    3d34:	f0 0d       	add	r31, r0
    3d36:	b1 1d       	adc	r27, r1
    3d38:	63 9f       	mul	r22, r19
    3d3a:	aa 27       	eor	r26, r26
    3d3c:	f0 0d       	add	r31, r0
    3d3e:	b1 1d       	adc	r27, r1
    3d40:	aa 1f       	adc	r26, r26
    3d42:	64 9f       	mul	r22, r20
    3d44:	66 27       	eor	r22, r22
    3d46:	b0 0d       	add	r27, r0
    3d48:	a1 1d       	adc	r26, r1
    3d4a:	66 1f       	adc	r22, r22
    3d4c:	82 9f       	mul	r24, r18
    3d4e:	22 27       	eor	r18, r18
    3d50:	b0 0d       	add	r27, r0
    3d52:	a1 1d       	adc	r26, r1
    3d54:	62 1f       	adc	r22, r18
    3d56:	73 9f       	mul	r23, r19
    3d58:	b0 0d       	add	r27, r0
    3d5a:	a1 1d       	adc	r26, r1
    3d5c:	62 1f       	adc	r22, r18
    3d5e:	83 9f       	mul	r24, r19
    3d60:	a0 0d       	add	r26, r0
    3d62:	61 1d       	adc	r22, r1
    3d64:	22 1f       	adc	r18, r18
    3d66:	74 9f       	mul	r23, r20
    3d68:	33 27       	eor	r19, r19
    3d6a:	a0 0d       	add	r26, r0
    3d6c:	61 1d       	adc	r22, r1
    3d6e:	23 1f       	adc	r18, r19
    3d70:	84 9f       	mul	r24, r20
    3d72:	60 0d       	add	r22, r0
    3d74:	21 1d       	adc	r18, r1
    3d76:	82 2f       	mov	r24, r18
    3d78:	76 2f       	mov	r23, r22
    3d7a:	6a 2f       	mov	r22, r26
    3d7c:	11 24       	eor	r1, r1
    3d7e:	9f 57       	subi	r25, 0x7F	; 127
    3d80:	50 40       	sbci	r21, 0x00	; 0
    3d82:	8a f0       	brmi	.+34     	; 0x3da6 <__mulsf3_pse+0x84>
    3d84:	e1 f0       	breq	.+56     	; 0x3dbe <__mulsf3_pse+0x9c>
    3d86:	88 23       	and	r24, r24
    3d88:	4a f0       	brmi	.+18     	; 0x3d9c <__mulsf3_pse+0x7a>
    3d8a:	ee 0f       	add	r30, r30
    3d8c:	ff 1f       	adc	r31, r31
    3d8e:	bb 1f       	adc	r27, r27
    3d90:	66 1f       	adc	r22, r22
    3d92:	77 1f       	adc	r23, r23
    3d94:	88 1f       	adc	r24, r24
    3d96:	91 50       	subi	r25, 0x01	; 1
    3d98:	50 40       	sbci	r21, 0x00	; 0
    3d9a:	a9 f7       	brne	.-22     	; 0x3d86 <__mulsf3_pse+0x64>
    3d9c:	9e 3f       	cpi	r25, 0xFE	; 254
    3d9e:	51 05       	cpc	r21, r1
    3da0:	70 f0       	brcs	.+28     	; 0x3dbe <__mulsf3_pse+0x9c>
    3da2:	5c cf       	rjmp	.-328    	; 0x3c5c <__fp_inf>
    3da4:	a6 cf       	rjmp	.-180    	; 0x3cf2 <__fp_szero>
    3da6:	5f 3f       	cpi	r21, 0xFF	; 255
    3da8:	ec f3       	brlt	.-6      	; 0x3da4 <__mulsf3_pse+0x82>
    3daa:	98 3e       	cpi	r25, 0xE8	; 232
    3dac:	dc f3       	brlt	.-10     	; 0x3da4 <__mulsf3_pse+0x82>
    3dae:	86 95       	lsr	r24
    3db0:	77 95       	ror	r23
    3db2:	67 95       	ror	r22
    3db4:	b7 95       	ror	r27
    3db6:	f7 95       	ror	r31
    3db8:	e7 95       	ror	r30
    3dba:	9f 5f       	subi	r25, 0xFF	; 255
    3dbc:	c1 f7       	brne	.-16     	; 0x3dae <__mulsf3_pse+0x8c>
    3dbe:	fe 2b       	or	r31, r30
    3dc0:	88 0f       	add	r24, r24
    3dc2:	91 1d       	adc	r25, r1
    3dc4:	96 95       	lsr	r25
    3dc6:	87 95       	ror	r24
    3dc8:	97 f9       	bld	r25, 7
    3dca:	08 95       	ret

00003dcc <__fp_cmp>:
    3dcc:	99 0f       	add	r25, r25
    3dce:	00 08       	sbc	r0, r0
    3dd0:	55 0f       	add	r21, r21
    3dd2:	aa 0b       	sbc	r26, r26
    3dd4:	e0 e8       	ldi	r30, 0x80	; 128
    3dd6:	fe ef       	ldi	r31, 0xFE	; 254
    3dd8:	16 16       	cp	r1, r22
    3dda:	17 06       	cpc	r1, r23
    3ddc:	e8 07       	cpc	r30, r24
    3dde:	f9 07       	cpc	r31, r25
    3de0:	c0 f0       	brcs	.+48     	; 0x3e12 <__fp_cmp+0x46>
    3de2:	12 16       	cp	r1, r18
    3de4:	13 06       	cpc	r1, r19
    3de6:	e4 07       	cpc	r30, r20
    3de8:	f5 07       	cpc	r31, r21
    3dea:	98 f0       	brcs	.+38     	; 0x3e12 <__fp_cmp+0x46>
    3dec:	62 1b       	sub	r22, r18
    3dee:	73 0b       	sbc	r23, r19
    3df0:	84 0b       	sbc	r24, r20
    3df2:	95 0b       	sbc	r25, r21
    3df4:	39 f4       	brne	.+14     	; 0x3e04 <__fp_cmp+0x38>
    3df6:	0a 26       	eor	r0, r26
    3df8:	61 f0       	breq	.+24     	; 0x3e12 <__fp_cmp+0x46>
    3dfa:	23 2b       	or	r18, r19
    3dfc:	24 2b       	or	r18, r20
    3dfe:	25 2b       	or	r18, r21
    3e00:	21 f4       	brne	.+8      	; 0x3e0a <__fp_cmp+0x3e>
    3e02:	08 95       	ret
    3e04:	0a 26       	eor	r0, r26
    3e06:	09 f4       	brne	.+2      	; 0x3e0a <__fp_cmp+0x3e>
    3e08:	a1 40       	sbci	r26, 0x01	; 1
    3e0a:	a6 95       	lsr	r26
    3e0c:	8f ef       	ldi	r24, 0xFF	; 255
    3e0e:	81 1d       	adc	r24, r1
    3e10:	81 1d       	adc	r24, r1
    3e12:	08 95       	ret

00003e14 <__divmodhi4>:
    3e14:	97 fb       	bst	r25, 7
    3e16:	07 2e       	mov	r0, r23
    3e18:	16 f4       	brtc	.+4      	; 0x3e1e <__divmodhi4+0xa>
    3e1a:	00 94       	com	r0
    3e1c:	06 d0       	rcall	.+12     	; 0x3e2a <__divmodhi4_neg1>
    3e1e:	77 fd       	sbrc	r23, 7
    3e20:	08 d0       	rcall	.+16     	; 0x3e32 <__divmodhi4_neg2>
    3e22:	35 d0       	rcall	.+106    	; 0x3e8e <__udivmodhi4>
    3e24:	07 fc       	sbrc	r0, 7
    3e26:	05 d0       	rcall	.+10     	; 0x3e32 <__divmodhi4_neg2>
    3e28:	3e f4       	brtc	.+14     	; 0x3e38 <__divmodhi4_exit>

00003e2a <__divmodhi4_neg1>:
    3e2a:	90 95       	com	r25
    3e2c:	81 95       	neg	r24
    3e2e:	9f 4f       	sbci	r25, 0xFF	; 255
    3e30:	08 95       	ret

00003e32 <__divmodhi4_neg2>:
    3e32:	70 95       	com	r23
    3e34:	61 95       	neg	r22
    3e36:	7f 4f       	sbci	r23, 0xFF	; 255

00003e38 <__divmodhi4_exit>:
    3e38:	08 95       	ret

00003e3a <__udivmodsi4>:
    3e3a:	a1 e2       	ldi	r26, 0x21	; 33
    3e3c:	1a 2e       	mov	r1, r26
    3e3e:	aa 1b       	sub	r26, r26
    3e40:	bb 1b       	sub	r27, r27
    3e42:	fd 01       	movw	r30, r26
    3e44:	0d c0       	rjmp	.+26     	; 0x3e60 <__udivmodsi4_ep>

00003e46 <__udivmodsi4_loop>:
    3e46:	aa 1f       	adc	r26, r26
    3e48:	bb 1f       	adc	r27, r27
    3e4a:	ee 1f       	adc	r30, r30
    3e4c:	ff 1f       	adc	r31, r31
    3e4e:	a2 17       	cp	r26, r18
    3e50:	b3 07       	cpc	r27, r19
    3e52:	e4 07       	cpc	r30, r20
    3e54:	f5 07       	cpc	r31, r21
    3e56:	20 f0       	brcs	.+8      	; 0x3e60 <__udivmodsi4_ep>
    3e58:	a2 1b       	sub	r26, r18
    3e5a:	b3 0b       	sbc	r27, r19
    3e5c:	e4 0b       	sbc	r30, r20
    3e5e:	f5 0b       	sbc	r31, r21

00003e60 <__udivmodsi4_ep>:
    3e60:	66 1f       	adc	r22, r22
    3e62:	77 1f       	adc	r23, r23
    3e64:	88 1f       	adc	r24, r24
    3e66:	99 1f       	adc	r25, r25
    3e68:	1a 94       	dec	r1
    3e6a:	69 f7       	brne	.-38     	; 0x3e46 <__udivmodsi4_loop>
    3e6c:	60 95       	com	r22
    3e6e:	70 95       	com	r23
    3e70:	80 95       	com	r24
    3e72:	90 95       	com	r25
    3e74:	9b 01       	movw	r18, r22
    3e76:	ac 01       	movw	r20, r24
    3e78:	bd 01       	movw	r22, r26
    3e7a:	cf 01       	movw	r24, r30
    3e7c:	08 95       	ret

00003e7e <__tablejump2__>:
    3e7e:	ee 0f       	add	r30, r30
    3e80:	ff 1f       	adc	r31, r31
    3e82:	88 1f       	adc	r24, r24
    3e84:	8b bf       	out	0x3b, r24	; 59
    3e86:	07 90       	elpm	r0, Z+
    3e88:	f6 91       	elpm	r31, Z
    3e8a:	e0 2d       	mov	r30, r0
    3e8c:	19 94       	eijmp

00003e8e <__udivmodhi4>:
    3e8e:	aa 1b       	sub	r26, r26
    3e90:	bb 1b       	sub	r27, r27
    3e92:	51 e1       	ldi	r21, 0x11	; 17
    3e94:	07 c0       	rjmp	.+14     	; 0x3ea4 <__udivmodhi4_ep>

00003e96 <__udivmodhi4_loop>:
    3e96:	aa 1f       	adc	r26, r26
    3e98:	bb 1f       	adc	r27, r27
    3e9a:	a6 17       	cp	r26, r22
    3e9c:	b7 07       	cpc	r27, r23
    3e9e:	10 f0       	brcs	.+4      	; 0x3ea4 <__udivmodhi4_ep>
    3ea0:	a6 1b       	sub	r26, r22
    3ea2:	b7 0b       	sbc	r27, r23

00003ea4 <__udivmodhi4_ep>:
    3ea4:	88 1f       	adc	r24, r24
    3ea6:	99 1f       	adc	r25, r25
    3ea8:	5a 95       	dec	r21
    3eaa:	a9 f7       	brne	.-22     	; 0x3e96 <__udivmodhi4_loop>
    3eac:	80 95       	com	r24
    3eae:	90 95       	com	r25
    3eb0:	bc 01       	movw	r22, r24
    3eb2:	cd 01       	movw	r24, r26
    3eb4:	08 95       	ret

00003eb6 <malloc>:
    3eb6:	0f 93       	push	r16
    3eb8:	1f 93       	push	r17
    3eba:	cf 93       	push	r28
    3ebc:	df 93       	push	r29
    3ebe:	82 30       	cpi	r24, 0x02	; 2
    3ec0:	91 05       	cpc	r25, r1
    3ec2:	10 f4       	brcc	.+4      	; 0x3ec8 <malloc+0x12>
    3ec4:	82 e0       	ldi	r24, 0x02	; 2
    3ec6:	90 e0       	ldi	r25, 0x00	; 0
    3ec8:	e0 91 33 24 	lds	r30, 0x2433	; 0x802433 <__flp>
    3ecc:	f0 91 34 24 	lds	r31, 0x2434	; 0x802434 <__flp+0x1>
    3ed0:	20 e0       	ldi	r18, 0x00	; 0
    3ed2:	30 e0       	ldi	r19, 0x00	; 0
    3ed4:	a0 e0       	ldi	r26, 0x00	; 0
    3ed6:	b0 e0       	ldi	r27, 0x00	; 0
    3ed8:	30 97       	sbiw	r30, 0x00	; 0
    3eda:	19 f1       	breq	.+70     	; 0x3f22 <malloc+0x6c>
    3edc:	40 81       	ld	r20, Z
    3ede:	51 81       	ldd	r21, Z+1	; 0x01
    3ee0:	02 81       	ldd	r16, Z+2	; 0x02
    3ee2:	13 81       	ldd	r17, Z+3	; 0x03
    3ee4:	48 17       	cp	r20, r24
    3ee6:	59 07       	cpc	r21, r25
    3ee8:	c8 f0       	brcs	.+50     	; 0x3f1c <malloc+0x66>
    3eea:	84 17       	cp	r24, r20
    3eec:	95 07       	cpc	r25, r21
    3eee:	69 f4       	brne	.+26     	; 0x3f0a <malloc+0x54>
    3ef0:	10 97       	sbiw	r26, 0x00	; 0
    3ef2:	31 f0       	breq	.+12     	; 0x3f00 <malloc+0x4a>
    3ef4:	12 96       	adiw	r26, 0x02	; 2
    3ef6:	0c 93       	st	X, r16
    3ef8:	12 97       	sbiw	r26, 0x02	; 2
    3efa:	13 96       	adiw	r26, 0x03	; 3
    3efc:	1c 93       	st	X, r17
    3efe:	27 c0       	rjmp	.+78     	; 0x3f4e <malloc+0x98>
    3f00:	00 93 33 24 	sts	0x2433, r16	; 0x802433 <__flp>
    3f04:	10 93 34 24 	sts	0x2434, r17	; 0x802434 <__flp+0x1>
    3f08:	22 c0       	rjmp	.+68     	; 0x3f4e <malloc+0x98>
    3f0a:	21 15       	cp	r18, r1
    3f0c:	31 05       	cpc	r19, r1
    3f0e:	19 f0       	breq	.+6      	; 0x3f16 <malloc+0x60>
    3f10:	42 17       	cp	r20, r18
    3f12:	53 07       	cpc	r21, r19
    3f14:	18 f4       	brcc	.+6      	; 0x3f1c <malloc+0x66>
    3f16:	9a 01       	movw	r18, r20
    3f18:	bd 01       	movw	r22, r26
    3f1a:	ef 01       	movw	r28, r30
    3f1c:	df 01       	movw	r26, r30
    3f1e:	f8 01       	movw	r30, r16
    3f20:	db cf       	rjmp	.-74     	; 0x3ed8 <malloc+0x22>
    3f22:	21 15       	cp	r18, r1
    3f24:	31 05       	cpc	r19, r1
    3f26:	f9 f0       	breq	.+62     	; 0x3f66 <malloc+0xb0>
    3f28:	28 1b       	sub	r18, r24
    3f2a:	39 0b       	sbc	r19, r25
    3f2c:	24 30       	cpi	r18, 0x04	; 4
    3f2e:	31 05       	cpc	r19, r1
    3f30:	80 f4       	brcc	.+32     	; 0x3f52 <malloc+0x9c>
    3f32:	8a 81       	ldd	r24, Y+2	; 0x02
    3f34:	9b 81       	ldd	r25, Y+3	; 0x03
    3f36:	61 15       	cp	r22, r1
    3f38:	71 05       	cpc	r23, r1
    3f3a:	21 f0       	breq	.+8      	; 0x3f44 <malloc+0x8e>
    3f3c:	fb 01       	movw	r30, r22
    3f3e:	82 83       	std	Z+2, r24	; 0x02
    3f40:	93 83       	std	Z+3, r25	; 0x03
    3f42:	04 c0       	rjmp	.+8      	; 0x3f4c <malloc+0x96>
    3f44:	80 93 33 24 	sts	0x2433, r24	; 0x802433 <__flp>
    3f48:	90 93 34 24 	sts	0x2434, r25	; 0x802434 <__flp+0x1>
    3f4c:	fe 01       	movw	r30, r28
    3f4e:	32 96       	adiw	r30, 0x02	; 2
    3f50:	44 c0       	rjmp	.+136    	; 0x3fda <malloc+0x124>
    3f52:	fe 01       	movw	r30, r28
    3f54:	e2 0f       	add	r30, r18
    3f56:	f3 1f       	adc	r31, r19
    3f58:	81 93       	st	Z+, r24
    3f5a:	91 93       	st	Z+, r25
    3f5c:	22 50       	subi	r18, 0x02	; 2
    3f5e:	31 09       	sbc	r19, r1
    3f60:	28 83       	st	Y, r18
    3f62:	39 83       	std	Y+1, r19	; 0x01
    3f64:	3a c0       	rjmp	.+116    	; 0x3fda <malloc+0x124>
    3f66:	20 91 31 24 	lds	r18, 0x2431	; 0x802431 <__brkval>
    3f6a:	30 91 32 24 	lds	r19, 0x2432	; 0x802432 <__brkval+0x1>
    3f6e:	23 2b       	or	r18, r19
    3f70:	41 f4       	brne	.+16     	; 0x3f82 <malloc+0xcc>
    3f72:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    3f76:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    3f7a:	20 93 31 24 	sts	0x2431, r18	; 0x802431 <__brkval>
    3f7e:	30 93 32 24 	sts	0x2432, r19	; 0x802432 <__brkval+0x1>
    3f82:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    3f86:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    3f8a:	21 15       	cp	r18, r1
    3f8c:	31 05       	cpc	r19, r1
    3f8e:	41 f4       	brne	.+16     	; 0x3fa0 <malloc+0xea>
    3f90:	2d b7       	in	r18, 0x3d	; 61
    3f92:	3e b7       	in	r19, 0x3e	; 62
    3f94:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    3f98:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    3f9c:	24 1b       	sub	r18, r20
    3f9e:	35 0b       	sbc	r19, r21
    3fa0:	e0 91 31 24 	lds	r30, 0x2431	; 0x802431 <__brkval>
    3fa4:	f0 91 32 24 	lds	r31, 0x2432	; 0x802432 <__brkval+0x1>
    3fa8:	e2 17       	cp	r30, r18
    3faa:	f3 07       	cpc	r31, r19
    3fac:	a0 f4       	brcc	.+40     	; 0x3fd6 <malloc+0x120>
    3fae:	2e 1b       	sub	r18, r30
    3fb0:	3f 0b       	sbc	r19, r31
    3fb2:	28 17       	cp	r18, r24
    3fb4:	39 07       	cpc	r19, r25
    3fb6:	78 f0       	brcs	.+30     	; 0x3fd6 <malloc+0x120>
    3fb8:	ac 01       	movw	r20, r24
    3fba:	4e 5f       	subi	r20, 0xFE	; 254
    3fbc:	5f 4f       	sbci	r21, 0xFF	; 255
    3fbe:	24 17       	cp	r18, r20
    3fc0:	35 07       	cpc	r19, r21
    3fc2:	48 f0       	brcs	.+18     	; 0x3fd6 <malloc+0x120>
    3fc4:	4e 0f       	add	r20, r30
    3fc6:	5f 1f       	adc	r21, r31
    3fc8:	40 93 31 24 	sts	0x2431, r20	; 0x802431 <__brkval>
    3fcc:	50 93 32 24 	sts	0x2432, r21	; 0x802432 <__brkval+0x1>
    3fd0:	81 93       	st	Z+, r24
    3fd2:	91 93       	st	Z+, r25
    3fd4:	02 c0       	rjmp	.+4      	; 0x3fda <malloc+0x124>
    3fd6:	e0 e0       	ldi	r30, 0x00	; 0
    3fd8:	f0 e0       	ldi	r31, 0x00	; 0
    3fda:	cf 01       	movw	r24, r30
    3fdc:	df 91       	pop	r29
    3fde:	cf 91       	pop	r28
    3fe0:	1f 91       	pop	r17
    3fe2:	0f 91       	pop	r16
    3fe4:	08 95       	ret

00003fe6 <free>:
    3fe6:	cf 93       	push	r28
    3fe8:	df 93       	push	r29
    3fea:	00 97       	sbiw	r24, 0x00	; 0
    3fec:	09 f4       	brne	.+2      	; 0x3ff0 <free+0xa>
    3fee:	81 c0       	rjmp	.+258    	; 0x40f2 <free+0x10c>
    3ff0:	fc 01       	movw	r30, r24
    3ff2:	32 97       	sbiw	r30, 0x02	; 2
    3ff4:	12 82       	std	Z+2, r1	; 0x02
    3ff6:	13 82       	std	Z+3, r1	; 0x03
    3ff8:	a0 91 33 24 	lds	r26, 0x2433	; 0x802433 <__flp>
    3ffc:	b0 91 34 24 	lds	r27, 0x2434	; 0x802434 <__flp+0x1>
    4000:	10 97       	sbiw	r26, 0x00	; 0
    4002:	81 f4       	brne	.+32     	; 0x4024 <free+0x3e>
    4004:	20 81       	ld	r18, Z
    4006:	31 81       	ldd	r19, Z+1	; 0x01
    4008:	82 0f       	add	r24, r18
    400a:	93 1f       	adc	r25, r19
    400c:	20 91 31 24 	lds	r18, 0x2431	; 0x802431 <__brkval>
    4010:	30 91 32 24 	lds	r19, 0x2432	; 0x802432 <__brkval+0x1>
    4014:	28 17       	cp	r18, r24
    4016:	39 07       	cpc	r19, r25
    4018:	51 f5       	brne	.+84     	; 0x406e <free+0x88>
    401a:	e0 93 31 24 	sts	0x2431, r30	; 0x802431 <__brkval>
    401e:	f0 93 32 24 	sts	0x2432, r31	; 0x802432 <__brkval+0x1>
    4022:	67 c0       	rjmp	.+206    	; 0x40f2 <free+0x10c>
    4024:	ed 01       	movw	r28, r26
    4026:	20 e0       	ldi	r18, 0x00	; 0
    4028:	30 e0       	ldi	r19, 0x00	; 0
    402a:	ce 17       	cp	r28, r30
    402c:	df 07       	cpc	r29, r31
    402e:	40 f4       	brcc	.+16     	; 0x4040 <free+0x5a>
    4030:	4a 81       	ldd	r20, Y+2	; 0x02
    4032:	5b 81       	ldd	r21, Y+3	; 0x03
    4034:	9e 01       	movw	r18, r28
    4036:	41 15       	cp	r20, r1
    4038:	51 05       	cpc	r21, r1
    403a:	f1 f0       	breq	.+60     	; 0x4078 <free+0x92>
    403c:	ea 01       	movw	r28, r20
    403e:	f5 cf       	rjmp	.-22     	; 0x402a <free+0x44>
    4040:	c2 83       	std	Z+2, r28	; 0x02
    4042:	d3 83       	std	Z+3, r29	; 0x03
    4044:	40 81       	ld	r20, Z
    4046:	51 81       	ldd	r21, Z+1	; 0x01
    4048:	84 0f       	add	r24, r20
    404a:	95 1f       	adc	r25, r21
    404c:	c8 17       	cp	r28, r24
    404e:	d9 07       	cpc	r29, r25
    4050:	59 f4       	brne	.+22     	; 0x4068 <free+0x82>
    4052:	88 81       	ld	r24, Y
    4054:	99 81       	ldd	r25, Y+1	; 0x01
    4056:	84 0f       	add	r24, r20
    4058:	95 1f       	adc	r25, r21
    405a:	02 96       	adiw	r24, 0x02	; 2
    405c:	80 83       	st	Z, r24
    405e:	91 83       	std	Z+1, r25	; 0x01
    4060:	8a 81       	ldd	r24, Y+2	; 0x02
    4062:	9b 81       	ldd	r25, Y+3	; 0x03
    4064:	82 83       	std	Z+2, r24	; 0x02
    4066:	93 83       	std	Z+3, r25	; 0x03
    4068:	21 15       	cp	r18, r1
    406a:	31 05       	cpc	r19, r1
    406c:	29 f4       	brne	.+10     	; 0x4078 <free+0x92>
    406e:	e0 93 33 24 	sts	0x2433, r30	; 0x802433 <__flp>
    4072:	f0 93 34 24 	sts	0x2434, r31	; 0x802434 <__flp+0x1>
    4076:	3d c0       	rjmp	.+122    	; 0x40f2 <free+0x10c>
    4078:	e9 01       	movw	r28, r18
    407a:	ea 83       	std	Y+2, r30	; 0x02
    407c:	fb 83       	std	Y+3, r31	; 0x03
    407e:	49 91       	ld	r20, Y+
    4080:	59 91       	ld	r21, Y+
    4082:	c4 0f       	add	r28, r20
    4084:	d5 1f       	adc	r29, r21
    4086:	ec 17       	cp	r30, r28
    4088:	fd 07       	cpc	r31, r29
    408a:	61 f4       	brne	.+24     	; 0x40a4 <free+0xbe>
    408c:	80 81       	ld	r24, Z
    408e:	91 81       	ldd	r25, Z+1	; 0x01
    4090:	84 0f       	add	r24, r20
    4092:	95 1f       	adc	r25, r21
    4094:	02 96       	adiw	r24, 0x02	; 2
    4096:	e9 01       	movw	r28, r18
    4098:	88 83       	st	Y, r24
    409a:	99 83       	std	Y+1, r25	; 0x01
    409c:	82 81       	ldd	r24, Z+2	; 0x02
    409e:	93 81       	ldd	r25, Z+3	; 0x03
    40a0:	8a 83       	std	Y+2, r24	; 0x02
    40a2:	9b 83       	std	Y+3, r25	; 0x03
    40a4:	e0 e0       	ldi	r30, 0x00	; 0
    40a6:	f0 e0       	ldi	r31, 0x00	; 0
    40a8:	12 96       	adiw	r26, 0x02	; 2
    40aa:	8d 91       	ld	r24, X+
    40ac:	9c 91       	ld	r25, X
    40ae:	13 97       	sbiw	r26, 0x03	; 3
    40b0:	00 97       	sbiw	r24, 0x00	; 0
    40b2:	19 f0       	breq	.+6      	; 0x40ba <free+0xd4>
    40b4:	fd 01       	movw	r30, r26
    40b6:	dc 01       	movw	r26, r24
    40b8:	f7 cf       	rjmp	.-18     	; 0x40a8 <free+0xc2>
    40ba:	8d 91       	ld	r24, X+
    40bc:	9c 91       	ld	r25, X
    40be:	11 97       	sbiw	r26, 0x01	; 1
    40c0:	9d 01       	movw	r18, r26
    40c2:	2e 5f       	subi	r18, 0xFE	; 254
    40c4:	3f 4f       	sbci	r19, 0xFF	; 255
    40c6:	82 0f       	add	r24, r18
    40c8:	93 1f       	adc	r25, r19
    40ca:	20 91 31 24 	lds	r18, 0x2431	; 0x802431 <__brkval>
    40ce:	30 91 32 24 	lds	r19, 0x2432	; 0x802432 <__brkval+0x1>
    40d2:	28 17       	cp	r18, r24
    40d4:	39 07       	cpc	r19, r25
    40d6:	69 f4       	brne	.+26     	; 0x40f2 <free+0x10c>
    40d8:	30 97       	sbiw	r30, 0x00	; 0
    40da:	29 f4       	brne	.+10     	; 0x40e6 <free+0x100>
    40dc:	10 92 33 24 	sts	0x2433, r1	; 0x802433 <__flp>
    40e0:	10 92 34 24 	sts	0x2434, r1	; 0x802434 <__flp+0x1>
    40e4:	02 c0       	rjmp	.+4      	; 0x40ea <free+0x104>
    40e6:	12 82       	std	Z+2, r1	; 0x02
    40e8:	13 82       	std	Z+3, r1	; 0x03
    40ea:	a0 93 31 24 	sts	0x2431, r26	; 0x802431 <__brkval>
    40ee:	b0 93 32 24 	sts	0x2432, r27	; 0x802432 <__brkval+0x1>
    40f2:	df 91       	pop	r29
    40f4:	cf 91       	pop	r28
    40f6:	08 95       	ret

000040f8 <memcpy>:
    40f8:	fb 01       	movw	r30, r22
    40fa:	dc 01       	movw	r26, r24
    40fc:	02 c0       	rjmp	.+4      	; 0x4102 <memcpy+0xa>
    40fe:	01 90       	ld	r0, Z+
    4100:	0d 92       	st	X+, r0
    4102:	41 50       	subi	r20, 0x01	; 1
    4104:	50 40       	sbci	r21, 0x00	; 0
    4106:	d8 f7       	brcc	.-10     	; 0x40fe <memcpy+0x6>
    4108:	08 95       	ret

0000410a <snprintf>:
    410a:	0f 93       	push	r16
    410c:	1f 93       	push	r17
    410e:	cf 93       	push	r28
    4110:	df 93       	push	r29
    4112:	cd b7       	in	r28, 0x3d	; 61
    4114:	de b7       	in	r29, 0x3e	; 62
    4116:	2e 97       	sbiw	r28, 0x0e	; 14
    4118:	cd bf       	out	0x3d, r28	; 61
    411a:	de bf       	out	0x3e, r29	; 62
    411c:	0e 89       	ldd	r16, Y+22	; 0x16
    411e:	1f 89       	ldd	r17, Y+23	; 0x17
    4120:	88 8d       	ldd	r24, Y+24	; 0x18
    4122:	99 8d       	ldd	r25, Y+25	; 0x19
    4124:	26 e0       	ldi	r18, 0x06	; 6
    4126:	2c 83       	std	Y+4, r18	; 0x04
    4128:	09 83       	std	Y+1, r16	; 0x01
    412a:	1a 83       	std	Y+2, r17	; 0x02
    412c:	97 ff       	sbrs	r25, 7
    412e:	02 c0       	rjmp	.+4      	; 0x4134 <snprintf+0x2a>
    4130:	80 e0       	ldi	r24, 0x00	; 0
    4132:	90 e8       	ldi	r25, 0x80	; 128
    4134:	01 97       	sbiw	r24, 0x01	; 1
    4136:	8d 83       	std	Y+5, r24	; 0x05
    4138:	9e 83       	std	Y+6, r25	; 0x06
    413a:	ae 01       	movw	r20, r28
    413c:	44 5e       	subi	r20, 0xE4	; 228
    413e:	5f 4f       	sbci	r21, 0xFF	; 255
    4140:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4142:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4144:	ce 01       	movw	r24, r28
    4146:	01 96       	adiw	r24, 0x01	; 1
    4148:	16 d0       	rcall	.+44     	; 0x4176 <vfprintf>
    414a:	4d 81       	ldd	r20, Y+5	; 0x05
    414c:	5e 81       	ldd	r21, Y+6	; 0x06
    414e:	57 fd       	sbrc	r21, 7
    4150:	0a c0       	rjmp	.+20     	; 0x4166 <snprintf+0x5c>
    4152:	2f 81       	ldd	r18, Y+7	; 0x07
    4154:	38 85       	ldd	r19, Y+8	; 0x08
    4156:	42 17       	cp	r20, r18
    4158:	53 07       	cpc	r21, r19
    415a:	0c f4       	brge	.+2      	; 0x415e <snprintf+0x54>
    415c:	9a 01       	movw	r18, r20
    415e:	f8 01       	movw	r30, r16
    4160:	e2 0f       	add	r30, r18
    4162:	f3 1f       	adc	r31, r19
    4164:	10 82       	st	Z, r1
    4166:	2e 96       	adiw	r28, 0x0e	; 14
    4168:	cd bf       	out	0x3d, r28	; 61
    416a:	de bf       	out	0x3e, r29	; 62
    416c:	df 91       	pop	r29
    416e:	cf 91       	pop	r28
    4170:	1f 91       	pop	r17
    4172:	0f 91       	pop	r16
    4174:	08 95       	ret

00004176 <vfprintf>:
    4176:	2f 92       	push	r2
    4178:	3f 92       	push	r3
    417a:	4f 92       	push	r4
    417c:	5f 92       	push	r5
    417e:	6f 92       	push	r6
    4180:	7f 92       	push	r7
    4182:	8f 92       	push	r8
    4184:	9f 92       	push	r9
    4186:	af 92       	push	r10
    4188:	bf 92       	push	r11
    418a:	cf 92       	push	r12
    418c:	df 92       	push	r13
    418e:	ef 92       	push	r14
    4190:	ff 92       	push	r15
    4192:	0f 93       	push	r16
    4194:	1f 93       	push	r17
    4196:	cf 93       	push	r28
    4198:	df 93       	push	r29
    419a:	cd b7       	in	r28, 0x3d	; 61
    419c:	de b7       	in	r29, 0x3e	; 62
    419e:	2b 97       	sbiw	r28, 0x0b	; 11
    41a0:	cd bf       	out	0x3d, r28	; 61
    41a2:	de bf       	out	0x3e, r29	; 62
    41a4:	6c 01       	movw	r12, r24
    41a6:	7b 01       	movw	r14, r22
    41a8:	8a 01       	movw	r16, r20
    41aa:	fc 01       	movw	r30, r24
    41ac:	16 82       	std	Z+6, r1	; 0x06
    41ae:	17 82       	std	Z+7, r1	; 0x07
    41b0:	83 81       	ldd	r24, Z+3	; 0x03
    41b2:	81 ff       	sbrs	r24, 1
    41b4:	bf c1       	rjmp	.+894    	; 0x4534 <vfprintf+0x3be>
    41b6:	ce 01       	movw	r24, r28
    41b8:	01 96       	adiw	r24, 0x01	; 1
    41ba:	3c 01       	movw	r6, r24
    41bc:	f6 01       	movw	r30, r12
    41be:	93 81       	ldd	r25, Z+3	; 0x03
    41c0:	f7 01       	movw	r30, r14
    41c2:	93 fd       	sbrc	r25, 3
    41c4:	85 91       	lpm	r24, Z+
    41c6:	93 ff       	sbrs	r25, 3
    41c8:	81 91       	ld	r24, Z+
    41ca:	7f 01       	movw	r14, r30
    41cc:	88 23       	and	r24, r24
    41ce:	09 f4       	brne	.+2      	; 0x41d2 <vfprintf+0x5c>
    41d0:	ad c1       	rjmp	.+858    	; 0x452c <vfprintf+0x3b6>
    41d2:	85 32       	cpi	r24, 0x25	; 37
    41d4:	39 f4       	brne	.+14     	; 0x41e4 <vfprintf+0x6e>
    41d6:	93 fd       	sbrc	r25, 3
    41d8:	85 91       	lpm	r24, Z+
    41da:	93 ff       	sbrs	r25, 3
    41dc:	81 91       	ld	r24, Z+
    41de:	7f 01       	movw	r14, r30
    41e0:	85 32       	cpi	r24, 0x25	; 37
    41e2:	21 f4       	brne	.+8      	; 0x41ec <vfprintf+0x76>
    41e4:	b6 01       	movw	r22, r12
    41e6:	90 e0       	ldi	r25, 0x00	; 0
    41e8:	d3 d1       	rcall	.+934    	; 0x4590 <fputc>
    41ea:	e8 cf       	rjmp	.-48     	; 0x41bc <vfprintf+0x46>
    41ec:	91 2c       	mov	r9, r1
    41ee:	21 2c       	mov	r2, r1
    41f0:	31 2c       	mov	r3, r1
    41f2:	ff e1       	ldi	r31, 0x1F	; 31
    41f4:	f3 15       	cp	r31, r3
    41f6:	d8 f0       	brcs	.+54     	; 0x422e <vfprintf+0xb8>
    41f8:	8b 32       	cpi	r24, 0x2B	; 43
    41fa:	79 f0       	breq	.+30     	; 0x421a <vfprintf+0xa4>
    41fc:	38 f4       	brcc	.+14     	; 0x420c <vfprintf+0x96>
    41fe:	80 32       	cpi	r24, 0x20	; 32
    4200:	79 f0       	breq	.+30     	; 0x4220 <vfprintf+0xaa>
    4202:	83 32       	cpi	r24, 0x23	; 35
    4204:	a1 f4       	brne	.+40     	; 0x422e <vfprintf+0xb8>
    4206:	23 2d       	mov	r18, r3
    4208:	20 61       	ori	r18, 0x10	; 16
    420a:	1d c0       	rjmp	.+58     	; 0x4246 <vfprintf+0xd0>
    420c:	8d 32       	cpi	r24, 0x2D	; 45
    420e:	61 f0       	breq	.+24     	; 0x4228 <vfprintf+0xb2>
    4210:	80 33       	cpi	r24, 0x30	; 48
    4212:	69 f4       	brne	.+26     	; 0x422e <vfprintf+0xb8>
    4214:	23 2d       	mov	r18, r3
    4216:	21 60       	ori	r18, 0x01	; 1
    4218:	16 c0       	rjmp	.+44     	; 0x4246 <vfprintf+0xd0>
    421a:	83 2d       	mov	r24, r3
    421c:	82 60       	ori	r24, 0x02	; 2
    421e:	38 2e       	mov	r3, r24
    4220:	e3 2d       	mov	r30, r3
    4222:	e4 60       	ori	r30, 0x04	; 4
    4224:	3e 2e       	mov	r3, r30
    4226:	2a c0       	rjmp	.+84     	; 0x427c <vfprintf+0x106>
    4228:	f3 2d       	mov	r31, r3
    422a:	f8 60       	ori	r31, 0x08	; 8
    422c:	1d c0       	rjmp	.+58     	; 0x4268 <vfprintf+0xf2>
    422e:	37 fc       	sbrc	r3, 7
    4230:	2d c0       	rjmp	.+90     	; 0x428c <vfprintf+0x116>
    4232:	20 ed       	ldi	r18, 0xD0	; 208
    4234:	28 0f       	add	r18, r24
    4236:	2a 30       	cpi	r18, 0x0A	; 10
    4238:	40 f0       	brcs	.+16     	; 0x424a <vfprintf+0xd4>
    423a:	8e 32       	cpi	r24, 0x2E	; 46
    423c:	b9 f4       	brne	.+46     	; 0x426c <vfprintf+0xf6>
    423e:	36 fc       	sbrc	r3, 6
    4240:	75 c1       	rjmp	.+746    	; 0x452c <vfprintf+0x3b6>
    4242:	23 2d       	mov	r18, r3
    4244:	20 64       	ori	r18, 0x40	; 64
    4246:	32 2e       	mov	r3, r18
    4248:	19 c0       	rjmp	.+50     	; 0x427c <vfprintf+0x106>
    424a:	36 fe       	sbrs	r3, 6
    424c:	06 c0       	rjmp	.+12     	; 0x425a <vfprintf+0xe4>
    424e:	8a e0       	ldi	r24, 0x0A	; 10
    4250:	98 9e       	mul	r9, r24
    4252:	20 0d       	add	r18, r0
    4254:	11 24       	eor	r1, r1
    4256:	92 2e       	mov	r9, r18
    4258:	11 c0       	rjmp	.+34     	; 0x427c <vfprintf+0x106>
    425a:	ea e0       	ldi	r30, 0x0A	; 10
    425c:	2e 9e       	mul	r2, r30
    425e:	20 0d       	add	r18, r0
    4260:	11 24       	eor	r1, r1
    4262:	22 2e       	mov	r2, r18
    4264:	f3 2d       	mov	r31, r3
    4266:	f0 62       	ori	r31, 0x20	; 32
    4268:	3f 2e       	mov	r3, r31
    426a:	08 c0       	rjmp	.+16     	; 0x427c <vfprintf+0x106>
    426c:	8c 36       	cpi	r24, 0x6C	; 108
    426e:	21 f4       	brne	.+8      	; 0x4278 <vfprintf+0x102>
    4270:	83 2d       	mov	r24, r3
    4272:	80 68       	ori	r24, 0x80	; 128
    4274:	38 2e       	mov	r3, r24
    4276:	02 c0       	rjmp	.+4      	; 0x427c <vfprintf+0x106>
    4278:	88 36       	cpi	r24, 0x68	; 104
    427a:	41 f4       	brne	.+16     	; 0x428c <vfprintf+0x116>
    427c:	f7 01       	movw	r30, r14
    427e:	93 fd       	sbrc	r25, 3
    4280:	85 91       	lpm	r24, Z+
    4282:	93 ff       	sbrs	r25, 3
    4284:	81 91       	ld	r24, Z+
    4286:	7f 01       	movw	r14, r30
    4288:	81 11       	cpse	r24, r1
    428a:	b3 cf       	rjmp	.-154    	; 0x41f2 <vfprintf+0x7c>
    428c:	98 2f       	mov	r25, r24
    428e:	9f 7d       	andi	r25, 0xDF	; 223
    4290:	95 54       	subi	r25, 0x45	; 69
    4292:	93 30       	cpi	r25, 0x03	; 3
    4294:	28 f4       	brcc	.+10     	; 0x42a0 <vfprintf+0x12a>
    4296:	0c 5f       	subi	r16, 0xFC	; 252
    4298:	1f 4f       	sbci	r17, 0xFF	; 255
    429a:	9f e3       	ldi	r25, 0x3F	; 63
    429c:	99 83       	std	Y+1, r25	; 0x01
    429e:	0d c0       	rjmp	.+26     	; 0x42ba <vfprintf+0x144>
    42a0:	83 36       	cpi	r24, 0x63	; 99
    42a2:	31 f0       	breq	.+12     	; 0x42b0 <vfprintf+0x13a>
    42a4:	83 37       	cpi	r24, 0x73	; 115
    42a6:	71 f0       	breq	.+28     	; 0x42c4 <vfprintf+0x14e>
    42a8:	83 35       	cpi	r24, 0x53	; 83
    42aa:	09 f0       	breq	.+2      	; 0x42ae <vfprintf+0x138>
    42ac:	55 c0       	rjmp	.+170    	; 0x4358 <vfprintf+0x1e2>
    42ae:	20 c0       	rjmp	.+64     	; 0x42f0 <vfprintf+0x17a>
    42b0:	f8 01       	movw	r30, r16
    42b2:	80 81       	ld	r24, Z
    42b4:	89 83       	std	Y+1, r24	; 0x01
    42b6:	0e 5f       	subi	r16, 0xFE	; 254
    42b8:	1f 4f       	sbci	r17, 0xFF	; 255
    42ba:	88 24       	eor	r8, r8
    42bc:	83 94       	inc	r8
    42be:	91 2c       	mov	r9, r1
    42c0:	53 01       	movw	r10, r6
    42c2:	12 c0       	rjmp	.+36     	; 0x42e8 <vfprintf+0x172>
    42c4:	28 01       	movw	r4, r16
    42c6:	f2 e0       	ldi	r31, 0x02	; 2
    42c8:	4f 0e       	add	r4, r31
    42ca:	51 1c       	adc	r5, r1
    42cc:	f8 01       	movw	r30, r16
    42ce:	a0 80       	ld	r10, Z
    42d0:	b1 80       	ldd	r11, Z+1	; 0x01
    42d2:	36 fe       	sbrs	r3, 6
    42d4:	03 c0       	rjmp	.+6      	; 0x42dc <vfprintf+0x166>
    42d6:	69 2d       	mov	r22, r9
    42d8:	70 e0       	ldi	r23, 0x00	; 0
    42da:	02 c0       	rjmp	.+4      	; 0x42e0 <vfprintf+0x16a>
    42dc:	6f ef       	ldi	r22, 0xFF	; 255
    42de:	7f ef       	ldi	r23, 0xFF	; 255
    42e0:	c5 01       	movw	r24, r10
    42e2:	4b d1       	rcall	.+662    	; 0x457a <strnlen>
    42e4:	4c 01       	movw	r8, r24
    42e6:	82 01       	movw	r16, r4
    42e8:	f3 2d       	mov	r31, r3
    42ea:	ff 77       	andi	r31, 0x7F	; 127
    42ec:	3f 2e       	mov	r3, r31
    42ee:	15 c0       	rjmp	.+42     	; 0x431a <vfprintf+0x1a4>
    42f0:	28 01       	movw	r4, r16
    42f2:	22 e0       	ldi	r18, 0x02	; 2
    42f4:	42 0e       	add	r4, r18
    42f6:	51 1c       	adc	r5, r1
    42f8:	f8 01       	movw	r30, r16
    42fa:	a0 80       	ld	r10, Z
    42fc:	b1 80       	ldd	r11, Z+1	; 0x01
    42fe:	36 fe       	sbrs	r3, 6
    4300:	03 c0       	rjmp	.+6      	; 0x4308 <vfprintf+0x192>
    4302:	69 2d       	mov	r22, r9
    4304:	70 e0       	ldi	r23, 0x00	; 0
    4306:	02 c0       	rjmp	.+4      	; 0x430c <vfprintf+0x196>
    4308:	6f ef       	ldi	r22, 0xFF	; 255
    430a:	7f ef       	ldi	r23, 0xFF	; 255
    430c:	c5 01       	movw	r24, r10
    430e:	2a d1       	rcall	.+596    	; 0x4564 <strnlen_P>
    4310:	4c 01       	movw	r8, r24
    4312:	f3 2d       	mov	r31, r3
    4314:	f0 68       	ori	r31, 0x80	; 128
    4316:	3f 2e       	mov	r3, r31
    4318:	82 01       	movw	r16, r4
    431a:	33 fc       	sbrc	r3, 3
    431c:	19 c0       	rjmp	.+50     	; 0x4350 <vfprintf+0x1da>
    431e:	82 2d       	mov	r24, r2
    4320:	90 e0       	ldi	r25, 0x00	; 0
    4322:	88 16       	cp	r8, r24
    4324:	99 06       	cpc	r9, r25
    4326:	a0 f4       	brcc	.+40     	; 0x4350 <vfprintf+0x1da>
    4328:	b6 01       	movw	r22, r12
    432a:	80 e2       	ldi	r24, 0x20	; 32
    432c:	90 e0       	ldi	r25, 0x00	; 0
    432e:	30 d1       	rcall	.+608    	; 0x4590 <fputc>
    4330:	2a 94       	dec	r2
    4332:	f5 cf       	rjmp	.-22     	; 0x431e <vfprintf+0x1a8>
    4334:	f5 01       	movw	r30, r10
    4336:	37 fc       	sbrc	r3, 7
    4338:	85 91       	lpm	r24, Z+
    433a:	37 fe       	sbrs	r3, 7
    433c:	81 91       	ld	r24, Z+
    433e:	5f 01       	movw	r10, r30
    4340:	b6 01       	movw	r22, r12
    4342:	90 e0       	ldi	r25, 0x00	; 0
    4344:	25 d1       	rcall	.+586    	; 0x4590 <fputc>
    4346:	21 10       	cpse	r2, r1
    4348:	2a 94       	dec	r2
    434a:	21 e0       	ldi	r18, 0x01	; 1
    434c:	82 1a       	sub	r8, r18
    434e:	91 08       	sbc	r9, r1
    4350:	81 14       	cp	r8, r1
    4352:	91 04       	cpc	r9, r1
    4354:	79 f7       	brne	.-34     	; 0x4334 <vfprintf+0x1be>
    4356:	e1 c0       	rjmp	.+450    	; 0x451a <vfprintf+0x3a4>
    4358:	84 36       	cpi	r24, 0x64	; 100
    435a:	11 f0       	breq	.+4      	; 0x4360 <vfprintf+0x1ea>
    435c:	89 36       	cpi	r24, 0x69	; 105
    435e:	39 f5       	brne	.+78     	; 0x43ae <vfprintf+0x238>
    4360:	f8 01       	movw	r30, r16
    4362:	37 fe       	sbrs	r3, 7
    4364:	07 c0       	rjmp	.+14     	; 0x4374 <vfprintf+0x1fe>
    4366:	60 81       	ld	r22, Z
    4368:	71 81       	ldd	r23, Z+1	; 0x01
    436a:	82 81       	ldd	r24, Z+2	; 0x02
    436c:	93 81       	ldd	r25, Z+3	; 0x03
    436e:	0c 5f       	subi	r16, 0xFC	; 252
    4370:	1f 4f       	sbci	r17, 0xFF	; 255
    4372:	08 c0       	rjmp	.+16     	; 0x4384 <vfprintf+0x20e>
    4374:	60 81       	ld	r22, Z
    4376:	71 81       	ldd	r23, Z+1	; 0x01
    4378:	07 2e       	mov	r0, r23
    437a:	00 0c       	add	r0, r0
    437c:	88 0b       	sbc	r24, r24
    437e:	99 0b       	sbc	r25, r25
    4380:	0e 5f       	subi	r16, 0xFE	; 254
    4382:	1f 4f       	sbci	r17, 0xFF	; 255
    4384:	f3 2d       	mov	r31, r3
    4386:	ff 76       	andi	r31, 0x6F	; 111
    4388:	3f 2e       	mov	r3, r31
    438a:	97 ff       	sbrs	r25, 7
    438c:	09 c0       	rjmp	.+18     	; 0x43a0 <vfprintf+0x22a>
    438e:	90 95       	com	r25
    4390:	80 95       	com	r24
    4392:	70 95       	com	r23
    4394:	61 95       	neg	r22
    4396:	7f 4f       	sbci	r23, 0xFF	; 255
    4398:	8f 4f       	sbci	r24, 0xFF	; 255
    439a:	9f 4f       	sbci	r25, 0xFF	; 255
    439c:	f0 68       	ori	r31, 0x80	; 128
    439e:	3f 2e       	mov	r3, r31
    43a0:	2a e0       	ldi	r18, 0x0A	; 10
    43a2:	30 e0       	ldi	r19, 0x00	; 0
    43a4:	a3 01       	movw	r20, r6
    43a6:	30 d1       	rcall	.+608    	; 0x4608 <__ultoa_invert>
    43a8:	88 2e       	mov	r8, r24
    43aa:	86 18       	sub	r8, r6
    43ac:	44 c0       	rjmp	.+136    	; 0x4436 <vfprintf+0x2c0>
    43ae:	85 37       	cpi	r24, 0x75	; 117
    43b0:	31 f4       	brne	.+12     	; 0x43be <vfprintf+0x248>
    43b2:	23 2d       	mov	r18, r3
    43b4:	2f 7e       	andi	r18, 0xEF	; 239
    43b6:	b2 2e       	mov	r11, r18
    43b8:	2a e0       	ldi	r18, 0x0A	; 10
    43ba:	30 e0       	ldi	r19, 0x00	; 0
    43bc:	25 c0       	rjmp	.+74     	; 0x4408 <vfprintf+0x292>
    43be:	93 2d       	mov	r25, r3
    43c0:	99 7f       	andi	r25, 0xF9	; 249
    43c2:	b9 2e       	mov	r11, r25
    43c4:	8f 36       	cpi	r24, 0x6F	; 111
    43c6:	c1 f0       	breq	.+48     	; 0x43f8 <vfprintf+0x282>
    43c8:	18 f4       	brcc	.+6      	; 0x43d0 <vfprintf+0x25a>
    43ca:	88 35       	cpi	r24, 0x58	; 88
    43cc:	79 f0       	breq	.+30     	; 0x43ec <vfprintf+0x276>
    43ce:	ae c0       	rjmp	.+348    	; 0x452c <vfprintf+0x3b6>
    43d0:	80 37       	cpi	r24, 0x70	; 112
    43d2:	19 f0       	breq	.+6      	; 0x43da <vfprintf+0x264>
    43d4:	88 37       	cpi	r24, 0x78	; 120
    43d6:	21 f0       	breq	.+8      	; 0x43e0 <vfprintf+0x26a>
    43d8:	a9 c0       	rjmp	.+338    	; 0x452c <vfprintf+0x3b6>
    43da:	e9 2f       	mov	r30, r25
    43dc:	e0 61       	ori	r30, 0x10	; 16
    43de:	be 2e       	mov	r11, r30
    43e0:	b4 fe       	sbrs	r11, 4
    43e2:	0d c0       	rjmp	.+26     	; 0x43fe <vfprintf+0x288>
    43e4:	fb 2d       	mov	r31, r11
    43e6:	f4 60       	ori	r31, 0x04	; 4
    43e8:	bf 2e       	mov	r11, r31
    43ea:	09 c0       	rjmp	.+18     	; 0x43fe <vfprintf+0x288>
    43ec:	34 fe       	sbrs	r3, 4
    43ee:	0a c0       	rjmp	.+20     	; 0x4404 <vfprintf+0x28e>
    43f0:	29 2f       	mov	r18, r25
    43f2:	26 60       	ori	r18, 0x06	; 6
    43f4:	b2 2e       	mov	r11, r18
    43f6:	06 c0       	rjmp	.+12     	; 0x4404 <vfprintf+0x28e>
    43f8:	28 e0       	ldi	r18, 0x08	; 8
    43fa:	30 e0       	ldi	r19, 0x00	; 0
    43fc:	05 c0       	rjmp	.+10     	; 0x4408 <vfprintf+0x292>
    43fe:	20 e1       	ldi	r18, 0x10	; 16
    4400:	30 e0       	ldi	r19, 0x00	; 0
    4402:	02 c0       	rjmp	.+4      	; 0x4408 <vfprintf+0x292>
    4404:	20 e1       	ldi	r18, 0x10	; 16
    4406:	32 e0       	ldi	r19, 0x02	; 2
    4408:	f8 01       	movw	r30, r16
    440a:	b7 fe       	sbrs	r11, 7
    440c:	07 c0       	rjmp	.+14     	; 0x441c <vfprintf+0x2a6>
    440e:	60 81       	ld	r22, Z
    4410:	71 81       	ldd	r23, Z+1	; 0x01
    4412:	82 81       	ldd	r24, Z+2	; 0x02
    4414:	93 81       	ldd	r25, Z+3	; 0x03
    4416:	0c 5f       	subi	r16, 0xFC	; 252
    4418:	1f 4f       	sbci	r17, 0xFF	; 255
    441a:	06 c0       	rjmp	.+12     	; 0x4428 <vfprintf+0x2b2>
    441c:	60 81       	ld	r22, Z
    441e:	71 81       	ldd	r23, Z+1	; 0x01
    4420:	80 e0       	ldi	r24, 0x00	; 0
    4422:	90 e0       	ldi	r25, 0x00	; 0
    4424:	0e 5f       	subi	r16, 0xFE	; 254
    4426:	1f 4f       	sbci	r17, 0xFF	; 255
    4428:	a3 01       	movw	r20, r6
    442a:	ee d0       	rcall	.+476    	; 0x4608 <__ultoa_invert>
    442c:	88 2e       	mov	r8, r24
    442e:	86 18       	sub	r8, r6
    4430:	fb 2d       	mov	r31, r11
    4432:	ff 77       	andi	r31, 0x7F	; 127
    4434:	3f 2e       	mov	r3, r31
    4436:	36 fe       	sbrs	r3, 6
    4438:	0d c0       	rjmp	.+26     	; 0x4454 <vfprintf+0x2de>
    443a:	23 2d       	mov	r18, r3
    443c:	2e 7f       	andi	r18, 0xFE	; 254
    443e:	a2 2e       	mov	r10, r18
    4440:	89 14       	cp	r8, r9
    4442:	58 f4       	brcc	.+22     	; 0x445a <vfprintf+0x2e4>
    4444:	34 fe       	sbrs	r3, 4
    4446:	0b c0       	rjmp	.+22     	; 0x445e <vfprintf+0x2e8>
    4448:	32 fc       	sbrc	r3, 2
    444a:	09 c0       	rjmp	.+18     	; 0x445e <vfprintf+0x2e8>
    444c:	83 2d       	mov	r24, r3
    444e:	8e 7e       	andi	r24, 0xEE	; 238
    4450:	a8 2e       	mov	r10, r24
    4452:	05 c0       	rjmp	.+10     	; 0x445e <vfprintf+0x2e8>
    4454:	b8 2c       	mov	r11, r8
    4456:	a3 2c       	mov	r10, r3
    4458:	03 c0       	rjmp	.+6      	; 0x4460 <vfprintf+0x2ea>
    445a:	b8 2c       	mov	r11, r8
    445c:	01 c0       	rjmp	.+2      	; 0x4460 <vfprintf+0x2ea>
    445e:	b9 2c       	mov	r11, r9
    4460:	a4 fe       	sbrs	r10, 4
    4462:	0f c0       	rjmp	.+30     	; 0x4482 <vfprintf+0x30c>
    4464:	fe 01       	movw	r30, r28
    4466:	e8 0d       	add	r30, r8
    4468:	f1 1d       	adc	r31, r1
    446a:	80 81       	ld	r24, Z
    446c:	80 33       	cpi	r24, 0x30	; 48
    446e:	21 f4       	brne	.+8      	; 0x4478 <vfprintf+0x302>
    4470:	9a 2d       	mov	r25, r10
    4472:	99 7e       	andi	r25, 0xE9	; 233
    4474:	a9 2e       	mov	r10, r25
    4476:	09 c0       	rjmp	.+18     	; 0x448a <vfprintf+0x314>
    4478:	a2 fe       	sbrs	r10, 2
    447a:	06 c0       	rjmp	.+12     	; 0x4488 <vfprintf+0x312>
    447c:	b3 94       	inc	r11
    447e:	b3 94       	inc	r11
    4480:	04 c0       	rjmp	.+8      	; 0x448a <vfprintf+0x314>
    4482:	8a 2d       	mov	r24, r10
    4484:	86 78       	andi	r24, 0x86	; 134
    4486:	09 f0       	breq	.+2      	; 0x448a <vfprintf+0x314>
    4488:	b3 94       	inc	r11
    448a:	a3 fc       	sbrc	r10, 3
    448c:	10 c0       	rjmp	.+32     	; 0x44ae <vfprintf+0x338>
    448e:	a0 fe       	sbrs	r10, 0
    4490:	06 c0       	rjmp	.+12     	; 0x449e <vfprintf+0x328>
    4492:	b2 14       	cp	r11, r2
    4494:	80 f4       	brcc	.+32     	; 0x44b6 <vfprintf+0x340>
    4496:	28 0c       	add	r2, r8
    4498:	92 2c       	mov	r9, r2
    449a:	9b 18       	sub	r9, r11
    449c:	0d c0       	rjmp	.+26     	; 0x44b8 <vfprintf+0x342>
    449e:	b2 14       	cp	r11, r2
    44a0:	58 f4       	brcc	.+22     	; 0x44b8 <vfprintf+0x342>
    44a2:	b6 01       	movw	r22, r12
    44a4:	80 e2       	ldi	r24, 0x20	; 32
    44a6:	90 e0       	ldi	r25, 0x00	; 0
    44a8:	73 d0       	rcall	.+230    	; 0x4590 <fputc>
    44aa:	b3 94       	inc	r11
    44ac:	f8 cf       	rjmp	.-16     	; 0x449e <vfprintf+0x328>
    44ae:	b2 14       	cp	r11, r2
    44b0:	18 f4       	brcc	.+6      	; 0x44b8 <vfprintf+0x342>
    44b2:	2b 18       	sub	r2, r11
    44b4:	02 c0       	rjmp	.+4      	; 0x44ba <vfprintf+0x344>
    44b6:	98 2c       	mov	r9, r8
    44b8:	21 2c       	mov	r2, r1
    44ba:	a4 fe       	sbrs	r10, 4
    44bc:	0f c0       	rjmp	.+30     	; 0x44dc <vfprintf+0x366>
    44be:	b6 01       	movw	r22, r12
    44c0:	80 e3       	ldi	r24, 0x30	; 48
    44c2:	90 e0       	ldi	r25, 0x00	; 0
    44c4:	65 d0       	rcall	.+202    	; 0x4590 <fputc>
    44c6:	a2 fe       	sbrs	r10, 2
    44c8:	16 c0       	rjmp	.+44     	; 0x44f6 <vfprintf+0x380>
    44ca:	a1 fc       	sbrc	r10, 1
    44cc:	03 c0       	rjmp	.+6      	; 0x44d4 <vfprintf+0x35e>
    44ce:	88 e7       	ldi	r24, 0x78	; 120
    44d0:	90 e0       	ldi	r25, 0x00	; 0
    44d2:	02 c0       	rjmp	.+4      	; 0x44d8 <vfprintf+0x362>
    44d4:	88 e5       	ldi	r24, 0x58	; 88
    44d6:	90 e0       	ldi	r25, 0x00	; 0
    44d8:	b6 01       	movw	r22, r12
    44da:	0c c0       	rjmp	.+24     	; 0x44f4 <vfprintf+0x37e>
    44dc:	8a 2d       	mov	r24, r10
    44de:	86 78       	andi	r24, 0x86	; 134
    44e0:	51 f0       	breq	.+20     	; 0x44f6 <vfprintf+0x380>
    44e2:	a1 fe       	sbrs	r10, 1
    44e4:	02 c0       	rjmp	.+4      	; 0x44ea <vfprintf+0x374>
    44e6:	8b e2       	ldi	r24, 0x2B	; 43
    44e8:	01 c0       	rjmp	.+2      	; 0x44ec <vfprintf+0x376>
    44ea:	80 e2       	ldi	r24, 0x20	; 32
    44ec:	a7 fc       	sbrc	r10, 7
    44ee:	8d e2       	ldi	r24, 0x2D	; 45
    44f0:	b6 01       	movw	r22, r12
    44f2:	90 e0       	ldi	r25, 0x00	; 0
    44f4:	4d d0       	rcall	.+154    	; 0x4590 <fputc>
    44f6:	89 14       	cp	r8, r9
    44f8:	30 f4       	brcc	.+12     	; 0x4506 <vfprintf+0x390>
    44fa:	b6 01       	movw	r22, r12
    44fc:	80 e3       	ldi	r24, 0x30	; 48
    44fe:	90 e0       	ldi	r25, 0x00	; 0
    4500:	47 d0       	rcall	.+142    	; 0x4590 <fputc>
    4502:	9a 94       	dec	r9
    4504:	f8 cf       	rjmp	.-16     	; 0x44f6 <vfprintf+0x380>
    4506:	8a 94       	dec	r8
    4508:	f3 01       	movw	r30, r6
    450a:	e8 0d       	add	r30, r8
    450c:	f1 1d       	adc	r31, r1
    450e:	80 81       	ld	r24, Z
    4510:	b6 01       	movw	r22, r12
    4512:	90 e0       	ldi	r25, 0x00	; 0
    4514:	3d d0       	rcall	.+122    	; 0x4590 <fputc>
    4516:	81 10       	cpse	r8, r1
    4518:	f6 cf       	rjmp	.-20     	; 0x4506 <vfprintf+0x390>
    451a:	22 20       	and	r2, r2
    451c:	09 f4       	brne	.+2      	; 0x4520 <vfprintf+0x3aa>
    451e:	4e ce       	rjmp	.-868    	; 0x41bc <vfprintf+0x46>
    4520:	b6 01       	movw	r22, r12
    4522:	80 e2       	ldi	r24, 0x20	; 32
    4524:	90 e0       	ldi	r25, 0x00	; 0
    4526:	34 d0       	rcall	.+104    	; 0x4590 <fputc>
    4528:	2a 94       	dec	r2
    452a:	f7 cf       	rjmp	.-18     	; 0x451a <vfprintf+0x3a4>
    452c:	f6 01       	movw	r30, r12
    452e:	86 81       	ldd	r24, Z+6	; 0x06
    4530:	97 81       	ldd	r25, Z+7	; 0x07
    4532:	02 c0       	rjmp	.+4      	; 0x4538 <vfprintf+0x3c2>
    4534:	8f ef       	ldi	r24, 0xFF	; 255
    4536:	9f ef       	ldi	r25, 0xFF	; 255
    4538:	2b 96       	adiw	r28, 0x0b	; 11
    453a:	cd bf       	out	0x3d, r28	; 61
    453c:	de bf       	out	0x3e, r29	; 62
    453e:	df 91       	pop	r29
    4540:	cf 91       	pop	r28
    4542:	1f 91       	pop	r17
    4544:	0f 91       	pop	r16
    4546:	ff 90       	pop	r15
    4548:	ef 90       	pop	r14
    454a:	df 90       	pop	r13
    454c:	cf 90       	pop	r12
    454e:	bf 90       	pop	r11
    4550:	af 90       	pop	r10
    4552:	9f 90       	pop	r9
    4554:	8f 90       	pop	r8
    4556:	7f 90       	pop	r7
    4558:	6f 90       	pop	r6
    455a:	5f 90       	pop	r5
    455c:	4f 90       	pop	r4
    455e:	3f 90       	pop	r3
    4560:	2f 90       	pop	r2
    4562:	08 95       	ret

00004564 <strnlen_P>:
    4564:	fc 01       	movw	r30, r24
    4566:	05 90       	lpm	r0, Z+
    4568:	61 50       	subi	r22, 0x01	; 1
    456a:	70 40       	sbci	r23, 0x00	; 0
    456c:	01 10       	cpse	r0, r1
    456e:	d8 f7       	brcc	.-10     	; 0x4566 <strnlen_P+0x2>
    4570:	80 95       	com	r24
    4572:	90 95       	com	r25
    4574:	8e 0f       	add	r24, r30
    4576:	9f 1f       	adc	r25, r31
    4578:	08 95       	ret

0000457a <strnlen>:
    457a:	fc 01       	movw	r30, r24
    457c:	61 50       	subi	r22, 0x01	; 1
    457e:	70 40       	sbci	r23, 0x00	; 0
    4580:	01 90       	ld	r0, Z+
    4582:	01 10       	cpse	r0, r1
    4584:	d8 f7       	brcc	.-10     	; 0x457c <strnlen+0x2>
    4586:	80 95       	com	r24
    4588:	90 95       	com	r25
    458a:	8e 0f       	add	r24, r30
    458c:	9f 1f       	adc	r25, r31
    458e:	08 95       	ret

00004590 <fputc>:
    4590:	0f 93       	push	r16
    4592:	1f 93       	push	r17
    4594:	cf 93       	push	r28
    4596:	df 93       	push	r29
    4598:	fb 01       	movw	r30, r22
    459a:	23 81       	ldd	r18, Z+3	; 0x03
    459c:	21 fd       	sbrc	r18, 1
    459e:	03 c0       	rjmp	.+6      	; 0x45a6 <fputc+0x16>
    45a0:	8f ef       	ldi	r24, 0xFF	; 255
    45a2:	9f ef       	ldi	r25, 0xFF	; 255
    45a4:	2c c0       	rjmp	.+88     	; 0x45fe <fputc+0x6e>
    45a6:	22 ff       	sbrs	r18, 2
    45a8:	16 c0       	rjmp	.+44     	; 0x45d6 <fputc+0x46>
    45aa:	46 81       	ldd	r20, Z+6	; 0x06
    45ac:	57 81       	ldd	r21, Z+7	; 0x07
    45ae:	24 81       	ldd	r18, Z+4	; 0x04
    45b0:	35 81       	ldd	r19, Z+5	; 0x05
    45b2:	42 17       	cp	r20, r18
    45b4:	53 07       	cpc	r21, r19
    45b6:	44 f4       	brge	.+16     	; 0x45c8 <fputc+0x38>
    45b8:	a0 81       	ld	r26, Z
    45ba:	b1 81       	ldd	r27, Z+1	; 0x01
    45bc:	9d 01       	movw	r18, r26
    45be:	2f 5f       	subi	r18, 0xFF	; 255
    45c0:	3f 4f       	sbci	r19, 0xFF	; 255
    45c2:	20 83       	st	Z, r18
    45c4:	31 83       	std	Z+1, r19	; 0x01
    45c6:	8c 93       	st	X, r24
    45c8:	26 81       	ldd	r18, Z+6	; 0x06
    45ca:	37 81       	ldd	r19, Z+7	; 0x07
    45cc:	2f 5f       	subi	r18, 0xFF	; 255
    45ce:	3f 4f       	sbci	r19, 0xFF	; 255
    45d0:	26 83       	std	Z+6, r18	; 0x06
    45d2:	37 83       	std	Z+7, r19	; 0x07
    45d4:	14 c0       	rjmp	.+40     	; 0x45fe <fputc+0x6e>
    45d6:	8b 01       	movw	r16, r22
    45d8:	ec 01       	movw	r28, r24
    45da:	fb 01       	movw	r30, r22
    45dc:	00 84       	ldd	r0, Z+8	; 0x08
    45de:	f1 85       	ldd	r31, Z+9	; 0x09
    45e0:	e0 2d       	mov	r30, r0
    45e2:	19 95       	eicall
    45e4:	89 2b       	or	r24, r25
    45e6:	e1 f6       	brne	.-72     	; 0x45a0 <fputc+0x10>
    45e8:	d8 01       	movw	r26, r16
    45ea:	16 96       	adiw	r26, 0x06	; 6
    45ec:	8d 91       	ld	r24, X+
    45ee:	9c 91       	ld	r25, X
    45f0:	17 97       	sbiw	r26, 0x07	; 7
    45f2:	01 96       	adiw	r24, 0x01	; 1
    45f4:	16 96       	adiw	r26, 0x06	; 6
    45f6:	8d 93       	st	X+, r24
    45f8:	9c 93       	st	X, r25
    45fa:	17 97       	sbiw	r26, 0x07	; 7
    45fc:	ce 01       	movw	r24, r28
    45fe:	df 91       	pop	r29
    4600:	cf 91       	pop	r28
    4602:	1f 91       	pop	r17
    4604:	0f 91       	pop	r16
    4606:	08 95       	ret

00004608 <__ultoa_invert>:
    4608:	fa 01       	movw	r30, r20
    460a:	aa 27       	eor	r26, r26
    460c:	28 30       	cpi	r18, 0x08	; 8
    460e:	51 f1       	breq	.+84     	; 0x4664 <__ultoa_invert+0x5c>
    4610:	20 31       	cpi	r18, 0x10	; 16
    4612:	81 f1       	breq	.+96     	; 0x4674 <__ultoa_invert+0x6c>
    4614:	e8 94       	clt
    4616:	6f 93       	push	r22
    4618:	6e 7f       	andi	r22, 0xFE	; 254
    461a:	6e 5f       	subi	r22, 0xFE	; 254
    461c:	7f 4f       	sbci	r23, 0xFF	; 255
    461e:	8f 4f       	sbci	r24, 0xFF	; 255
    4620:	9f 4f       	sbci	r25, 0xFF	; 255
    4622:	af 4f       	sbci	r26, 0xFF	; 255
    4624:	b1 e0       	ldi	r27, 0x01	; 1
    4626:	3e d0       	rcall	.+124    	; 0x46a4 <__ultoa_invert+0x9c>
    4628:	b4 e0       	ldi	r27, 0x04	; 4
    462a:	3c d0       	rcall	.+120    	; 0x46a4 <__ultoa_invert+0x9c>
    462c:	67 0f       	add	r22, r23
    462e:	78 1f       	adc	r23, r24
    4630:	89 1f       	adc	r24, r25
    4632:	9a 1f       	adc	r25, r26
    4634:	a1 1d       	adc	r26, r1
    4636:	68 0f       	add	r22, r24
    4638:	79 1f       	adc	r23, r25
    463a:	8a 1f       	adc	r24, r26
    463c:	91 1d       	adc	r25, r1
    463e:	a1 1d       	adc	r26, r1
    4640:	6a 0f       	add	r22, r26
    4642:	71 1d       	adc	r23, r1
    4644:	81 1d       	adc	r24, r1
    4646:	91 1d       	adc	r25, r1
    4648:	a1 1d       	adc	r26, r1
    464a:	20 d0       	rcall	.+64     	; 0x468c <__ultoa_invert+0x84>
    464c:	09 f4       	brne	.+2      	; 0x4650 <__ultoa_invert+0x48>
    464e:	68 94       	set
    4650:	3f 91       	pop	r19
    4652:	2a e0       	ldi	r18, 0x0A	; 10
    4654:	26 9f       	mul	r18, r22
    4656:	11 24       	eor	r1, r1
    4658:	30 19       	sub	r19, r0
    465a:	30 5d       	subi	r19, 0xD0	; 208
    465c:	31 93       	st	Z+, r19
    465e:	de f6       	brtc	.-74     	; 0x4616 <__ultoa_invert+0xe>
    4660:	cf 01       	movw	r24, r30
    4662:	08 95       	ret
    4664:	46 2f       	mov	r20, r22
    4666:	47 70       	andi	r20, 0x07	; 7
    4668:	40 5d       	subi	r20, 0xD0	; 208
    466a:	41 93       	st	Z+, r20
    466c:	b3 e0       	ldi	r27, 0x03	; 3
    466e:	0f d0       	rcall	.+30     	; 0x468e <__ultoa_invert+0x86>
    4670:	c9 f7       	brne	.-14     	; 0x4664 <__ultoa_invert+0x5c>
    4672:	f6 cf       	rjmp	.-20     	; 0x4660 <__ultoa_invert+0x58>
    4674:	46 2f       	mov	r20, r22
    4676:	4f 70       	andi	r20, 0x0F	; 15
    4678:	40 5d       	subi	r20, 0xD0	; 208
    467a:	4a 33       	cpi	r20, 0x3A	; 58
    467c:	18 f0       	brcs	.+6      	; 0x4684 <__ultoa_invert+0x7c>
    467e:	49 5d       	subi	r20, 0xD9	; 217
    4680:	31 fd       	sbrc	r19, 1
    4682:	40 52       	subi	r20, 0x20	; 32
    4684:	41 93       	st	Z+, r20
    4686:	02 d0       	rcall	.+4      	; 0x468c <__ultoa_invert+0x84>
    4688:	a9 f7       	brne	.-22     	; 0x4674 <__ultoa_invert+0x6c>
    468a:	ea cf       	rjmp	.-44     	; 0x4660 <__ultoa_invert+0x58>
    468c:	b4 e0       	ldi	r27, 0x04	; 4
    468e:	a6 95       	lsr	r26
    4690:	97 95       	ror	r25
    4692:	87 95       	ror	r24
    4694:	77 95       	ror	r23
    4696:	67 95       	ror	r22
    4698:	ba 95       	dec	r27
    469a:	c9 f7       	brne	.-14     	; 0x468e <__ultoa_invert+0x86>
    469c:	00 97       	sbiw	r24, 0x00	; 0
    469e:	61 05       	cpc	r22, r1
    46a0:	71 05       	cpc	r23, r1
    46a2:	08 95       	ret
    46a4:	9b 01       	movw	r18, r22
    46a6:	ac 01       	movw	r20, r24
    46a8:	0a 2e       	mov	r0, r26
    46aa:	06 94       	lsr	r0
    46ac:	57 95       	ror	r21
    46ae:	47 95       	ror	r20
    46b0:	37 95       	ror	r19
    46b2:	27 95       	ror	r18
    46b4:	ba 95       	dec	r27
    46b6:	c9 f7       	brne	.-14     	; 0x46aa <__ultoa_invert+0xa2>
    46b8:	62 0f       	add	r22, r18
    46ba:	73 1f       	adc	r23, r19
    46bc:	84 1f       	adc	r24, r20
    46be:	95 1f       	adc	r25, r21
    46c0:	a0 1d       	adc	r26, r0
    46c2:	08 95       	ret

000046c4 <_exit>:
    46c4:	f8 94       	cli

000046c6 <__stop_program>:
    46c6:	ff cf       	rjmp	.-2      	; 0x46c6 <__stop_program>
