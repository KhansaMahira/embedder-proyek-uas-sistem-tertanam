
UAS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004534  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000004a  00802000  00004534  000045c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000318  0080204a  0080204a  00004612  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004612  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00004670  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000748  00000000  00000000  000046b8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00016171  00000000  00000000  00004e00  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000061fe  00000000  00000000  0001af71  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c0c1  00000000  00000000  0002116f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001908  00000000  00000000  0002d230  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0003c25a  00000000  00000000  0002eb38  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b4d6  00000000  00000000  0006ad92  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000988  00000000  00000000  00076268  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000d36d  00000000  00000000  00076bf0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 c8 0b 	jmp	0x1790	; 0x1790 <__vector_13>
      38:	0c 94 29 12 	jmp	0x2452	; 0x2452 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 2a 09 	jmp	0x1254	; 0x1254 <__vector_39>
      a0:	0c 94 5c 09 	jmp	0x12b8	; 0x12b8 <__vector_40>
      a4:	0c 94 8e 09 	jmp	0x131c	; 0x131c <__vector_41>
      a8:	0c 94 c0 09 	jmp	0x1380	; 0x1380 <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0c 94 ef 0b 	jmp	0x17de	; 0x17de <__vector_46>
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	d3 c7       	rjmp	.+4006   	; 0x10c4 <__vector_71>
     11e:	00 00       	nop
     120:	0c 94 94 08 	jmp	0x1128	; 0x1128 <__vector_72>
     124:	0c 94 c6 08 	jmp	0x118c	; 0x118c <__vector_73>
     128:	0c 94 f8 08 	jmp	0x11f0	; 0x11f0 <__vector_74>
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	bc 1a       	sub	r11, r28
     1fe:	bc 1a       	sub	r11, r28
     200:	bc 1a       	sub	r11, r28
     202:	e9 1a       	sub	r14, r25
     204:	f1 1a       	sub	r15, r17
     206:	ff 1a       	sub	r15, r31
     208:	bc 1a       	sub	r11, r28
     20a:	bc 1a       	sub	r11, r28
     20c:	e9 1a       	sub	r14, r25
     20e:	f1 1a       	sub	r15, r17

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1d3e>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x6526>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x64fe>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x5526>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1cfe>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e4 e3       	ldi	r30, 0x34	; 52
     4ba:	f5 e4       	ldi	r31, 0x45	; 69
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	aa 34       	cpi	r26, 0x4A	; 74
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	aa e4       	ldi	r26, 0x4A	; 74
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a2 36       	cpi	r26, 0x62	; 98
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 d1 1b 	call	0x37a2	; 0x37a2 <main>
     4e0:	0c 94 98 22 	jmp	0x4530	; 0x4530 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
     4e6:	04 c0       	rjmp	.+8      	; 0x4f0 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
     4e8:	61 50       	subi	r22, 0x01	; 1
     4ea:	71 09       	sbc	r23, r1
     4ec:	81 09       	sbc	r24, r1
     4ee:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
     4f0:	61 15       	cp	r22, r1
     4f2:	71 05       	cpc	r23, r1
     4f4:	81 05       	cpc	r24, r1
     4f6:	91 05       	cpc	r25, r1
     4f8:	b9 f7       	brne	.-18     	; 0x4e8 <__portable_avr_delay_cycles+0x2>
     4fa:	08 95       	ret

000004fc <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4fc:	bf 92       	push	r11
     4fe:	cf 92       	push	r12
     500:	df 92       	push	r13
     502:	ef 92       	push	r14
     504:	ff 92       	push	r15
     506:	0f 93       	push	r16
     508:	1f 93       	push	r17
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	1f 92       	push	r1
     510:	cd b7       	in	r28, 0x3d	; 61
     512:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     514:	00 e0       	ldi	r16, 0x00	; 0
     516:	16 e0       	ldi	r17, 0x06	; 6
     518:	68 94       	set
     51a:	ff 24       	eor	r15, r15
     51c:	f3 f8       	bld	r15, 3
     51e:	f8 01       	movw	r30, r16
     520:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     522:	64 e0       	ldi	r22, 0x04	; 4
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	dd df       	rcall	.-70     	; 0x4e6 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     52c:	f8 01       	movw	r30, r16
     52e:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     530:	64 e0       	ldi	r22, 0x04	; 4
     532:	70 e0       	ldi	r23, 0x00	; 0
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	d6 df       	rcall	.-84     	; 0x4e6 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     53a:	0f 2e       	mov	r0, r31
     53c:	fb e2       	ldi	r31, 0x2B	; 43
     53e:	bf 2e       	mov	r11, r31
     540:	f0 2d       	mov	r31, r0
     542:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     544:	80 ea       	ldi	r24, 0xA0	; 160
     546:	99 e0       	ldi	r25, 0x09	; 9
     548:	43 d4       	rcall	.+2182   	; 0xdd0 <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     54a:	c1 2c       	mov	r12, r1
     54c:	d1 2c       	mov	r13, r1
     54e:	76 01       	movw	r14, r12
     550:	00 e4       	ldi	r16, 0x40	; 64
     552:	12 e4       	ldi	r17, 0x42	; 66
     554:	2f e0       	ldi	r18, 0x0F	; 15
     556:	30 e0       	ldi	r19, 0x00	; 0
     558:	43 e0       	ldi	r20, 0x03	; 3
     55a:	be 01       	movw	r22, r28
     55c:	6f 5f       	subi	r22, 0xFF	; 255
     55e:	7f 4f       	sbci	r23, 0xFF	; 255
     560:	80 ea       	ldi	r24, 0xA0	; 160
     562:	99 e0       	ldi	r25, 0x09	; 9
     564:	64 d4       	rcall	.+2248   	; 0xe2e <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     566:	00 e6       	ldi	r16, 0x60	; 96
     568:	16 e0       	ldi	r17, 0x06	; 6
     56a:	ff 24       	eor	r15, r15
     56c:	f3 94       	inc	r15
     56e:	f8 01       	movw	r30, r16
     570:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     572:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     574:	be 01       	movw	r22, r28
     576:	6f 5f       	subi	r22, 0xFF	; 255
     578:	7f 4f       	sbci	r23, 0xFF	; 255
     57a:	80 ea       	ldi	r24, 0xA0	; 160
     57c:	99 e0       	ldi	r25, 0x09	; 9
     57e:	71 d4       	rcall	.+2274   	; 0xe62 <usart_spi_select_device>
     580:	f8 01       	movw	r30, r16
     582:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     584:	e0 ea       	ldi	r30, 0xA0	; 160
     586:	f9 e0       	ldi	r31, 0x09	; 9
     588:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     58a:	85 ff       	sbrs	r24, 5
     58c:	fd cf       	rjmp	.-6      	; 0x588 <st7565r_init+0x8c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     58e:	80 ea       	ldi	r24, 0xA0	; 160
     590:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     594:	e0 ea       	ldi	r30, 0xA0	; 160
     596:	f9 e0       	ldi	r31, 0x09	; 9
     598:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     59a:	86 ff       	sbrs	r24, 6
     59c:	fd cf       	rjmp	.-6      	; 0x598 <st7565r_init+0x9c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     59e:	e0 ea       	ldi	r30, 0xA0	; 160
     5a0:	f9 e0       	ldi	r31, 0x09	; 9
     5a2:	80 e4       	ldi	r24, 0x40	; 64
     5a4:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5a6:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5a8:	be 01       	movw	r22, r28
     5aa:	6f 5f       	subi	r22, 0xFF	; 255
     5ac:	7f 4f       	sbci	r23, 0xFF	; 255
     5ae:	80 ea       	ldi	r24, 0xA0	; 160
     5b0:	99 e0       	ldi	r25, 0x09	; 9
     5b2:	6d d4       	rcall	.+2266   	; 0xe8e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5b4:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5b6:	89 83       	std	Y+1, r24	; 0x01
     5b8:	be 01       	movw	r22, r28
     5ba:	6f 5f       	subi	r22, 0xFF	; 255
     5bc:	7f 4f       	sbci	r23, 0xFF	; 255
     5be:	80 ea       	ldi	r24, 0xA0	; 160
     5c0:	99 e0       	ldi	r25, 0x09	; 9
     5c2:	4f d4       	rcall	.+2206   	; 0xe62 <usart_spi_select_device>
     5c4:	81 e0       	ldi	r24, 0x01	; 1
     5c6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5ca:	e0 ea       	ldi	r30, 0xA0	; 160
     5cc:	f9 e0       	ldi	r31, 0x09	; 9
     5ce:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5d0:	85 ff       	sbrs	r24, 5
     5d2:	fd cf       	rjmp	.-6      	; 0x5ce <st7565r_init+0xd2>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5d4:	86 ea       	ldi	r24, 0xA6	; 166
     5d6:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5da:	e0 ea       	ldi	r30, 0xA0	; 160
     5dc:	f9 e0       	ldi	r31, 0x09	; 9
     5de:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5e0:	86 ff       	sbrs	r24, 6
     5e2:	fd cf       	rjmp	.-6      	; 0x5de <st7565r_init+0xe2>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5e4:	e0 ea       	ldi	r30, 0xA0	; 160
     5e6:	f9 e0       	ldi	r31, 0x09	; 9
     5e8:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ea:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5ec:	80 81       	ld	r24, Z
     5ee:	be 01       	movw	r22, r28
     5f0:	6f 5f       	subi	r22, 0xFF	; 255
     5f2:	7f 4f       	sbci	r23, 0xFF	; 255
     5f4:	80 ea       	ldi	r24, 0xA0	; 160
     5f6:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5f8:	4a d4       	rcall	.+2196   	; 0xe8e <usart_spi_deselect_device>
     5fa:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5fc:	89 83       	std	Y+1, r24	; 0x01
     5fe:	be 01       	movw	r22, r28
     600:	6f 5f       	subi	r22, 0xFF	; 255
     602:	7f 4f       	sbci	r23, 0xFF	; 255
     604:	80 ea       	ldi	r24, 0xA0	; 160
     606:	99 e0       	ldi	r25, 0x09	; 9
     608:	2c d4       	rcall	.+2136   	; 0xe62 <usart_spi_select_device>
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     610:	e0 ea       	ldi	r30, 0xA0	; 160
     612:	f9 e0       	ldi	r31, 0x09	; 9
     614:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     616:	85 ff       	sbrs	r24, 5
     618:	fd cf       	rjmp	.-6      	; 0x614 <st7565r_init+0x118>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     61a:	88 ec       	ldi	r24, 0xC8	; 200
     61c:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     620:	e0 ea       	ldi	r30, 0xA0	; 160
     622:	f9 e0       	ldi	r31, 0x09	; 9
     624:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     626:	86 ff       	sbrs	r24, 6
     628:	fd cf       	rjmp	.-6      	; 0x624 <st7565r_init+0x128>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     62a:	e0 ea       	ldi	r30, 0xA0	; 160
     62c:	f9 e0       	ldi	r31, 0x09	; 9
     62e:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     630:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     632:	80 81       	ld	r24, Z
     634:	be 01       	movw	r22, r28
     636:	6f 5f       	subi	r22, 0xFF	; 255
     638:	7f 4f       	sbci	r23, 0xFF	; 255
     63a:	80 ea       	ldi	r24, 0xA0	; 160
     63c:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     63e:	27 d4       	rcall	.+2126   	; 0xe8e <usart_spi_deselect_device>
     640:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     642:	89 83       	std	Y+1, r24	; 0x01
     644:	be 01       	movw	r22, r28
     646:	6f 5f       	subi	r22, 0xFF	; 255
     648:	7f 4f       	sbci	r23, 0xFF	; 255
     64a:	80 ea       	ldi	r24, 0xA0	; 160
     64c:	99 e0       	ldi	r25, 0x09	; 9
     64e:	09 d4       	rcall	.+2066   	; 0xe62 <usart_spi_select_device>
     650:	81 e0       	ldi	r24, 0x01	; 1
     652:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     656:	e0 ea       	ldi	r30, 0xA0	; 160
     658:	f9 e0       	ldi	r31, 0x09	; 9
     65a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     65c:	85 ff       	sbrs	r24, 5
     65e:	fd cf       	rjmp	.-6      	; 0x65a <st7565r_init+0x15e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     660:	82 ea       	ldi	r24, 0xA2	; 162
     662:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     666:	e0 ea       	ldi	r30, 0xA0	; 160
     668:	f9 e0       	ldi	r31, 0x09	; 9
     66a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     66c:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     66e:	fd cf       	rjmp	.-6      	; 0x66a <st7565r_init+0x16e>
     670:	e0 ea       	ldi	r30, 0xA0	; 160
     672:	f9 e0       	ldi	r31, 0x09	; 9
     674:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     676:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     678:	80 81       	ld	r24, Z
     67a:	be 01       	movw	r22, r28
     67c:	6f 5f       	subi	r22, 0xFF	; 255
     67e:	7f 4f       	sbci	r23, 0xFF	; 255
     680:	80 ea       	ldi	r24, 0xA0	; 160
     682:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     684:	04 d4       	rcall	.+2056   	; 0xe8e <usart_spi_deselect_device>
     686:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     688:	89 83       	std	Y+1, r24	; 0x01
     68a:	be 01       	movw	r22, r28
     68c:	6f 5f       	subi	r22, 0xFF	; 255
     68e:	7f 4f       	sbci	r23, 0xFF	; 255
     690:	80 ea       	ldi	r24, 0xA0	; 160
     692:	99 e0       	ldi	r25, 0x09	; 9
     694:	e6 d3       	rcall	.+1996   	; 0xe62 <usart_spi_select_device>
     696:	81 e0       	ldi	r24, 0x01	; 1
     698:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     69c:	e0 ea       	ldi	r30, 0xA0	; 160
     69e:	f9 e0       	ldi	r31, 0x09	; 9
     6a0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6a2:	85 ff       	sbrs	r24, 5
     6a4:	fd cf       	rjmp	.-6      	; 0x6a0 <st7565r_init+0x1a4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6a6:	8f e2       	ldi	r24, 0x2F	; 47
     6a8:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6ac:	e0 ea       	ldi	r30, 0xA0	; 160
     6ae:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6b0:	81 81       	ldd	r24, Z+1	; 0x01
     6b2:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6b4:	fd cf       	rjmp	.-6      	; 0x6b0 <st7565r_init+0x1b4>
     6b6:	e0 ea       	ldi	r30, 0xA0	; 160
     6b8:	f9 e0       	ldi	r31, 0x09	; 9
     6ba:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6bc:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6be:	80 81       	ld	r24, Z
     6c0:	be 01       	movw	r22, r28
     6c2:	6f 5f       	subi	r22, 0xFF	; 255
     6c4:	7f 4f       	sbci	r23, 0xFF	; 255
     6c6:	80 ea       	ldi	r24, 0xA0	; 160
     6c8:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6ca:	e1 d3       	rcall	.+1986   	; 0xe8e <usart_spi_deselect_device>
     6cc:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6ce:	89 83       	std	Y+1, r24	; 0x01
     6d0:	be 01       	movw	r22, r28
     6d2:	6f 5f       	subi	r22, 0xFF	; 255
     6d4:	7f 4f       	sbci	r23, 0xFF	; 255
     6d6:	80 ea       	ldi	r24, 0xA0	; 160
     6d8:	99 e0       	ldi	r25, 0x09	; 9
     6da:	c3 d3       	rcall	.+1926   	; 0xe62 <usart_spi_select_device>
     6dc:	81 e0       	ldi	r24, 0x01	; 1
     6de:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6e2:	e0 ea       	ldi	r30, 0xA0	; 160
     6e4:	f9 e0       	ldi	r31, 0x09	; 9
     6e6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6e8:	85 ff       	sbrs	r24, 5
     6ea:	fd cf       	rjmp	.-6      	; 0x6e6 <st7565r_init+0x1ea>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6ec:	88 ef       	ldi	r24, 0xF8	; 248
     6ee:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6f2:	e0 ea       	ldi	r30, 0xA0	; 160
     6f4:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6f6:	81 81       	ldd	r24, Z+1	; 0x01
     6f8:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6fa:	fd cf       	rjmp	.-6      	; 0x6f6 <st7565r_init+0x1fa>
     6fc:	e0 ea       	ldi	r30, 0xA0	; 160
     6fe:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     700:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     702:	81 83       	std	Z+1, r24	; 0x01
     704:	80 81       	ld	r24, Z
     706:	be 01       	movw	r22, r28
     708:	6f 5f       	subi	r22, 0xFF	; 255
     70a:	7f 4f       	sbci	r23, 0xFF	; 255
     70c:	80 ea       	ldi	r24, 0xA0	; 160
     70e:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     710:	be d3       	rcall	.+1916   	; 0xe8e <usart_spi_deselect_device>
     712:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     714:	89 83       	std	Y+1, r24	; 0x01
     716:	be 01       	movw	r22, r28
     718:	6f 5f       	subi	r22, 0xFF	; 255
     71a:	7f 4f       	sbci	r23, 0xFF	; 255
     71c:	80 ea       	ldi	r24, 0xA0	; 160
     71e:	99 e0       	ldi	r25, 0x09	; 9
     720:	a0 d3       	rcall	.+1856   	; 0xe62 <usart_spi_select_device>
     722:	81 e0       	ldi	r24, 0x01	; 1
     724:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     728:	e0 ea       	ldi	r30, 0xA0	; 160
     72a:	f9 e0       	ldi	r31, 0x09	; 9
     72c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     72e:	85 ff       	sbrs	r24, 5
     730:	fd cf       	rjmp	.-6      	; 0x72c <st7565r_init+0x230>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     732:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     736:	e0 ea       	ldi	r30, 0xA0	; 160
     738:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     73a:	81 81       	ldd	r24, Z+1	; 0x01
     73c:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     73e:	fd cf       	rjmp	.-6      	; 0x73a <st7565r_init+0x23e>
     740:	e0 ea       	ldi	r30, 0xA0	; 160
     742:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     744:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     746:	81 83       	std	Z+1, r24	; 0x01
     748:	80 81       	ld	r24, Z
     74a:	be 01       	movw	r22, r28
     74c:	6f 5f       	subi	r22, 0xFF	; 255
     74e:	7f 4f       	sbci	r23, 0xFF	; 255
     750:	80 ea       	ldi	r24, 0xA0	; 160
     752:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     754:	9c d3       	rcall	.+1848   	; 0xe8e <usart_spi_deselect_device>
     756:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     758:	89 83       	std	Y+1, r24	; 0x01
     75a:	be 01       	movw	r22, r28
     75c:	6f 5f       	subi	r22, 0xFF	; 255
     75e:	7f 4f       	sbci	r23, 0xFF	; 255
     760:	80 ea       	ldi	r24, 0xA0	; 160
     762:	99 e0       	ldi	r25, 0x09	; 9
     764:	7e d3       	rcall	.+1788   	; 0xe62 <usart_spi_select_device>
     766:	81 e0       	ldi	r24, 0x01	; 1
     768:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     76c:	e0 ea       	ldi	r30, 0xA0	; 160
     76e:	f9 e0       	ldi	r31, 0x09	; 9
     770:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     772:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     774:	fd cf       	rjmp	.-6      	; 0x770 <st7565r_init+0x274>
     776:	81 e2       	ldi	r24, 0x21	; 33
     778:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     77c:	e0 ea       	ldi	r30, 0xA0	; 160
     77e:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     780:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     782:	86 ff       	sbrs	r24, 6
     784:	fd cf       	rjmp	.-6      	; 0x780 <st7565r_init+0x284>
     786:	e0 ea       	ldi	r30, 0xA0	; 160
     788:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     78a:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     78c:	81 83       	std	Z+1, r24	; 0x01
     78e:	80 81       	ld	r24, Z
     790:	be 01       	movw	r22, r28
     792:	6f 5f       	subi	r22, 0xFF	; 255
     794:	7f 4f       	sbci	r23, 0xFF	; 255
     796:	80 ea       	ldi	r24, 0xA0	; 160
     798:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     79a:	79 d3       	rcall	.+1778   	; 0xe8e <usart_spi_deselect_device>
     79c:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     79e:	89 83       	std	Y+1, r24	; 0x01
     7a0:	be 01       	movw	r22, r28
     7a2:	6f 5f       	subi	r22, 0xFF	; 255
     7a4:	7f 4f       	sbci	r23, 0xFF	; 255
     7a6:	80 ea       	ldi	r24, 0xA0	; 160
     7a8:	99 e0       	ldi	r25, 0x09	; 9
     7aa:	5b d3       	rcall	.+1718   	; 0xe62 <usart_spi_select_device>
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7b2:	e0 ea       	ldi	r30, 0xA0	; 160
     7b4:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7b6:	81 81       	ldd	r24, Z+1	; 0x01
     7b8:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7ba:	fd cf       	rjmp	.-6      	; 0x7b6 <st7565r_init+0x2ba>
     7bc:	81 e8       	ldi	r24, 0x81	; 129
     7be:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7c2:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7c4:	f9 e0       	ldi	r31, 0x09	; 9
     7c6:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7c8:	86 ff       	sbrs	r24, 6
     7ca:	fd cf       	rjmp	.-6      	; 0x7c6 <st7565r_init+0x2ca>
     7cc:	e0 ea       	ldi	r30, 0xA0	; 160
     7ce:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7d0:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7d2:	81 83       	std	Z+1, r24	; 0x01
     7d4:	80 81       	ld	r24, Z
     7d6:	be 01       	movw	r22, r28
     7d8:	6f 5f       	subi	r22, 0xFF	; 255
     7da:	7f 4f       	sbci	r23, 0xFF	; 255
     7dc:	80 ea       	ldi	r24, 0xA0	; 160
     7de:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7e0:	56 d3       	rcall	.+1708   	; 0xe8e <usart_spi_deselect_device>
     7e2:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7e4:	89 83       	std	Y+1, r24	; 0x01
     7e6:	be 01       	movw	r22, r28
     7e8:	6f 5f       	subi	r22, 0xFF	; 255
     7ea:	7f 4f       	sbci	r23, 0xFF	; 255
     7ec:	80 ea       	ldi	r24, 0xA0	; 160
     7ee:	99 e0       	ldi	r25, 0x09	; 9
     7f0:	38 d3       	rcall	.+1648   	; 0xe62 <usart_spi_select_device>
     7f2:	81 e0       	ldi	r24, 0x01	; 1
     7f4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7f8:	e0 ea       	ldi	r30, 0xA0	; 160
     7fa:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7fc:	81 81       	ldd	r24, Z+1	; 0x01
     7fe:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     800:	fd cf       	rjmp	.-6      	; 0x7fc <st7565r_init+0x300>
     802:	81 e2       	ldi	r24, 0x21	; 33
     804:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     808:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     80a:	f9 e0       	ldi	r31, 0x09	; 9
     80c:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     80e:	86 ff       	sbrs	r24, 6
     810:	fd cf       	rjmp	.-6      	; 0x80c <st7565r_init+0x310>
     812:	e0 ea       	ldi	r30, 0xA0	; 160
     814:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     816:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     818:	81 83       	std	Z+1, r24	; 0x01
     81a:	80 81       	ld	r24, Z
     81c:	be 01       	movw	r22, r28
     81e:	6f 5f       	subi	r22, 0xFF	; 255
     820:	7f 4f       	sbci	r23, 0xFF	; 255
     822:	80 ea       	ldi	r24, 0xA0	; 160
     824:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     826:	33 d3       	rcall	.+1638   	; 0xe8e <usart_spi_deselect_device>
     828:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     82a:	89 83       	std	Y+1, r24	; 0x01
     82c:	be 01       	movw	r22, r28
     82e:	6f 5f       	subi	r22, 0xFF	; 255
     830:	7f 4f       	sbci	r23, 0xFF	; 255
     832:	80 ea       	ldi	r24, 0xA0	; 160
     834:	99 e0       	ldi	r25, 0x09	; 9
     836:	15 d3       	rcall	.+1578   	; 0xe62 <usart_spi_select_device>
     838:	81 e0       	ldi	r24, 0x01	; 1
     83a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     83e:	e0 ea       	ldi	r30, 0xA0	; 160
     840:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     842:	81 81       	ldd	r24, Z+1	; 0x01
     844:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     846:	fd cf       	rjmp	.-6      	; 0x842 <st7565r_init+0x346>
     848:	8f ea       	ldi	r24, 0xAF	; 175
     84a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     84e:	e0 ea       	ldi	r30, 0xA0	; 160
     850:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     852:	81 81       	ldd	r24, Z+1	; 0x01
     854:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     856:	fd cf       	rjmp	.-6      	; 0x852 <st7565r_init+0x356>
     858:	e0 ea       	ldi	r30, 0xA0	; 160
     85a:	f9 e0       	ldi	r31, 0x09	; 9
     85c:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     85e:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     860:	80 81       	ld	r24, Z
     862:	be 01       	movw	r22, r28
     864:	6f 5f       	subi	r22, 0xFF	; 255
     866:	7f 4f       	sbci	r23, 0xFF	; 255
     868:	80 ea       	ldi	r24, 0xA0	; 160
     86a:	99 e0       	ldi	r25, 0x09	; 9
     86c:	10 d3       	rcall	.+1568   	; 0xe8e <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     86e:	0f 90       	pop	r0
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	1f 91       	pop	r17
     876:	0f 91       	pop	r16
     878:	ff 90       	pop	r15
     87a:	ef 90       	pop	r14
     87c:	df 90       	pop	r13
     87e:	cf 90       	pop	r12
     880:	bf 90       	pop	r11
     882:	08 95       	ret

00000884 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
     884:	8f ef       	ldi	r24, 0xFF	; 255
     886:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
     88a:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
     88e:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
     892:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
     896:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
     89a:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
     89e:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>
     8a2:	08 95       	ret

000008a4 <sysclk_enable_module>:
	sysclk_rtcsrc_enable(CONFIG_RTC_SOURCE);
#endif
}

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	1f 92       	push	r1
     8aa:	cd b7       	in	r28, 0x3d	; 61
     8ac:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     8ae:	9f b7       	in	r25, 0x3f	; 63
     8b0:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
     8b2:	f8 94       	cli
	return flags;
     8b4:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     8b6:	e8 2f       	mov	r30, r24
     8b8:	f0 e0       	ldi	r31, 0x00	; 0
     8ba:	e0 59       	subi	r30, 0x90	; 144
     8bc:	ff 4f       	sbci	r31, 0xFF	; 255
     8be:	60 95       	com	r22
     8c0:	80 81       	ld	r24, Z
     8c2:	68 23       	and	r22, r24
     8c4:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     8c6:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
     8c8:	0f 90       	pop	r0
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <sysclk_disable_module>:

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	1f 92       	push	r1
     8d6:	cd b7       	in	r28, 0x3d	; 61
     8d8:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     8da:	9f b7       	in	r25, 0x3f	; 63
     8dc:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
     8de:	f8 94       	cli
	return flags;
     8e0:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     8e2:	e8 2f       	mov	r30, r24
     8e4:	f0 e0       	ldi	r31, 0x00	; 0
     8e6:	e0 59       	subi	r30, 0x90	; 144
     8e8:	ff 4f       	sbci	r31, 0xFF	; 255
     8ea:	80 81       	ld	r24, Z
     8ec:	68 2b       	or	r22, r24
     8ee:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     8f0:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
     8f2:	0f 90       	pop	r0
     8f4:	df 91       	pop	r29
     8f6:	cf 91       	pop	r28
     8f8:	08 95       	ret

000008fa <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     8fa:	ff 92       	push	r15
     8fc:	0f 93       	push	r16
     8fe:	1f 93       	push	r17
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	1f 92       	push	r1
     906:	cd b7       	in	r28, 0x3d	; 61
     908:	de b7       	in	r29, 0x3e	; 62
     90a:	08 2f       	mov	r16, r24
     90c:	f6 2e       	mov	r15, r22
     90e:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     910:	1a d1       	rcall	.+564    	; 0xb46 <gfx_mono_framebuffer_put_byte>
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     912:	0f 70       	andi	r16, 0x0F	; 15
     914:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     916:	8b e2       	ldi	r24, 0x2B	; 43
     918:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     91a:	be 01       	movw	r22, r28
     91c:	6f 5f       	subi	r22, 0xFF	; 255
     91e:	7f 4f       	sbci	r23, 0xFF	; 255
     920:	80 ea       	ldi	r24, 0xA0	; 160
     922:	99 e0       	ldi	r25, 0x09	; 9
     924:	9e d2       	rcall	.+1340   	; 0xe62 <usart_spi_select_device>
     926:	81 e0       	ldi	r24, 0x01	; 1
     928:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     92c:	e0 ea       	ldi	r30, 0xA0	; 160
     92e:	f9 e0       	ldi	r31, 0x09	; 9
     930:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     932:	95 ff       	sbrs	r25, 5
     934:	fd cf       	rjmp	.-6      	; 0x930 <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     936:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     93a:	e0 ea       	ldi	r30, 0xA0	; 160
     93c:	f9 e0       	ldi	r31, 0x09	; 9
     93e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     940:	86 ff       	sbrs	r24, 6
     942:	fd cf       	rjmp	.-6      	; 0x93e <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     944:	e0 ea       	ldi	r30, 0xA0	; 160
     946:	f9 e0       	ldi	r31, 0x09	; 9
     948:	80 e4       	ldi	r24, 0x40	; 64
     94a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     94c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     94e:	be 01       	movw	r22, r28
     950:	6f 5f       	subi	r22, 0xFF	; 255
     952:	7f 4f       	sbci	r23, 0xFF	; 255
     954:	80 ea       	ldi	r24, 0xA0	; 160
     956:	99 e0       	ldi	r25, 0x09	; 9
     958:	9a d2       	rcall	.+1332   	; 0xe8e <usart_spi_deselect_device>
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     95a:	0f 2d       	mov	r16, r15
     95c:	0f 77       	andi	r16, 0x7F	; 127
     95e:	02 95       	swap	r16
     960:	0f 70       	andi	r16, 0x0F	; 15
     962:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     964:	8b e2       	ldi	r24, 0x2B	; 43
     966:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     968:	be 01       	movw	r22, r28
     96a:	6f 5f       	subi	r22, 0xFF	; 255
     96c:	7f 4f       	sbci	r23, 0xFF	; 255
     96e:	80 ea       	ldi	r24, 0xA0	; 160
     970:	99 e0       	ldi	r25, 0x09	; 9
     972:	77 d2       	rcall	.+1262   	; 0xe62 <usart_spi_select_device>
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     97a:	e0 ea       	ldi	r30, 0xA0	; 160
     97c:	f9 e0       	ldi	r31, 0x09	; 9
     97e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     980:	85 ff       	sbrs	r24, 5
     982:	fd cf       	rjmp	.-6      	; 0x97e <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     984:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     988:	e0 ea       	ldi	r30, 0xA0	; 160
     98a:	f9 e0       	ldi	r31, 0x09	; 9
     98c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     98e:	86 ff       	sbrs	r24, 6
     990:	fd cf       	rjmp	.-6      	; 0x98c <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     992:	e0 ea       	ldi	r30, 0xA0	; 160
     994:	f9 e0       	ldi	r31, 0x09	; 9
     996:	80 e4       	ldi	r24, 0x40	; 64
     998:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     99a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     99c:	be 01       	movw	r22, r28
     99e:	6f 5f       	subi	r22, 0xFF	; 255
     9a0:	7f 4f       	sbci	r23, 0xFF	; 255
     9a2:	80 ea       	ldi	r24, 0xA0	; 160
     9a4:	99 e0       	ldi	r25, 0x09	; 9
     9a6:	73 d2       	rcall	.+1254   	; 0xe8e <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     9a8:	0f 2d       	mov	r16, r15
     9aa:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9ac:	8b e2       	ldi	r24, 0x2B	; 43
     9ae:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9b0:	be 01       	movw	r22, r28
     9b2:	6f 5f       	subi	r22, 0xFF	; 255
     9b4:	7f 4f       	sbci	r23, 0xFF	; 255
     9b6:	80 ea       	ldi	r24, 0xA0	; 160
     9b8:	99 e0       	ldi	r25, 0x09	; 9
     9ba:	53 d2       	rcall	.+1190   	; 0xe62 <usart_spi_select_device>
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9c2:	e0 ea       	ldi	r30, 0xA0	; 160
     9c4:	f9 e0       	ldi	r31, 0x09	; 9
     9c6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9c8:	85 ff       	sbrs	r24, 5
     9ca:	fd cf       	rjmp	.-6      	; 0x9c6 <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9cc:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9d0:	e0 ea       	ldi	r30, 0xA0	; 160
     9d2:	f9 e0       	ldi	r31, 0x09	; 9
     9d4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9d6:	86 ff       	sbrs	r24, 6
     9d8:	fd cf       	rjmp	.-6      	; 0x9d4 <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9da:	e0 ea       	ldi	r30, 0xA0	; 160
     9dc:	f9 e0       	ldi	r31, 0x09	; 9
     9de:	80 e4       	ldi	r24, 0x40	; 64
     9e0:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9e2:	80 81       	ld	r24, Z
     9e4:	be 01       	movw	r22, r28
     9e6:	6f 5f       	subi	r22, 0xFF	; 255
     9e8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ea:	80 ea       	ldi	r24, 0xA0	; 160
     9ec:	99 e0       	ldi	r25, 0x09	; 9
     9ee:	4f d2       	rcall	.+1182   	; 0xe8e <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9f0:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9f2:	89 83       	std	Y+1, r24	; 0x01
     9f4:	be 01       	movw	r22, r28
     9f6:	6f 5f       	subi	r22, 0xFF	; 255
     9f8:	7f 4f       	sbci	r23, 0xFF	; 255
     9fa:	80 ea       	ldi	r24, 0xA0	; 160
     9fc:	99 e0       	ldi	r25, 0x09	; 9
     9fe:	31 d2       	rcall	.+1122   	; 0xe62 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a06:	e0 ea       	ldi	r30, 0xA0	; 160
     a08:	f9 e0       	ldi	r31, 0x09	; 9
     a0a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a0c:	85 ff       	sbrs	r24, 5
     a0e:	fd cf       	rjmp	.-6      	; 0xa0a <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a10:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a14:	e0 ea       	ldi	r30, 0xA0	; 160
     a16:	f9 e0       	ldi	r31, 0x09	; 9
     a18:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a1a:	86 ff       	sbrs	r24, 6
     a1c:	fd cf       	rjmp	.-6      	; 0xa18 <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a1e:	e0 ea       	ldi	r30, 0xA0	; 160
     a20:	f9 e0       	ldi	r31, 0x09	; 9
     a22:	80 e4       	ldi	r24, 0x40	; 64
     a24:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a26:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     a28:	81 e0       	ldi	r24, 0x01	; 1
     a2a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a2e:	be 01       	movw	r22, r28
     a30:	6f 5f       	subi	r22, 0xFF	; 255
     a32:	7f 4f       	sbci	r23, 0xFF	; 255
     a34:	80 ea       	ldi	r24, 0xA0	; 160
     a36:	99 e0       	ldi	r25, 0x09	; 9
     a38:	2a d2       	rcall	.+1108   	; 0xe8e <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     a3a:	0f 90       	pop	r0
     a3c:	df 91       	pop	r29
     a3e:	cf 91       	pop	r28
     a40:	1f 91       	pop	r17
     a42:	0f 91       	pop	r16
     a44:	ff 90       	pop	r15
     a46:	08 95       	ret

00000a48 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	cf 93       	push	r28
     a4e:	df 93       	push	r29
     a50:	1f 92       	push	r1
     a52:	cd b7       	in	r28, 0x3d	; 61
     a54:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a56:	8a e4       	ldi	r24, 0x4A	; 74
     a58:	90 e2       	ldi	r25, 0x20	; 32
     a5a:	70 d0       	rcall	.+224    	; 0xb3c <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a5c:	4f dd       	rcall	.-1378   	; 0x4fc <st7565r_init>
     a5e:	8b e2       	ldi	r24, 0x2B	; 43
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a60:	89 83       	std	Y+1, r24	; 0x01
     a62:	be 01       	movw	r22, r28
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a64:	6f 5f       	subi	r22, 0xFF	; 255
     a66:	7f 4f       	sbci	r23, 0xFF	; 255
     a68:	80 ea       	ldi	r24, 0xA0	; 160
     a6a:	99 e0       	ldi	r25, 0x09	; 9
     a6c:	fa d1       	rcall	.+1012   	; 0xe62 <usart_spi_select_device>
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     a74:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a76:	f9 e0       	ldi	r31, 0x09	; 9
     a78:	81 81       	ldd	r24, Z+1	; 0x01
     a7a:	85 ff       	sbrs	r24, 5
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a7c:	fd cf       	rjmp	.-6      	; 0xa78 <gfx_mono_st7565r_init+0x30>
     a7e:	80 e4       	ldi	r24, 0x40	; 64
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a80:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     a84:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a86:	f9 e0       	ldi	r31, 0x09	; 9
     a88:	81 81       	ldd	r24, Z+1	; 0x01
     a8a:	86 ff       	sbrs	r24, 6
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a8c:	fd cf       	rjmp	.-6      	; 0xa88 <gfx_mono_st7565r_init+0x40>
     a8e:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a90:	f9 e0       	ldi	r31, 0x09	; 9
     a92:	80 e4       	ldi	r24, 0x40	; 64
     a94:	81 83       	std	Z+1, r24	; 0x01
     a96:	80 81       	ld	r24, Z
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a98:	be 01       	movw	r22, r28
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a9a:	6f 5f       	subi	r22, 0xFF	; 255
     a9c:	7f 4f       	sbci	r23, 0xFF	; 255
     a9e:	80 ea       	ldi	r24, 0xA0	; 160
     aa0:	99 e0       	ldi	r25, 0x09	; 9
     aa2:	f5 d1       	rcall	.+1002   	; 0xe8e <usart_spi_deselect_device>
     aa4:	00 e0       	ldi	r16, 0x00	; 0

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     aa6:	0a c0       	rjmp	.+20     	; 0xabc <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     aa8:	40 e0       	ldi	r20, 0x00	; 0
     aaa:	61 2f       	mov	r22, r17
     aac:	80 2f       	mov	r24, r16
     aae:	25 df       	rcall	.-438    	; 0x8fa <gfx_mono_st7565r_put_byte>
     ab0:	1f 5f       	subi	r17, 0xFF	; 255
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     ab2:	10 38       	cpi	r17, 0x80	; 128
     ab4:	c9 f7       	brne	.-14     	; 0xaa8 <gfx_mono_st7565r_init+0x60>
     ab6:	0f 5f       	subi	r16, 0xFF	; 255

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     ab8:	04 30       	cpi	r16, 0x04	; 4
     aba:	11 f0       	breq	.+4      	; 0xac0 <gfx_mono_st7565r_init+0x78>
     abc:	10 e0       	ldi	r17, 0x00	; 0
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     abe:	f4 cf       	rjmp	.-24     	; 0xaa8 <gfx_mono_st7565r_init+0x60>
     ac0:	0f 90       	pop	r0
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	1f 91       	pop	r17
     ac8:	0f 91       	pop	r16
     aca:	08 95       	ret

00000acc <gfx_mono_st7565r_draw_pixel>:
     acc:	ff 92       	push	r15
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     ace:	0f 93       	push	r16
     ad0:	1f 93       	push	r17
     ad2:	cf 93       	push	r28
     ad4:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     ad6:	88 23       	and	r24, r24
     ad8:	4c f1       	brlt	.+82     	; 0xb2c <gfx_mono_st7565r_draw_pixel+0x60>
     ada:	60 32       	cpi	r22, 0x20	; 32
     adc:	38 f5       	brcc	.+78     	; 0xb2c <gfx_mono_st7565r_draw_pixel+0x60>
     ade:	d4 2f       	mov	r29, r20
     ae0:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     ae2:	f6 2e       	mov	r15, r22
     ae4:	f6 94       	lsr	r15
     ae6:	f6 94       	lsr	r15
     ae8:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     aea:	70 e0       	ldi	r23, 0x00	; 0
     aec:	88 e0       	ldi	r24, 0x08	; 8
     aee:	f8 9e       	mul	r15, r24
     af0:	60 19       	sub	r22, r0
     af2:	71 09       	sbc	r23, r1
     af4:	11 24       	eor	r1, r1
     af6:	81 e0       	ldi	r24, 0x01	; 1
     af8:	90 e0       	ldi	r25, 0x00	; 0
     afa:	8c 01       	movw	r16, r24
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <gfx_mono_st7565r_draw_pixel+0x36>
     afe:	00 0f       	add	r16, r16
     b00:	11 1f       	adc	r17, r17
     b02:	6a 95       	dec	r22
     b04:	e2 f7       	brpl	.-8      	; 0xafe <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     b06:	6c 2f       	mov	r22, r28
     b08:	8f 2d       	mov	r24, r15
     b0a:	2b d0       	rcall	.+86     	; 0xb62 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     b0c:	d1 30       	cpi	r29, 0x01	; 1
     b0e:	21 f0       	breq	.+8      	; 0xb18 <gfx_mono_st7565r_draw_pixel+0x4c>
     b10:	28 f0       	brcs	.+10     	; 0xb1c <gfx_mono_st7565r_draw_pixel+0x50>
     b12:	d2 30       	cpi	r29, 0x02	; 2
     b14:	31 f0       	breq	.+12     	; 0xb22 <gfx_mono_st7565r_draw_pixel+0x56>
     b16:	06 c0       	rjmp	.+12     	; 0xb24 <gfx_mono_st7565r_draw_pixel+0x58>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     b18:	80 2b       	or	r24, r16
		break;
     b1a:	04 c0       	rjmp	.+8      	; 0xb24 <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     b1c:	00 95       	com	r16
     b1e:	80 23       	and	r24, r16
		break;
     b20:	01 c0       	rjmp	.+2      	; 0xb24 <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     b22:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     b24:	48 2f       	mov	r20, r24
     b26:	6c 2f       	mov	r22, r28
     b28:	8f 2d       	mov	r24, r15
     b2a:	e7 de       	rcall	.-562    	; 0x8fa <gfx_mono_st7565r_put_byte>
}
     b2c:	df 91       	pop	r29
     b2e:	cf 91       	pop	r28
     b30:	1f 91       	pop	r17
     b32:	0f 91       	pop	r16
     b34:	ff 90       	pop	r15
     b36:	08 95       	ret

00000b38 <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     b38:	14 c0       	rjmp	.+40     	; 0xb62 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     b3a:	08 95       	ret

00000b3c <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     b3c:	80 93 4a 22 	sts	0x224A, r24	; 0x80224a <fbpointer>
     b40:	90 93 4b 22 	sts	0x224B, r25	; 0x80224b <fbpointer+0x1>
     b44:	08 95       	ret

00000b46 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     b46:	20 91 4a 22 	lds	r18, 0x224A	; 0x80224a <fbpointer>
     b4a:	30 91 4b 22 	lds	r19, 0x224B	; 0x80224b <fbpointer+0x1>
     b4e:	90 e8       	ldi	r25, 0x80	; 128
     b50:	89 9f       	mul	r24, r25
     b52:	20 0d       	add	r18, r0
     b54:	31 1d       	adc	r19, r1
     b56:	11 24       	eor	r1, r1
     b58:	f9 01       	movw	r30, r18
     b5a:	e6 0f       	add	r30, r22
     b5c:	f1 1d       	adc	r31, r1
     b5e:	40 83       	st	Z, r20
     b60:	08 95       	ret

00000b62 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     b62:	20 91 4a 22 	lds	r18, 0x224A	; 0x80224a <fbpointer>
     b66:	30 91 4b 22 	lds	r19, 0x224B	; 0x80224b <fbpointer+0x1>
     b6a:	90 e8       	ldi	r25, 0x80	; 128
     b6c:	89 9f       	mul	r24, r25
     b6e:	20 0d       	add	r18, r0
     b70:	31 1d       	adc	r19, r1
     b72:	11 24       	eor	r1, r1
     b74:	f9 01       	movw	r30, r18
     b76:	e6 0f       	add	r30, r22
     b78:	f1 1d       	adc	r31, r1
}
     b7a:	80 81       	ld	r24, Z
     b7c:	08 95       	ret

00000b7e <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b7e:	ff 92       	push	r15
     b80:	0f 93       	push	r16
     b82:	1f 93       	push	r17
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	e4 2f       	mov	r30, r20
     b8a:	f0 e0       	ldi	r31, 0x00	; 0
     b8c:	e8 0f       	add	r30, r24
     b8e:	f1 1d       	adc	r31, r1
     b90:	e1 38       	cpi	r30, 0x81	; 129
     b92:	f1 05       	cpc	r31, r1
     b94:	1c f0       	brlt	.+6      	; 0xb9c <gfx_mono_generic_draw_horizontal_line+0x1e>
     b96:	c0 e8       	ldi	r28, 0x80	; 128
     b98:	4c 2f       	mov	r20, r28
     b9a:	48 1b       	sub	r20, r24
     b9c:	44 23       	and	r20, r20
     b9e:	09 f4       	brne	.+2      	; 0xba2 <gfx_mono_generic_draw_horizontal_line+0x24>
     ba0:	4a c0       	rjmp	.+148    	; 0xc36 <gfx_mono_generic_draw_horizontal_line+0xb8>
     ba2:	d6 2f       	mov	r29, r22
     ba4:	d6 95       	lsr	r29
     ba6:	d6 95       	lsr	r29
     ba8:	d6 95       	lsr	r29
     baa:	70 e0       	ldi	r23, 0x00	; 0
     bac:	98 e0       	ldi	r25, 0x08	; 8
     bae:	d9 9f       	mul	r29, r25
     bb0:	60 19       	sub	r22, r0
     bb2:	71 09       	sbc	r23, r1
     bb4:	11 24       	eor	r1, r1
     bb6:	e1 e0       	ldi	r30, 0x01	; 1
     bb8:	f0 e0       	ldi	r31, 0x00	; 0
     bba:	df 01       	movw	r26, r30
     bbc:	02 c0       	rjmp	.+4      	; 0xbc2 <gfx_mono_generic_draw_horizontal_line+0x44>
     bbe:	aa 0f       	add	r26, r26
     bc0:	bb 1f       	adc	r27, r27
     bc2:	6a 95       	dec	r22
     bc4:	e2 f7       	brpl	.-8      	; 0xbbe <gfx_mono_generic_draw_horizontal_line+0x40>
     bc6:	fa 2e       	mov	r15, r26
     bc8:	21 30       	cpi	r18, 0x01	; 1
     bca:	21 f0       	breq	.+8      	; 0xbd4 <gfx_mono_generic_draw_horizontal_line+0x56>
     bcc:	98 f0       	brcs	.+38     	; 0xbf4 <gfx_mono_generic_draw_horizontal_line+0x76>
     bce:	22 30       	cpi	r18, 0x02	; 2
     bd0:	19 f1       	breq	.+70     	; 0xc18 <gfx_mono_generic_draw_horizontal_line+0x9a>
     bd2:	31 c0       	rjmp	.+98     	; 0xc36 <gfx_mono_generic_draw_horizontal_line+0xb8>
     bd4:	c4 2f       	mov	r28, r20
     bd6:	1f ef       	ldi	r17, 0xFF	; 255
     bd8:	18 0f       	add	r17, r24
     bda:	01 2f       	mov	r16, r17
     bdc:	0c 0f       	add	r16, r28
     bde:	60 2f       	mov	r22, r16
     be0:	8d 2f       	mov	r24, r29
     be2:	aa df       	rcall	.-172    	; 0xb38 <gfx_mono_st7565r_get_byte>
     be4:	4f 2d       	mov	r20, r15
     be6:	48 2b       	or	r20, r24
     be8:	60 2f       	mov	r22, r16
     bea:	8d 2f       	mov	r24, r29
     bec:	86 de       	rcall	.-756    	; 0x8fa <gfx_mono_st7565r_put_byte>
     bee:	c1 50       	subi	r28, 0x01	; 1
     bf0:	a1 f7       	brne	.-24     	; 0xbda <gfx_mono_generic_draw_horizontal_line+0x5c>
     bf2:	21 c0       	rjmp	.+66     	; 0xc36 <gfx_mono_generic_draw_horizontal_line+0xb8>
     bf4:	c4 2f       	mov	r28, r20
     bf6:	1f ef       	ldi	r17, 0xFF	; 255
     bf8:	18 0f       	add	r17, r24
     bfa:	fa 2e       	mov	r15, r26
     bfc:	f0 94       	com	r15
     bfe:	01 2f       	mov	r16, r17
     c00:	0c 0f       	add	r16, r28
     c02:	60 2f       	mov	r22, r16
     c04:	8d 2f       	mov	r24, r29
     c06:	98 df       	rcall	.-208    	; 0xb38 <gfx_mono_st7565r_get_byte>
     c08:	4f 2d       	mov	r20, r15
     c0a:	48 23       	and	r20, r24
     c0c:	60 2f       	mov	r22, r16
     c0e:	8d 2f       	mov	r24, r29
     c10:	74 de       	rcall	.-792    	; 0x8fa <gfx_mono_st7565r_put_byte>
     c12:	c1 50       	subi	r28, 0x01	; 1
     c14:	a1 f7       	brne	.-24     	; 0xbfe <gfx_mono_generic_draw_horizontal_line+0x80>
     c16:	0f c0       	rjmp	.+30     	; 0xc36 <gfx_mono_generic_draw_horizontal_line+0xb8>
     c18:	c4 2f       	mov	r28, r20
     c1a:	1f ef       	ldi	r17, 0xFF	; 255
     c1c:	18 0f       	add	r17, r24
     c1e:	01 2f       	mov	r16, r17
     c20:	0c 0f       	add	r16, r28
     c22:	60 2f       	mov	r22, r16
     c24:	8d 2f       	mov	r24, r29
     c26:	88 df       	rcall	.-240    	; 0xb38 <gfx_mono_st7565r_get_byte>
     c28:	4f 2d       	mov	r20, r15
     c2a:	48 27       	eor	r20, r24
     c2c:	60 2f       	mov	r22, r16
     c2e:	8d 2f       	mov	r24, r29
     c30:	64 de       	rcall	.-824    	; 0x8fa <gfx_mono_st7565r_put_byte>
     c32:	c1 50       	subi	r28, 0x01	; 1
     c34:	a1 f7       	brne	.-24     	; 0xc1e <gfx_mono_generic_draw_horizontal_line+0xa0>
     c36:	df 91       	pop	r29
     c38:	cf 91       	pop	r28
     c3a:	1f 91       	pop	r17
     c3c:	0f 91       	pop	r16
     c3e:	ff 90       	pop	r15
     c40:	08 95       	ret

00000c42 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     c42:	ff 92       	push	r15
     c44:	0f 93       	push	r16
     c46:	1f 93       	push	r17
     c48:	cf 93       	push	r28
     c4a:	df 93       	push	r29
	if (height == 0) {
     c4c:	22 23       	and	r18, r18
     c4e:	69 f0       	breq	.+26     	; 0xc6a <gfx_mono_generic_draw_filled_rect+0x28>
     c50:	f4 2e       	mov	r15, r20
     c52:	18 2f       	mov	r17, r24
     c54:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c56:	df ef       	ldi	r29, 0xFF	; 255
     c58:	d6 0f       	add	r29, r22
     c5a:	6d 2f       	mov	r22, r29
     c5c:	6c 0f       	add	r22, r28
     c5e:	20 2f       	mov	r18, r16
     c60:	4f 2d       	mov	r20, r15
     c62:	81 2f       	mov	r24, r17
     c64:	8c df       	rcall	.-232    	; 0xb7e <gfx_mono_generic_draw_horizontal_line>
     c66:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c68:	c1 f7       	brne	.-16     	; 0xc5a <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	1f 91       	pop	r17
     c70:	0f 91       	pop	r16
     c72:	ff 90       	pop	r15
     c74:	08 95       	ret

00000c76 <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c76:	af 92       	push	r10
     c78:	bf 92       	push	r11
     c7a:	cf 92       	push	r12
     c7c:	df 92       	push	r13
     c7e:	ef 92       	push	r14
     c80:	ff 92       	push	r15
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
     c8a:	c8 2f       	mov	r28, r24
     c8c:	e6 2e       	mov	r14, r22
     c8e:	b4 2e       	mov	r11, r20
     c90:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c92:	00 e0       	ldi	r16, 0x00	; 0
     c94:	f9 01       	movw	r30, r18
     c96:	24 81       	ldd	r18, Z+4	; 0x04
     c98:	43 81       	ldd	r20, Z+3	; 0x03
     c9a:	6b 2d       	mov	r22, r11
     c9c:	8e 2d       	mov	r24, r14
     c9e:	d1 df       	rcall	.-94     	; 0xc42 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     ca0:	f6 01       	movw	r30, r12
     ca2:	80 81       	ld	r24, Z
     ca4:	81 11       	cpse	r24, r1
     ca6:	39 c0       	rjmp	.+114    	; 0xd1a <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     ca8:	83 81       	ldd	r24, Z+3	; 0x03
     caa:	28 2f       	mov	r18, r24
     cac:	26 95       	lsr	r18
     cae:	26 95       	lsr	r18
     cb0:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     cb2:	87 70       	andi	r24, 0x07	; 7
     cb4:	09 f0       	breq	.+2      	; 0xcb8 <gfx_mono_draw_char+0x42>
		char_row_size++;
     cb6:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     cb8:	f6 01       	movw	r30, r12
     cba:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     cbc:	8c 2f       	mov	r24, r28
     cbe:	90 e0       	ldi	r25, 0x00	; 0
     cc0:	35 81       	ldd	r19, Z+5	; 0x05
     cc2:	83 1b       	sub	r24, r19
     cc4:	91 09       	sbc	r25, r1
     cc6:	2a 9d       	mul	r18, r10
     cc8:	90 01       	movw	r18, r0
     cca:	11 24       	eor	r1, r1
     ccc:	82 9f       	mul	r24, r18
     cce:	a0 01       	movw	r20, r0
     cd0:	83 9f       	mul	r24, r19
     cd2:	50 0d       	add	r21, r0
     cd4:	92 9f       	mul	r25, r18
     cd6:	50 0d       	add	r21, r0
     cd8:	11 24       	eor	r1, r1
     cda:	01 81       	ldd	r16, Z+1	; 0x01
     cdc:	12 81       	ldd	r17, Z+2	; 0x02
     cde:	04 0f       	add	r16, r20
     ce0:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     ce2:	f6 01       	movw	r30, r12
     ce4:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     ce6:	ff 20       	and	r15, r15
     ce8:	a1 f0       	breq	.+40     	; 0xd12 <gfx_mono_draw_char+0x9c>
     cea:	d0 e0       	ldi	r29, 0x00	; 0
     cec:	c0 e0       	ldi	r28, 0x00	; 0
     cee:	8e 2d       	mov	r24, r14
     cf0:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     cf2:	9c 2f       	mov	r25, r28
     cf4:	97 70       	andi	r25, 0x07	; 7
     cf6:	21 f4       	brne	.+8      	; 0xd00 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     cf8:	f8 01       	movw	r30, r16
     cfa:	d4 91       	lpm	r29, Z
				glyph_data++;
     cfc:	0f 5f       	subi	r16, 0xFF	; 255
     cfe:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     d00:	dd 23       	and	r29, r29
     d02:	1c f4       	brge	.+6      	; 0xd0a <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     d04:	41 e0       	ldi	r20, 0x01	; 1
     d06:	6b 2d       	mov	r22, r11
     d08:	e1 de       	rcall	.-574    	; 0xacc <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     d0a:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     d0c:	cf 5f       	subi	r28, 0xFF	; 255
     d0e:	fc 12       	cpse	r15, r28
     d10:	ee cf       	rjmp	.-36     	; 0xcee <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     d12:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     d14:	aa 94       	dec	r10
	} while (rows_left > 0);
     d16:	a1 10       	cpse	r10, r1
     d18:	e4 cf       	rjmp	.-56     	; 0xce2 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     d1a:	df 91       	pop	r29
     d1c:	cf 91       	pop	r28
     d1e:	1f 91       	pop	r17
     d20:	0f 91       	pop	r16
     d22:	ff 90       	pop	r15
     d24:	ef 90       	pop	r14
     d26:	df 90       	pop	r13
     d28:	cf 90       	pop	r12
     d2a:	bf 90       	pop	r11
     d2c:	af 90       	pop	r10
     d2e:	08 95       	ret

00000d30 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     d30:	df 92       	push	r13
     d32:	ef 92       	push	r14
     d34:	ff 92       	push	r15
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	cf 93       	push	r28
     d3c:	df 93       	push	r29
     d3e:	d6 2e       	mov	r13, r22
     d40:	04 2f       	mov	r16, r20
     d42:	79 01       	movw	r14, r18
     d44:	ec 01       	movw	r28, r24
     d46:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     d48:	89 91       	ld	r24, Y+
     d4a:	8a 30       	cpi	r24, 0x0A	; 10
     d4c:	31 f4       	brne	.+12     	; 0xd5a <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
     d4e:	f7 01       	movw	r30, r14
     d50:	84 81       	ldd	r24, Z+4	; 0x04
     d52:	8f 5f       	subi	r24, 0xFF	; 255
     d54:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     d56:	1d 2d       	mov	r17, r13
     d58:	09 c0       	rjmp	.+18     	; 0xd6c <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d5a:	8d 30       	cpi	r24, 0x0D	; 13
     d5c:	39 f0       	breq	.+14     	; 0xd6c <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d5e:	97 01       	movw	r18, r14
     d60:	40 2f       	mov	r20, r16
     d62:	61 2f       	mov	r22, r17
     d64:	88 df       	rcall	.-240    	; 0xc76 <gfx_mono_draw_char>
			x += font->width;
     d66:	f7 01       	movw	r30, r14
     d68:	83 81       	ldd	r24, Z+3	; 0x03
     d6a:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     d6c:	88 81       	ld	r24, Y
     d6e:	81 11       	cpse	r24, r1
     d70:	eb cf       	rjmp	.-42     	; 0xd48 <gfx_mono_draw_string+0x18>
}
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	1f 91       	pop	r17
     d78:	0f 91       	pop	r16
     d7a:	ff 90       	pop	r15
     d7c:	ef 90       	pop	r14
     d7e:	df 90       	pop	r13
     d80:	08 95       	ret

00000d82 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
     d82:	cf 93       	push	r28
     d84:	df 93       	push	r29
     d86:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
     d88:	20 e0       	ldi	r18, 0x00	; 0
     d8a:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
     d8c:	c6 2f       	mov	r28, r22
     d8e:	d0 e0       	ldi	r29, 0x00	; 0
     d90:	de 01       	movw	r26, r28
     d92:	02 2e       	mov	r0, r18
     d94:	02 c0       	rjmp	.+4      	; 0xd9a <ioport_configure_port_pin+0x18>
     d96:	b5 95       	asr	r27
     d98:	a7 95       	ror	r26
     d9a:	0a 94       	dec	r0
     d9c:	e2 f7       	brpl	.-8      	; 0xd96 <ioport_configure_port_pin+0x14>
     d9e:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
     da0:	50 8b       	std	Z+16, r21	; 0x10
     da2:	2f 5f       	subi	r18, 0xFF	; 255
     da4:	3f 4f       	sbci	r19, 0xFF	; 255
     da6:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
     da8:	28 30       	cpi	r18, 0x08	; 8
     daa:	31 05       	cpc	r19, r1
     dac:	89 f7       	brne	.-30     	; 0xd90 <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
     dae:	40 ff       	sbrs	r20, 0
     db0:	0a c0       	rjmp	.+20     	; 0xdc6 <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
     db2:	41 ff       	sbrs	r20, 1
     db4:	03 c0       	rjmp	.+6      	; 0xdbc <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
     db6:	fc 01       	movw	r30, r24
     db8:	65 83       	std	Z+5, r22	; 0x05
     dba:	02 c0       	rjmp	.+4      	; 0xdc0 <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
     dbc:	fc 01       	movw	r30, r24
     dbe:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
     dc0:	fc 01       	movw	r30, r24
     dc2:	61 83       	std	Z+1, r22	; 0x01
     dc4:	02 c0       	rjmp	.+4      	; 0xdca <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
     dc6:	fc 01       	movw	r30, r24
     dc8:	62 83       	std	Z+2, r22	; 0x02
	}
}
     dca:	df 91       	pop	r29
     dcc:	cf 91       	pop	r28
     dce:	08 95       	ret

00000dd0 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     dd0:	80 3a       	cpi	r24, 0xA0	; 160
     dd2:	28 e0       	ldi	r18, 0x08	; 8
     dd4:	92 07       	cpc	r25, r18
     dd6:	21 f4       	brne	.+8      	; 0xde0 <usart_spi_init+0x10>
     dd8:	60 e1       	ldi	r22, 0x10	; 16
     dda:	83 e0       	ldi	r24, 0x03	; 3
     ddc:	63 cd       	rjmp	.-1338   	; 0x8a4 <sysclk_enable_module>
     dde:	08 95       	ret
     de0:	80 3b       	cpi	r24, 0xB0	; 176
     de2:	28 e0       	ldi	r18, 0x08	; 8
     de4:	92 07       	cpc	r25, r18
     de6:	21 f4       	brne	.+8      	; 0xdf0 <usart_spi_init+0x20>
     de8:	60 e2       	ldi	r22, 0x20	; 32
     dea:	83 e0       	ldi	r24, 0x03	; 3
     dec:	5b cd       	rjmp	.-1354   	; 0x8a4 <sysclk_enable_module>
     dee:	08 95       	ret
     df0:	80 3a       	cpi	r24, 0xA0	; 160
     df2:	29 e0       	ldi	r18, 0x09	; 9
     df4:	92 07       	cpc	r25, r18
     df6:	21 f4       	brne	.+8      	; 0xe00 <usart_spi_init+0x30>
     df8:	60 e1       	ldi	r22, 0x10	; 16
     dfa:	84 e0       	ldi	r24, 0x04	; 4
     dfc:	53 cd       	rjmp	.-1370   	; 0x8a4 <sysclk_enable_module>
     dfe:	08 95       	ret
     e00:	80 3b       	cpi	r24, 0xB0	; 176
     e02:	29 e0       	ldi	r18, 0x09	; 9
     e04:	92 07       	cpc	r25, r18
     e06:	21 f4       	brne	.+8      	; 0xe10 <usart_spi_init+0x40>
     e08:	60 e2       	ldi	r22, 0x20	; 32
     e0a:	84 e0       	ldi	r24, 0x04	; 4
     e0c:	4b cd       	rjmp	.-1386   	; 0x8a4 <sysclk_enable_module>
     e0e:	08 95       	ret
     e10:	80 3a       	cpi	r24, 0xA0	; 160
     e12:	2a e0       	ldi	r18, 0x0A	; 10
     e14:	92 07       	cpc	r25, r18
     e16:	21 f4       	brne	.+8      	; 0xe20 <usart_spi_init+0x50>
     e18:	60 e1       	ldi	r22, 0x10	; 16
     e1a:	85 e0       	ldi	r24, 0x05	; 5
     e1c:	43 cd       	rjmp	.-1402   	; 0x8a4 <sysclk_enable_module>
     e1e:	08 95       	ret
     e20:	80 3a       	cpi	r24, 0xA0	; 160
     e22:	9b 40       	sbci	r25, 0x0B	; 11
     e24:	19 f4       	brne	.+6      	; 0xe2c <usart_spi_init+0x5c>
     e26:	60 e1       	ldi	r22, 0x10	; 16
     e28:	86 e0       	ldi	r24, 0x06	; 6
     e2a:	3c cd       	rjmp	.-1416   	; 0x8a4 <sysclk_enable_module>
     e2c:	08 95       	ret

00000e2e <usart_spi_setup_device>:
     e2e:	0f 93       	push	r16
     e30:	1f 93       	push	r17
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	00 d0       	rcall	.+0      	; 0xe38 <usart_spi_setup_device+0xa>
     e38:	00 d0       	rcall	.+0      	; 0xe3a <usart_spi_setup_device+0xc>
     e3a:	cd b7       	in	r28, 0x3d	; 61
     e3c:	de b7       	in	r29, 0x3e	; 62
     e3e:	09 83       	std	Y+1, r16	; 0x01
     e40:	1a 83       	std	Y+2, r17	; 0x02
     e42:	2b 83       	std	Y+3, r18	; 0x03
     e44:	3c 83       	std	Y+4, r19	; 0x04
     e46:	4d 83       	std	Y+5, r20	; 0x05
     e48:	1e 82       	std	Y+6, r1	; 0x06
     e4a:	be 01       	movw	r22, r28
     e4c:	6f 5f       	subi	r22, 0xFF	; 255
     e4e:	7f 4f       	sbci	r23, 0xFF	; 255
     e50:	60 d7       	rcall	.+3776   	; 0x1d12 <usart_init_spi>
     e52:	26 96       	adiw	r28, 0x06	; 6
     e54:	cd bf       	out	0x3d, r28	; 61
     e56:	de bf       	out	0x3e, r29	; 62
     e58:	df 91       	pop	r29
     e5a:	cf 91       	pop	r28
     e5c:	1f 91       	pop	r17
     e5e:	0f 91       	pop	r16
     e60:	08 95       	ret

00000e62 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     e62:	fb 01       	movw	r30, r22
     e64:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e66:	e8 2f       	mov	r30, r24
     e68:	e6 95       	lsr	r30
     e6a:	e6 95       	lsr	r30
     e6c:	e6 95       	lsr	r30
     e6e:	40 e2       	ldi	r20, 0x20	; 32
     e70:	e4 9f       	mul	r30, r20
     e72:	f0 01       	movw	r30, r0
     e74:	11 24       	eor	r1, r1
     e76:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     e78:	87 70       	andi	r24, 0x07	; 7
     e7a:	21 e0       	ldi	r18, 0x01	; 1
     e7c:	30 e0       	ldi	r19, 0x00	; 0
     e7e:	a9 01       	movw	r20, r18
     e80:	02 c0       	rjmp	.+4      	; 0xe86 <usart_spi_select_device+0x24>
     e82:	44 0f       	add	r20, r20
     e84:	55 1f       	adc	r21, r21
     e86:	8a 95       	dec	r24
     e88:	e2 f7       	brpl	.-8      	; 0xe82 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     e8a:	46 83       	std	Z+6, r20	; 0x06
     e8c:	08 95       	ret

00000e8e <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     e8e:	fb 01       	movw	r30, r22
     e90:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e92:	e8 2f       	mov	r30, r24
     e94:	e6 95       	lsr	r30
     e96:	e6 95       	lsr	r30
     e98:	e6 95       	lsr	r30
     e9a:	40 e2       	ldi	r20, 0x20	; 32
     e9c:	e4 9f       	mul	r30, r20
     e9e:	f0 01       	movw	r30, r0
     ea0:	11 24       	eor	r1, r1
     ea2:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     ea4:	87 70       	andi	r24, 0x07	; 7
     ea6:	21 e0       	ldi	r18, 0x01	; 1
     ea8:	30 e0       	ldi	r19, 0x00	; 0
     eaa:	a9 01       	movw	r20, r18
     eac:	02 c0       	rjmp	.+4      	; 0xeb2 <usart_spi_deselect_device+0x24>
     eae:	44 0f       	add	r20, r20
     eb0:	55 1f       	adc	r21, r21
     eb2:	8a 95       	dec	r24
     eb4:	e2 f7       	brpl	.-8      	; 0xeae <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     eb6:	45 83       	std	Z+5, r20	; 0x05
     eb8:	08 95       	ret

00000eba <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
     eba:	43 e0       	ldi	r20, 0x03	; 3
     ebc:	50 e0       	ldi	r21, 0x00	; 0
     ebe:	61 e0       	ldi	r22, 0x01	; 1
     ec0:	80 ee       	ldi	r24, 0xE0	; 224
     ec2:	97 e0       	ldi	r25, 0x07	; 7
     ec4:	5e df       	rcall	.-324    	; 0xd82 <ioport_configure_port_pin>
     ec6:	43 e0       	ldi	r20, 0x03	; 3
     ec8:	50 e0       	ldi	r21, 0x00	; 0
     eca:	62 e0       	ldi	r22, 0x02	; 2
     ecc:	80 ee       	ldi	r24, 0xE0	; 224
     ece:	97 e0       	ldi	r25, 0x07	; 7
     ed0:	58 df       	rcall	.-336    	; 0xd82 <ioport_configure_port_pin>
     ed2:	43 e0       	ldi	r20, 0x03	; 3
     ed4:	50 e0       	ldi	r21, 0x00	; 0
     ed6:	60 e1       	ldi	r22, 0x10	; 16
     ed8:	80 e6       	ldi	r24, 0x60	; 96
     eda:	96 e0       	ldi	r25, 0x06	; 6
     edc:	52 df       	rcall	.-348    	; 0xd82 <ioport_configure_port_pin>
     ede:	41 e0       	ldi	r20, 0x01	; 1
     ee0:	50 e4       	ldi	r21, 0x40	; 64
     ee2:	60 e2       	ldi	r22, 0x20	; 32
     ee4:	80 e6       	ldi	r24, 0x60	; 96
     ee6:	96 e0       	ldi	r25, 0x06	; 6
     ee8:	4c df       	rcall	.-360    	; 0xd82 <ioport_configure_port_pin>
     eea:	40 e0       	ldi	r20, 0x00	; 0
     eec:	5b e1       	ldi	r21, 0x1B	; 27
     eee:	60 e2       	ldi	r22, 0x20	; 32
     ef0:	80 e8       	ldi	r24, 0x80	; 128
     ef2:	96 e0       	ldi	r25, 0x06	; 6
     ef4:	46 df       	rcall	.-372    	; 0xd82 <ioport_configure_port_pin>
     ef6:	40 e0       	ldi	r20, 0x00	; 0
     ef8:	5b e1       	ldi	r21, 0x1B	; 27
     efa:	62 e0       	ldi	r22, 0x02	; 2
     efc:	80 ea       	ldi	r24, 0xA0	; 160
     efe:	96 e0       	ldi	r25, 0x06	; 6
     f00:	40 df       	rcall	.-384    	; 0xd82 <ioport_configure_port_pin>
     f02:	40 e0       	ldi	r20, 0x00	; 0
     f04:	5b e1       	ldi	r21, 0x1B	; 27
     f06:	64 e0       	ldi	r22, 0x04	; 4
     f08:	80 ea       	ldi	r24, 0xA0	; 160
     f0a:	96 e0       	ldi	r25, 0x06	; 6
     f0c:	3a df       	rcall	.-396    	; 0xd82 <ioport_configure_port_pin>
     f0e:	43 e0       	ldi	r20, 0x03	; 3
     f10:	50 e0       	ldi	r21, 0x00	; 0
     f12:	62 e0       	ldi	r22, 0x02	; 2
     f14:	80 e6       	ldi	r24, 0x60	; 96
     f16:	96 e0       	ldi	r25, 0x06	; 6
     f18:	34 df       	rcall	.-408    	; 0xd82 <ioport_configure_port_pin>
     f1a:	43 e0       	ldi	r20, 0x03	; 3
     f1c:	50 e0       	ldi	r21, 0x00	; 0
     f1e:	68 e0       	ldi	r22, 0x08	; 8
     f20:	80 e6       	ldi	r24, 0x60	; 96
     f22:	96 e0       	ldi	r25, 0x06	; 6
     f24:	2e df       	rcall	.-420    	; 0xd82 <ioport_configure_port_pin>
     f26:	43 e0       	ldi	r20, 0x03	; 3
     f28:	50 e0       	ldi	r21, 0x00	; 0
     f2a:	68 e0       	ldi	r22, 0x08	; 8
     f2c:	80 ea       	ldi	r24, 0xA0	; 160
     f2e:	96 e0       	ldi	r25, 0x06	; 6
     f30:	28 df       	rcall	.-432    	; 0xd82 <ioport_configure_port_pin>
     f32:	43 e0       	ldi	r20, 0x03	; 3
     f34:	50 e0       	ldi	r21, 0x00	; 0
     f36:	61 e0       	ldi	r22, 0x01	; 1
     f38:	80 e6       	ldi	r24, 0x60	; 96
     f3a:	96 e0       	ldi	r25, 0x06	; 6
     f3c:	22 df       	rcall	.-444    	; 0xd82 <ioport_configure_port_pin>
     f3e:	43 e0       	ldi	r20, 0x03	; 3
     f40:	50 e0       	ldi	r21, 0x00	; 0
     f42:	68 e0       	ldi	r22, 0x08	; 8
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	96 e0       	ldi	r25, 0x06	; 6
     f48:	1c df       	rcall	.-456    	; 0xd82 <ioport_configure_port_pin>
     f4a:	41 e0       	ldi	r20, 0x01	; 1
     f4c:	50 e0       	ldi	r21, 0x00	; 0
     f4e:	60 e1       	ldi	r22, 0x10	; 16
     f50:	80 e8       	ldi	r24, 0x80	; 128
     f52:	96 e0       	ldi	r25, 0x06	; 6
     f54:	16 df       	rcall	.-468    	; 0xd82 <ioport_configure_port_pin>
     f56:	43 e0       	ldi	r20, 0x03	; 3
     f58:	50 e0       	ldi	r21, 0x00	; 0
     f5a:	62 e0       	ldi	r22, 0x02	; 2
     f5c:	80 e6       	ldi	r24, 0x60	; 96
     f5e:	96 e0       	ldi	r25, 0x06	; 6
     f60:	10 df       	rcall	.-480    	; 0xd82 <ioport_configure_port_pin>
     f62:	43 e0       	ldi	r20, 0x03	; 3
     f64:	50 e0       	ldi	r21, 0x00	; 0
     f66:	68 e0       	ldi	r22, 0x08	; 8
     f68:	80 e6       	ldi	r24, 0x60	; 96
     f6a:	96 e0       	ldi	r25, 0x06	; 6
     f6c:	0a df       	rcall	.-492    	; 0xd82 <ioport_configure_port_pin>
     f6e:	40 e0       	ldi	r20, 0x00	; 0
     f70:	50 e0       	ldi	r21, 0x00	; 0
     f72:	64 e0       	ldi	r22, 0x04	; 4
     f74:	80 e6       	ldi	r24, 0x60	; 96
     f76:	96 e0       	ldi	r25, 0x06	; 6
     f78:	04 df       	rcall	.-504    	; 0xd82 <ioport_configure_port_pin>
     f7a:	43 e0       	ldi	r20, 0x03	; 3
     f7c:	50 e0       	ldi	r21, 0x00	; 0
     f7e:	60 e1       	ldi	r22, 0x10	; 16
     f80:	80 ea       	ldi	r24, 0xA0	; 160
     f82:	96 e0       	ldi	r25, 0x06	; 6
     f84:	fe de       	rcall	.-516    	; 0xd82 <ioport_configure_port_pin>
     f86:	40 e0       	ldi	r20, 0x00	; 0
     f88:	50 e0       	ldi	r21, 0x00	; 0
     f8a:	61 e0       	ldi	r22, 0x01	; 1
     f8c:	80 e0       	ldi	r24, 0x00	; 0
     f8e:	96 e0       	ldi	r25, 0x06	; 6
     f90:	f8 de       	rcall	.-528    	; 0xd82 <ioport_configure_port_pin>
     f92:	40 e0       	ldi	r20, 0x00	; 0
     f94:	50 e0       	ldi	r21, 0x00	; 0
     f96:	64 e0       	ldi	r22, 0x04	; 4
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	96 e0       	ldi	r25, 0x06	; 6
     f9c:	f2 de       	rcall	.-540    	; 0xd82 <ioport_configure_port_pin>
     f9e:	40 e0       	ldi	r20, 0x00	; 0
     fa0:	50 e0       	ldi	r21, 0x00	; 0
     fa2:	62 e0       	ldi	r22, 0x02	; 2
     fa4:	80 e2       	ldi	r24, 0x20	; 32
     fa6:	96 e0       	ldi	r25, 0x06	; 6
     fa8:	ec de       	rcall	.-552    	; 0xd82 <ioport_configure_port_pin>
     faa:	43 e0       	ldi	r20, 0x03	; 3
     fac:	50 e0       	ldi	r21, 0x00	; 0
     fae:	68 e0       	ldi	r22, 0x08	; 8
     fb0:	80 e4       	ldi	r24, 0x40	; 64
     fb2:	96 e0       	ldi	r25, 0x06	; 6
     fb4:	e6 de       	rcall	.-564    	; 0xd82 <ioport_configure_port_pin>
     fb6:	40 e0       	ldi	r20, 0x00	; 0
     fb8:	50 e0       	ldi	r21, 0x00	; 0
     fba:	64 e0       	ldi	r22, 0x04	; 4
     fbc:	80 e4       	ldi	r24, 0x40	; 64
     fbe:	96 e0       	ldi	r25, 0x06	; 6
     fc0:	e0 de       	rcall	.-576    	; 0xd82 <ioport_configure_port_pin>
     fc2:	43 e0       	ldi	r20, 0x03	; 3
     fc4:	50 e0       	ldi	r21, 0x00	; 0
     fc6:	68 e0       	ldi	r22, 0x08	; 8
     fc8:	80 e6       	ldi	r24, 0x60	; 96
     fca:	96 e0       	ldi	r25, 0x06	; 6
     fcc:	da de       	rcall	.-588    	; 0xd82 <ioport_configure_port_pin>
     fce:	40 e0       	ldi	r20, 0x00	; 0
     fd0:	50 e0       	ldi	r21, 0x00	; 0
     fd2:	64 e0       	ldi	r22, 0x04	; 4
     fd4:	80 e6       	ldi	r24, 0x60	; 96
     fd6:	96 e0       	ldi	r25, 0x06	; 6
     fd8:	d4 de       	rcall	.-600    	; 0xd82 <ioport_configure_port_pin>
     fda:	43 e0       	ldi	r20, 0x03	; 3
     fdc:	50 e0       	ldi	r21, 0x00	; 0
     fde:	68 e0       	ldi	r22, 0x08	; 8
     fe0:	80 e8       	ldi	r24, 0x80	; 128
     fe2:	96 e0       	ldi	r25, 0x06	; 6
     fe4:	ce de       	rcall	.-612    	; 0xd82 <ioport_configure_port_pin>
     fe6:	40 e0       	ldi	r20, 0x00	; 0
     fe8:	50 e0       	ldi	r21, 0x00	; 0
     fea:	64 e0       	ldi	r22, 0x04	; 4
     fec:	80 e8       	ldi	r24, 0x80	; 128
     fee:	96 e0       	ldi	r25, 0x06	; 6
     ff0:	c8 ce       	rjmp	.-624    	; 0xd82 <ioport_configure_port_pin>
     ff2:	08 95       	ret

00000ff4 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     ff4:	81 15       	cp	r24, r1
     ff6:	22 e0       	ldi	r18, 0x02	; 2
     ff8:	92 07       	cpc	r25, r18
     ffa:	61 f4       	brne	.+24     	; 0x1014 <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     ffc:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <adca_enable_count>
    1000:	91 e0       	ldi	r25, 0x01	; 1
    1002:	98 0f       	add	r25, r24
    1004:	90 93 4d 22 	sts	0x224D, r25	; 0x80224d <adca_enable_count>
    1008:	81 11       	cpse	r24, r1
    100a:	12 c0       	rjmp	.+36     	; 0x1030 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    100c:	62 e0       	ldi	r22, 0x02	; 2
    100e:	81 e0       	ldi	r24, 0x01	; 1
    1010:	49 cc       	rjmp	.-1902   	; 0x8a4 <sysclk_enable_module>
    1012:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    1014:	80 34       	cpi	r24, 0x40	; 64
    1016:	92 40       	sbci	r25, 0x02	; 2
    1018:	59 f4       	brne	.+22     	; 0x1030 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
    101a:	80 91 4c 22 	lds	r24, 0x224C	; 0x80224c <adcb_enable_count>
    101e:	91 e0       	ldi	r25, 0x01	; 1
    1020:	98 0f       	add	r25, r24
    1022:	90 93 4c 22 	sts	0x224C, r25	; 0x80224c <adcb_enable_count>
    1026:	81 11       	cpse	r24, r1
    1028:	03 c0       	rjmp	.+6      	; 0x1030 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    102a:	62 e0       	ldi	r22, 0x02	; 2
    102c:	82 e0       	ldi	r24, 0x02	; 2
    102e:	3a cc       	rjmp	.-1932   	; 0x8a4 <sysclk_enable_module>
    1030:	08 95       	ret

00001032 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
    1032:	81 15       	cp	r24, r1
    1034:	22 e0       	ldi	r18, 0x02	; 2
    1036:	92 07       	cpc	r25, r18
    1038:	59 f4       	brne	.+22     	; 0x1050 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
    103a:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <adca_enable_count>
    103e:	81 50       	subi	r24, 0x01	; 1
    1040:	80 93 4d 22 	sts	0x224D, r24	; 0x80224d <adca_enable_count>
    1044:	81 11       	cpse	r24, r1
    1046:	11 c0       	rjmp	.+34     	; 0x106a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1048:	62 e0       	ldi	r22, 0x02	; 2
    104a:	81 e0       	ldi	r24, 0x01	; 1
    104c:	41 cc       	rjmp	.-1918   	; 0x8d0 <sysclk_disable_module>
    104e:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    1050:	80 34       	cpi	r24, 0x40	; 64
    1052:	92 40       	sbci	r25, 0x02	; 2
    1054:	51 f4       	brne	.+20     	; 0x106a <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
    1056:	80 91 4c 22 	lds	r24, 0x224C	; 0x80224c <adcb_enable_count>
    105a:	81 50       	subi	r24, 0x01	; 1
    105c:	80 93 4c 22 	sts	0x224C, r24	; 0x80224c <adcb_enable_count>
    1060:	81 11       	cpse	r24, r1
    1062:	03 c0       	rjmp	.+6      	; 0x106a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1064:	62 e0       	ldi	r22, 0x02	; 2
    1066:	82 e0       	ldi	r24, 0x02	; 2
    1068:	33 cc       	rjmp	.-1946   	; 0x8d0 <sysclk_disable_module>
    106a:	08 95       	ret

0000106c <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
    106c:	ef 92       	push	r14
    106e:	ff 92       	push	r15
    1070:	1f 93       	push	r17
    1072:	cf 93       	push	r28
    1074:	df 93       	push	r29
    1076:	1f 92       	push	r1
    1078:	1f 92       	push	r1
    107a:	cd b7       	in	r28, 0x3d	; 61
    107c:	de b7       	in	r29, 0x3e	; 62
    107e:	7c 01       	movw	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    1080:	8f b7       	in	r24, 0x3f	; 63
    1082:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    1084:	f8 94       	cli
	return flags;
    1086:	19 81       	ldd	r17, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
    1088:	c7 01       	movw	r24, r14
    108a:	b4 df       	rcall	.-152    	; 0xff4 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
    108c:	f7 01       	movw	r30, r14
    108e:	80 81       	ld	r24, Z
    1090:	81 60       	ori	r24, 0x01	; 1
    1092:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1094:	1f bf       	out	0x3f, r17	; 63
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
    1096:	80 91 53 23 	lds	r24, 0x2353	; 0x802353 <sleepmgr_locks+0x1>
    109a:	8f 3f       	cpi	r24, 0xFF	; 255
    109c:	09 f4       	brne	.+2      	; 0x10a0 <adc_enable+0x34>
    109e:	ff cf       	rjmp	.-2      	; 0x109e <adc_enable+0x32>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    10a0:	8f b7       	in	r24, 0x3f	; 63
    10a2:	8a 83       	std	Y+2, r24	; 0x02
	cpu_irq_disable();
    10a4:	f8 94       	cli
	return flags;
    10a6:	9a 81       	ldd	r25, Y+2	; 0x02
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
    10a8:	e2 e5       	ldi	r30, 0x52	; 82
    10aa:	f3 e2       	ldi	r31, 0x23	; 35
    10ac:	81 81       	ldd	r24, Z+1	; 0x01
    10ae:	8f 5f       	subi	r24, 0xFF	; 255
    10b0:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    10b2:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	ff 90       	pop	r15
    10c0:	ef 90       	pop	r14
    10c2:	08 95       	ret

000010c4 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
    10c4:	1f 92       	push	r1
    10c6:	0f 92       	push	r0
    10c8:	0f b6       	in	r0, 0x3f	; 63
    10ca:	0f 92       	push	r0
    10cc:	11 24       	eor	r1, r1
    10ce:	0b b6       	in	r0, 0x3b	; 59
    10d0:	0f 92       	push	r0
    10d2:	2f 93       	push	r18
    10d4:	3f 93       	push	r19
    10d6:	4f 93       	push	r20
    10d8:	5f 93       	push	r21
    10da:	6f 93       	push	r22
    10dc:	7f 93       	push	r23
    10de:	8f 93       	push	r24
    10e0:	9f 93       	push	r25
    10e2:	af 93       	push	r26
    10e4:	bf 93       	push	r27
    10e6:	ef 93       	push	r30
    10e8:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
    10ea:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
    10ee:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
    10f2:	e0 91 5a 23 	lds	r30, 0x235A	; 0x80235a <adca_callback>
    10f6:	f0 91 5b 23 	lds	r31, 0x235B	; 0x80235b <adca_callback+0x1>
    10fa:	61 e0       	ldi	r22, 0x01	; 1
    10fc:	80 e0       	ldi	r24, 0x00	; 0
    10fe:	92 e0       	ldi	r25, 0x02	; 2
    1100:	19 95       	eicall
}
    1102:	ff 91       	pop	r31
    1104:	ef 91       	pop	r30
    1106:	bf 91       	pop	r27
    1108:	af 91       	pop	r26
    110a:	9f 91       	pop	r25
    110c:	8f 91       	pop	r24
    110e:	7f 91       	pop	r23
    1110:	6f 91       	pop	r22
    1112:	5f 91       	pop	r21
    1114:	4f 91       	pop	r20
    1116:	3f 91       	pop	r19
    1118:	2f 91       	pop	r18
    111a:	0f 90       	pop	r0
    111c:	0b be       	out	0x3b, r0	; 59
    111e:	0f 90       	pop	r0
    1120:	0f be       	out	0x3f, r0	; 63
    1122:	0f 90       	pop	r0
    1124:	1f 90       	pop	r1
    1126:	18 95       	reti

00001128 <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
    1128:	1f 92       	push	r1
    112a:	0f 92       	push	r0
    112c:	0f b6       	in	r0, 0x3f	; 63
    112e:	0f 92       	push	r0
    1130:	11 24       	eor	r1, r1
    1132:	0b b6       	in	r0, 0x3b	; 59
    1134:	0f 92       	push	r0
    1136:	2f 93       	push	r18
    1138:	3f 93       	push	r19
    113a:	4f 93       	push	r20
    113c:	5f 93       	push	r21
    113e:	6f 93       	push	r22
    1140:	7f 93       	push	r23
    1142:	8f 93       	push	r24
    1144:	9f 93       	push	r25
    1146:	af 93       	push	r26
    1148:	bf 93       	push	r27
    114a:	ef 93       	push	r30
    114c:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
    114e:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
    1152:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
    1156:	e0 91 5a 23 	lds	r30, 0x235A	; 0x80235a <adca_callback>
    115a:	f0 91 5b 23 	lds	r31, 0x235B	; 0x80235b <adca_callback+0x1>
    115e:	62 e0       	ldi	r22, 0x02	; 2
    1160:	80 e0       	ldi	r24, 0x00	; 0
    1162:	92 e0       	ldi	r25, 0x02	; 2
    1164:	19 95       	eicall
}
    1166:	ff 91       	pop	r31
    1168:	ef 91       	pop	r30
    116a:	bf 91       	pop	r27
    116c:	af 91       	pop	r26
    116e:	9f 91       	pop	r25
    1170:	8f 91       	pop	r24
    1172:	7f 91       	pop	r23
    1174:	6f 91       	pop	r22
    1176:	5f 91       	pop	r21
    1178:	4f 91       	pop	r20
    117a:	3f 91       	pop	r19
    117c:	2f 91       	pop	r18
    117e:	0f 90       	pop	r0
    1180:	0b be       	out	0x3b, r0	; 59
    1182:	0f 90       	pop	r0
    1184:	0f be       	out	0x3f, r0	; 63
    1186:	0f 90       	pop	r0
    1188:	1f 90       	pop	r1
    118a:	18 95       	reti

0000118c <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    118c:	1f 92       	push	r1
    118e:	0f 92       	push	r0
    1190:	0f b6       	in	r0, 0x3f	; 63
    1192:	0f 92       	push	r0
    1194:	11 24       	eor	r1, r1
    1196:	0b b6       	in	r0, 0x3b	; 59
    1198:	0f 92       	push	r0
    119a:	2f 93       	push	r18
    119c:	3f 93       	push	r19
    119e:	4f 93       	push	r20
    11a0:	5f 93       	push	r21
    11a2:	6f 93       	push	r22
    11a4:	7f 93       	push	r23
    11a6:	8f 93       	push	r24
    11a8:	9f 93       	push	r25
    11aa:	af 93       	push	r26
    11ac:	bf 93       	push	r27
    11ae:	ef 93       	push	r30
    11b0:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    11b2:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
    11b6:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
    11ba:	e0 91 5a 23 	lds	r30, 0x235A	; 0x80235a <adca_callback>
    11be:	f0 91 5b 23 	lds	r31, 0x235B	; 0x80235b <adca_callback+0x1>
    11c2:	64 e0       	ldi	r22, 0x04	; 4
    11c4:	80 e0       	ldi	r24, 0x00	; 0
    11c6:	92 e0       	ldi	r25, 0x02	; 2
    11c8:	19 95       	eicall
}
    11ca:	ff 91       	pop	r31
    11cc:	ef 91       	pop	r30
    11ce:	bf 91       	pop	r27
    11d0:	af 91       	pop	r26
    11d2:	9f 91       	pop	r25
    11d4:	8f 91       	pop	r24
    11d6:	7f 91       	pop	r23
    11d8:	6f 91       	pop	r22
    11da:	5f 91       	pop	r21
    11dc:	4f 91       	pop	r20
    11de:	3f 91       	pop	r19
    11e0:	2f 91       	pop	r18
    11e2:	0f 90       	pop	r0
    11e4:	0b be       	out	0x3b, r0	; 59
    11e6:	0f 90       	pop	r0
    11e8:	0f be       	out	0x3f, r0	; 63
    11ea:	0f 90       	pop	r0
    11ec:	1f 90       	pop	r1
    11ee:	18 95       	reti

000011f0 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    11f0:	1f 92       	push	r1
    11f2:	0f 92       	push	r0
    11f4:	0f b6       	in	r0, 0x3f	; 63
    11f6:	0f 92       	push	r0
    11f8:	11 24       	eor	r1, r1
    11fa:	0b b6       	in	r0, 0x3b	; 59
    11fc:	0f 92       	push	r0
    11fe:	2f 93       	push	r18
    1200:	3f 93       	push	r19
    1202:	4f 93       	push	r20
    1204:	5f 93       	push	r21
    1206:	6f 93       	push	r22
    1208:	7f 93       	push	r23
    120a:	8f 93       	push	r24
    120c:	9f 93       	push	r25
    120e:	af 93       	push	r26
    1210:	bf 93       	push	r27
    1212:	ef 93       	push	r30
    1214:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    1216:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
    121a:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
    121e:	e0 91 5a 23 	lds	r30, 0x235A	; 0x80235a <adca_callback>
    1222:	f0 91 5b 23 	lds	r31, 0x235B	; 0x80235b <adca_callback+0x1>
    1226:	68 e0       	ldi	r22, 0x08	; 8
    1228:	80 e0       	ldi	r24, 0x00	; 0
    122a:	92 e0       	ldi	r25, 0x02	; 2
    122c:	19 95       	eicall
}
    122e:	ff 91       	pop	r31
    1230:	ef 91       	pop	r30
    1232:	bf 91       	pop	r27
    1234:	af 91       	pop	r26
    1236:	9f 91       	pop	r25
    1238:	8f 91       	pop	r24
    123a:	7f 91       	pop	r23
    123c:	6f 91       	pop	r22
    123e:	5f 91       	pop	r21
    1240:	4f 91       	pop	r20
    1242:	3f 91       	pop	r19
    1244:	2f 91       	pop	r18
    1246:	0f 90       	pop	r0
    1248:	0b be       	out	0x3b, r0	; 59
    124a:	0f 90       	pop	r0
    124c:	0f be       	out	0x3f, r0	; 63
    124e:	0f 90       	pop	r0
    1250:	1f 90       	pop	r1
    1252:	18 95       	reti

00001254 <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    1254:	1f 92       	push	r1
    1256:	0f 92       	push	r0
    1258:	0f b6       	in	r0, 0x3f	; 63
    125a:	0f 92       	push	r0
    125c:	11 24       	eor	r1, r1
    125e:	0b b6       	in	r0, 0x3b	; 59
    1260:	0f 92       	push	r0
    1262:	2f 93       	push	r18
    1264:	3f 93       	push	r19
    1266:	4f 93       	push	r20
    1268:	5f 93       	push	r21
    126a:	6f 93       	push	r22
    126c:	7f 93       	push	r23
    126e:	8f 93       	push	r24
    1270:	9f 93       	push	r25
    1272:	af 93       	push	r26
    1274:	bf 93       	push	r27
    1276:	ef 93       	push	r30
    1278:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    127a:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
    127e:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
    1282:	e0 91 58 23 	lds	r30, 0x2358	; 0x802358 <adcb_callback>
    1286:	f0 91 59 23 	lds	r31, 0x2359	; 0x802359 <adcb_callback+0x1>
    128a:	61 e0       	ldi	r22, 0x01	; 1
    128c:	80 e4       	ldi	r24, 0x40	; 64
    128e:	92 e0       	ldi	r25, 0x02	; 2
    1290:	19 95       	eicall
}
    1292:	ff 91       	pop	r31
    1294:	ef 91       	pop	r30
    1296:	bf 91       	pop	r27
    1298:	af 91       	pop	r26
    129a:	9f 91       	pop	r25
    129c:	8f 91       	pop	r24
    129e:	7f 91       	pop	r23
    12a0:	6f 91       	pop	r22
    12a2:	5f 91       	pop	r21
    12a4:	4f 91       	pop	r20
    12a6:	3f 91       	pop	r19
    12a8:	2f 91       	pop	r18
    12aa:	0f 90       	pop	r0
    12ac:	0b be       	out	0x3b, r0	; 59
    12ae:	0f 90       	pop	r0
    12b0:	0f be       	out	0x3f, r0	; 63
    12b2:	0f 90       	pop	r0
    12b4:	1f 90       	pop	r1
    12b6:	18 95       	reti

000012b8 <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    12b8:	1f 92       	push	r1
    12ba:	0f 92       	push	r0
    12bc:	0f b6       	in	r0, 0x3f	; 63
    12be:	0f 92       	push	r0
    12c0:	11 24       	eor	r1, r1
    12c2:	0b b6       	in	r0, 0x3b	; 59
    12c4:	0f 92       	push	r0
    12c6:	2f 93       	push	r18
    12c8:	3f 93       	push	r19
    12ca:	4f 93       	push	r20
    12cc:	5f 93       	push	r21
    12ce:	6f 93       	push	r22
    12d0:	7f 93       	push	r23
    12d2:	8f 93       	push	r24
    12d4:	9f 93       	push	r25
    12d6:	af 93       	push	r26
    12d8:	bf 93       	push	r27
    12da:	ef 93       	push	r30
    12dc:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    12de:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
    12e2:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
    12e6:	e0 91 58 23 	lds	r30, 0x2358	; 0x802358 <adcb_callback>
    12ea:	f0 91 59 23 	lds	r31, 0x2359	; 0x802359 <adcb_callback+0x1>
    12ee:	62 e0       	ldi	r22, 0x02	; 2
    12f0:	80 e4       	ldi	r24, 0x40	; 64
    12f2:	92 e0       	ldi	r25, 0x02	; 2
    12f4:	19 95       	eicall
}
    12f6:	ff 91       	pop	r31
    12f8:	ef 91       	pop	r30
    12fa:	bf 91       	pop	r27
    12fc:	af 91       	pop	r26
    12fe:	9f 91       	pop	r25
    1300:	8f 91       	pop	r24
    1302:	7f 91       	pop	r23
    1304:	6f 91       	pop	r22
    1306:	5f 91       	pop	r21
    1308:	4f 91       	pop	r20
    130a:	3f 91       	pop	r19
    130c:	2f 91       	pop	r18
    130e:	0f 90       	pop	r0
    1310:	0b be       	out	0x3b, r0	; 59
    1312:	0f 90       	pop	r0
    1314:	0f be       	out	0x3f, r0	; 63
    1316:	0f 90       	pop	r0
    1318:	1f 90       	pop	r1
    131a:	18 95       	reti

0000131c <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    131c:	1f 92       	push	r1
    131e:	0f 92       	push	r0
    1320:	0f b6       	in	r0, 0x3f	; 63
    1322:	0f 92       	push	r0
    1324:	11 24       	eor	r1, r1
    1326:	0b b6       	in	r0, 0x3b	; 59
    1328:	0f 92       	push	r0
    132a:	2f 93       	push	r18
    132c:	3f 93       	push	r19
    132e:	4f 93       	push	r20
    1330:	5f 93       	push	r21
    1332:	6f 93       	push	r22
    1334:	7f 93       	push	r23
    1336:	8f 93       	push	r24
    1338:	9f 93       	push	r25
    133a:	af 93       	push	r26
    133c:	bf 93       	push	r27
    133e:	ef 93       	push	r30
    1340:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1342:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
    1346:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
    134a:	e0 91 58 23 	lds	r30, 0x2358	; 0x802358 <adcb_callback>
    134e:	f0 91 59 23 	lds	r31, 0x2359	; 0x802359 <adcb_callback+0x1>
    1352:	64 e0       	ldi	r22, 0x04	; 4
    1354:	80 e4       	ldi	r24, 0x40	; 64
    1356:	92 e0       	ldi	r25, 0x02	; 2
    1358:	19 95       	eicall
}
    135a:	ff 91       	pop	r31
    135c:	ef 91       	pop	r30
    135e:	bf 91       	pop	r27
    1360:	af 91       	pop	r26
    1362:	9f 91       	pop	r25
    1364:	8f 91       	pop	r24
    1366:	7f 91       	pop	r23
    1368:	6f 91       	pop	r22
    136a:	5f 91       	pop	r21
    136c:	4f 91       	pop	r20
    136e:	3f 91       	pop	r19
    1370:	2f 91       	pop	r18
    1372:	0f 90       	pop	r0
    1374:	0b be       	out	0x3b, r0	; 59
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	0f 90       	pop	r0
    137c:	1f 90       	pop	r1
    137e:	18 95       	reti

00001380 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1380:	1f 92       	push	r1
    1382:	0f 92       	push	r0
    1384:	0f b6       	in	r0, 0x3f	; 63
    1386:	0f 92       	push	r0
    1388:	11 24       	eor	r1, r1
    138a:	0b b6       	in	r0, 0x3b	; 59
    138c:	0f 92       	push	r0
    138e:	2f 93       	push	r18
    1390:	3f 93       	push	r19
    1392:	4f 93       	push	r20
    1394:	5f 93       	push	r21
    1396:	6f 93       	push	r22
    1398:	7f 93       	push	r23
    139a:	8f 93       	push	r24
    139c:	9f 93       	push	r25
    139e:	af 93       	push	r26
    13a0:	bf 93       	push	r27
    13a2:	ef 93       	push	r30
    13a4:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    13a6:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
    13aa:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
    13ae:	e0 91 58 23 	lds	r30, 0x2358	; 0x802358 <adcb_callback>
    13b2:	f0 91 59 23 	lds	r31, 0x2359	; 0x802359 <adcb_callback+0x1>
    13b6:	68 e0       	ldi	r22, 0x08	; 8
    13b8:	80 e4       	ldi	r24, 0x40	; 64
    13ba:	92 e0       	ldi	r25, 0x02	; 2
    13bc:	19 95       	eicall
}
    13be:	ff 91       	pop	r31
    13c0:	ef 91       	pop	r30
    13c2:	bf 91       	pop	r27
    13c4:	af 91       	pop	r26
    13c6:	9f 91       	pop	r25
    13c8:	8f 91       	pop	r24
    13ca:	7f 91       	pop	r23
    13cc:	6f 91       	pop	r22
    13ce:	5f 91       	pop	r21
    13d0:	4f 91       	pop	r20
    13d2:	3f 91       	pop	r19
    13d4:	2f 91       	pop	r18
    13d6:	0f 90       	pop	r0
    13d8:	0b be       	out	0x3b, r0	; 59
    13da:	0f 90       	pop	r0
    13dc:	0f be       	out	0x3f, r0	; 63
    13de:	0f 90       	pop	r0
    13e0:	1f 90       	pop	r1
    13e2:	18 95       	reti

000013e4 <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    13e4:	bf 92       	push	r11
    13e6:	cf 92       	push	r12
    13e8:	df 92       	push	r13
    13ea:	ef 92       	push	r14
    13ec:	ff 92       	push	r15
    13ee:	0f 93       	push	r16
    13f0:	1f 93       	push	r17
    13f2:	cf 93       	push	r28
    13f4:	df 93       	push	r29
    13f6:	1f 92       	push	r1
    13f8:	cd b7       	in	r28, 0x3d	; 61
    13fa:	de b7       	in	r29, 0x3e	; 62
    13fc:	8c 01       	movw	r16, r24
    13fe:	7b 01       	movw	r14, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    1400:	81 15       	cp	r24, r1
    1402:	22 e0       	ldi	r18, 0x02	; 2
    1404:	92 07       	cpc	r25, r18
    1406:	71 f4       	brne	.+28     	; 0x1424 <adc_write_configuration+0x40>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    1408:	61 e2       	ldi	r22, 0x21	; 33
    140a:	70 e0       	ldi	r23, 0x00	; 0
    140c:	82 e0       	ldi	r24, 0x02	; 2
    140e:	1f d1       	rcall	.+574    	; 0x164e <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    1410:	c8 2e       	mov	r12, r24
    1412:	d1 2c       	mov	r13, r1
    1414:	60 e2       	ldi	r22, 0x20	; 32
    1416:	70 e0       	ldi	r23, 0x00	; 0
    1418:	82 e0       	ldi	r24, 0x02	; 2
    141a:	19 d1       	rcall	.+562    	; 0x164e <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCACAL0);
    141c:	dc 2c       	mov	r13, r12
    141e:	cc 24       	eor	r12, r12
    1420:	c8 2a       	or	r12, r24
    1422:	10 c0       	rjmp	.+32     	; 0x1444 <adc_write_configuration+0x60>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1424:	80 34       	cpi	r24, 0x40	; 64
    1426:	92 40       	sbci	r25, 0x02	; 2
    1428:	c1 f5       	brne	.+112    	; 0x149a <adc_write_configuration+0xb6>
    142a:	65 e2       	ldi	r22, 0x25	; 37
    142c:	70 e0       	ldi	r23, 0x00	; 0
    142e:	82 e0       	ldi	r24, 0x02	; 2
    1430:	0e d1       	rcall	.+540    	; 0x164e <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    1432:	c8 2e       	mov	r12, r24
    1434:	d1 2c       	mov	r13, r1
    1436:	64 e2       	ldi	r22, 0x24	; 36
    1438:	70 e0       	ldi	r23, 0x00	; 0
    143a:	82 e0       	ldi	r24, 0x02	; 2
    143c:	08 d1       	rcall	.+528    	; 0x164e <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCBCAL0);
    143e:	dc 2c       	mov	r13, r12
    1440:	cc 24       	eor	r12, r12
    1442:	c8 2a       	or	r12, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    1444:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    1446:	89 83       	std	Y+1, r24	; 0x01
	return flags;
    1448:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    144a:	b9 80       	ldd	r11, Y+1	; 0x01
    144c:	c8 01       	movw	r24, r16
    144e:	d2 dd       	rcall	.-1116   	; 0xff4 <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1450:	f8 01       	movw	r30, r16
    1452:	80 81       	ld	r24, Z

	adc->CTRLA = ADC_FLUSH_bm;
    1454:	92 e0       	ldi	r25, 0x02	; 2
    1456:	90 83       	st	Z, r25
	adc->CAL = cal;
    1458:	c4 86       	std	Z+12, r12	; 0x0c
    145a:	d5 86       	std	Z+13, r13	; 0x0d
	adc->CMP = conf->cmp;
    145c:	f7 01       	movw	r30, r14
    145e:	25 81       	ldd	r18, Z+5	; 0x05
    1460:	36 81       	ldd	r19, Z+6	; 0x06
    1462:	f8 01       	movw	r30, r16
    1464:	20 8f       	std	Z+24, r18	; 0x18
    1466:	31 8f       	std	Z+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
    1468:	f7 01       	movw	r30, r14
    146a:	92 81       	ldd	r25, Z+2	; 0x02
    146c:	f8 01       	movw	r30, r16
    146e:	92 83       	std	Z+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
    1470:	f7 01       	movw	r30, r14
    1472:	94 81       	ldd	r25, Z+4	; 0x04
    1474:	f8 01       	movw	r30, r16
    1476:	94 83       	std	Z+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
    1478:	f7 01       	movw	r30, r14
    147a:	93 81       	ldd	r25, Z+3	; 0x03
    147c:	f8 01       	movw	r30, r16
    147e:	93 83       	std	Z+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    1480:	f7 01       	movw	r30, r14
    1482:	91 81       	ldd	r25, Z+1	; 0x01
    1484:	f8 01       	movw	r30, r16
    1486:	91 83       	std	Z+1, r25	; 0x01

	adc->CTRLA = enable | conf->ctrla;
    1488:	81 70       	andi	r24, 0x01	; 1
    148a:	f7 01       	movw	r30, r14
    148c:	90 81       	ld	r25, Z
    148e:	89 2b       	or	r24, r25
    1490:	f8 01       	movw	r30, r16

	adc_disable_clock(adc);
    1492:	80 83       	st	Z, r24
    1494:	c8 01       	movw	r24, r16
    1496:	cd dd       	rcall	.-1126   	; 0x1032 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1498:	bf be       	out	0x3f, r11	; 63

	cpu_irq_restore(flags);
}
    149a:	0f 90       	pop	r0
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	1f 91       	pop	r17
    14a2:	0f 91       	pop	r16
    14a4:	ff 90       	pop	r15
    14a6:	ef 90       	pop	r14
    14a8:	df 90       	pop	r13
    14aa:	cf 90       	pop	r12
    14ac:	bf 90       	pop	r11
    14ae:	08 95       	ret

000014b0 <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    14b0:	df 92       	push	r13
    14b2:	ef 92       	push	r14
    14b4:	ff 92       	push	r15
    14b6:	0f 93       	push	r16
    14b8:	1f 93       	push	r17
    14ba:	cf 93       	push	r28
    14bc:	df 93       	push	r29
    14be:	1f 92       	push	r1
    14c0:	cd b7       	in	r28, 0x3d	; 61
    14c2:	de b7       	in	r29, 0x3e	; 62
    14c4:	8c 01       	movw	r16, r24
    14c6:	7b 01       	movw	r14, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    14c8:	8f b7       	in	r24, 0x3f	; 63
    14ca:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    14cc:	f8 94       	cli
	return flags;
    14ce:	d9 80       	ldd	r13, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    14d0:	c8 01       	movw	r24, r16
    14d2:	90 dd       	rcall	.-1248   	; 0xff4 <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    14d4:	f8 01       	movw	r30, r16
    14d6:	80 81       	ld	r24, Z
    14d8:	80 7c       	andi	r24, 0xC0	; 192
    14da:	f7 01       	movw	r30, r14
    14dc:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    14de:	f8 01       	movw	r30, r16
    14e0:	80 8d       	ldd	r24, Z+24	; 0x18
    14e2:	91 8d       	ldd	r25, Z+25	; 0x19
    14e4:	f7 01       	movw	r30, r14
    14e6:	85 83       	std	Z+5, r24	; 0x05
    14e8:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    14ea:	f8 01       	movw	r30, r16
    14ec:	82 81       	ldd	r24, Z+2	; 0x02
    14ee:	f7 01       	movw	r30, r14
    14f0:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    14f2:	f8 01       	movw	r30, r16
    14f4:	84 81       	ldd	r24, Z+4	; 0x04
    14f6:	f7 01       	movw	r30, r14
    14f8:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    14fa:	f8 01       	movw	r30, r16
    14fc:	83 81       	ldd	r24, Z+3	; 0x03
    14fe:	f7 01       	movw	r30, r14
    1500:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    1502:	f8 01       	movw	r30, r16
    1504:	81 81       	ldd	r24, Z+1	; 0x01
    1506:	f7 01       	movw	r30, r14
    1508:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    150a:	c8 01       	movw	r24, r16
    150c:	92 dd       	rcall	.-1244   	; 0x1032 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    150e:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    1510:	0f 90       	pop	r0
    1512:	df 91       	pop	r29
    1514:	cf 91       	pop	r28
    1516:	1f 91       	pop	r17
    1518:	0f 91       	pop	r16
    151a:	ff 90       	pop	r15
    151c:	ef 90       	pop	r14
    151e:	df 90       	pop	r13
    1520:	08 95       	ret

00001522 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    1522:	af 92       	push	r10
    1524:	bf 92       	push	r11
    1526:	cf 92       	push	r12
    1528:	df 92       	push	r13
    152a:	ef 92       	push	r14
    152c:	ff 92       	push	r15
    152e:	0f 93       	push	r16
    1530:	1f 93       	push	r17
    1532:	cf 93       	push	r28
    1534:	df 93       	push	r29
    1536:	1f 92       	push	r1
    1538:	cd b7       	in	r28, 0x3d	; 61
    153a:	de b7       	in	r29, 0x3e	; 62
    153c:	6c 01       	movw	r12, r24
    153e:	b6 2e       	mov	r11, r22
    1540:	7a 01       	movw	r14, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1542:	86 2f       	mov	r24, r22
    1544:	83 70       	andi	r24, 0x03	; 3
    1546:	29 f4       	brne	.+10     	; 0x1552 <adcch_write_configuration+0x30>
		index += 2;
		ch_mask >>= 2;
    1548:	96 2f       	mov	r25, r22
    154a:	96 95       	lsr	r25
    154c:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    154e:	82 e0       	ldi	r24, 0x02	; 2
    1550:	02 c0       	rjmp	.+4      	; 0x1556 <adcch_write_configuration+0x34>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1552:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
__always_inline static  ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1554:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1556:	90 ff       	sbrs	r25, 0
		index++;
    1558:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    155a:	86 01       	movw	r16, r12
    155c:	00 5e       	subi	r16, 0xE0	; 224
    155e:	1f 4f       	sbci	r17, 0xFF	; 255
    1560:	98 e0       	ldi	r25, 0x08	; 8
    1562:	89 9f       	mul	r24, r25
    1564:	00 0d       	add	r16, r0
    1566:	11 1d       	adc	r17, r1
    1568:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    156a:	8f b7       	in	r24, 0x3f	; 63
    156c:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    156e:	f8 94       	cli
	return flags;
    1570:	a9 80       	ldd	r10, Y+1	; 0x01
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1572:	c6 01       	movw	r24, r12
    1574:	3f dd       	rcall	.-1410   	; 0xff4 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    1576:	f7 01       	movw	r30, r14
    1578:	80 81       	ld	r24, Z
    157a:	f8 01       	movw	r30, r16
    157c:	80 83       	st	Z, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    157e:	f7 01       	movw	r30, r14
    1580:	82 81       	ldd	r24, Z+2	; 0x02
    1582:	f8 01       	movw	r30, r16
    1584:	82 83       	std	Z+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    1586:	f7 01       	movw	r30, r14
    1588:	81 81       	ldd	r24, Z+1	; 0x01
    158a:	f8 01       	movw	r30, r16
    158c:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    158e:	b0 fe       	sbrs	r11, 0
    1590:	04 c0       	rjmp	.+8      	; 0x159a <adcch_write_configuration+0x78>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    1592:	f7 01       	movw	r30, r14
    1594:	83 81       	ldd	r24, Z+3	; 0x03
    1596:	f8 01       	movw	r30, r16
    1598:	86 83       	std	Z+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    159a:	c6 01       	movw	r24, r12
    159c:	4a dd       	rcall	.-1388   	; 0x1032 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    159e:	af be       	out	0x3f, r10	; 63

	cpu_irq_restore(flags);
}
    15a0:	0f 90       	pop	r0
    15a2:	df 91       	pop	r29
    15a4:	cf 91       	pop	r28
    15a6:	1f 91       	pop	r17
    15a8:	0f 91       	pop	r16
    15aa:	ff 90       	pop	r15
    15ac:	ef 90       	pop	r14
    15ae:	df 90       	pop	r13
    15b0:	cf 90       	pop	r12
    15b2:	bf 90       	pop	r11
    15b4:	af 90       	pop	r10
    15b6:	08 95       	ret

000015b8 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    15b8:	af 92       	push	r10
    15ba:	bf 92       	push	r11
    15bc:	cf 92       	push	r12
    15be:	df 92       	push	r13
    15c0:	ef 92       	push	r14
    15c2:	ff 92       	push	r15
    15c4:	0f 93       	push	r16
    15c6:	1f 93       	push	r17
    15c8:	cf 93       	push	r28
    15ca:	df 93       	push	r29
    15cc:	1f 92       	push	r1
    15ce:	cd b7       	in	r28, 0x3d	; 61
    15d0:	de b7       	in	r29, 0x3e	; 62
    15d2:	6c 01       	movw	r12, r24
    15d4:	b6 2e       	mov	r11, r22
    15d6:	7a 01       	movw	r14, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    15d8:	86 2f       	mov	r24, r22
    15da:	83 70       	andi	r24, 0x03	; 3
    15dc:	29 f4       	brne	.+10     	; 0x15e8 <adcch_read_configuration+0x30>
		index += 2;
		ch_mask >>= 2;
    15de:	96 2f       	mov	r25, r22
    15e0:	96 95       	lsr	r25
    15e2:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    15e4:	82 e0       	ldi	r24, 0x02	; 2
    15e6:	02 c0       	rjmp	.+4      	; 0x15ec <adcch_read_configuration+0x34>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    15e8:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
__always_inline static  ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    15ea:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    15ec:	90 ff       	sbrs	r25, 0
		index++;
    15ee:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    15f0:	86 01       	movw	r16, r12
    15f2:	00 5e       	subi	r16, 0xE0	; 224
    15f4:	1f 4f       	sbci	r17, 0xFF	; 255
    15f6:	98 e0       	ldi	r25, 0x08	; 8
    15f8:	89 9f       	mul	r24, r25
    15fa:	00 0d       	add	r16, r0
    15fc:	11 1d       	adc	r17, r1
    15fe:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    1600:	8f b7       	in	r24, 0x3f	; 63
    1602:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    1604:	f8 94       	cli
	return flags;
    1606:	a9 80       	ldd	r10, Y+1	; 0x01

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1608:	c6 01       	movw	r24, r12
    160a:	f4 dc       	rcall	.-1560   	; 0xff4 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    160c:	f8 01       	movw	r30, r16
    160e:	80 81       	ld	r24, Z
    1610:	f7 01       	movw	r30, r14
    1612:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    1614:	f8 01       	movw	r30, r16
    1616:	82 81       	ldd	r24, Z+2	; 0x02
    1618:	f7 01       	movw	r30, r14
    161a:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    161c:	f8 01       	movw	r30, r16
    161e:	81 81       	ldd	r24, Z+1	; 0x01
    1620:	f7 01       	movw	r30, r14
    1622:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1624:	b0 fe       	sbrs	r11, 0
    1626:	04 c0       	rjmp	.+8      	; 0x1630 <adcch_read_configuration+0x78>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1628:	f8 01       	movw	r30, r16
    162a:	86 81       	ldd	r24, Z+6	; 0x06
    162c:	f7 01       	movw	r30, r14
    162e:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    1630:	c6 01       	movw	r24, r12
    1632:	ff dc       	rcall	.-1538   	; 0x1032 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1634:	af be       	out	0x3f, r10	; 63

	cpu_irq_restore(flags);
}
    1636:	0f 90       	pop	r0
    1638:	df 91       	pop	r29
    163a:	cf 91       	pop	r28
    163c:	1f 91       	pop	r17
    163e:	0f 91       	pop	r16
    1640:	ff 90       	pop	r15
    1642:	ef 90       	pop	r14
    1644:	df 90       	pop	r13
    1646:	cf 90       	pop	r12
    1648:	bf 90       	pop	r11
    164a:	af 90       	pop	r10
    164c:	08 95       	ret

0000164e <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    164e:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    1652:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    1654:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    1656:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    165a:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    165c:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    1660:	08 95       	ret

00001662 <twim_interrupt_handler>:
 * \brief Common TWI master interrupt service routine.
 *
 *  Check current status and calls the appropriate handler.
 */
static void twim_interrupt_handler(void)
{
    1662:	cf 93       	push	r28
    1664:	df 93       	push	r29
	uint8_t const master_status = transfer.bus->MASTER.STATUS;
    1666:	e0 91 4e 22 	lds	r30, 0x224E	; 0x80224e <transfer>
    166a:	f0 91 4f 22 	lds	r31, 0x224F	; 0x80224f <transfer+0x1>
    166e:	84 81       	ldd	r24, Z+4	; 0x04

	if (master_status & TWI_MASTER_ARBLOST_bm) {
    1670:	83 ff       	sbrs	r24, 3
    1672:	08 c0       	rjmp	.+16     	; 0x1684 <twim_interrupt_handler+0x22>

		transfer.bus->MASTER.STATUS = master_status | TWI_MASTER_ARBLOST_bm;
    1674:	88 60       	ori	r24, 0x08	; 8
    1676:	84 83       	std	Z+4, r24	; 0x04
		transfer.bus->MASTER.CTRLC  = TWI_MASTER_CMD_STOP_gc;
    1678:	83 e0       	ldi	r24, 0x03	; 3
    167a:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_BUSY;
    167c:	86 ef       	ldi	r24, 0xF6	; 246
    167e:	80 93 58 22 	sts	0x2258, r24	; 0x802258 <transfer+0xa>
    1682:	83 c0       	rjmp	.+262    	; 0x178a <twim_interrupt_handler+0x128>

	} else if ((master_status & TWI_MASTER_BUSERR_bm) ||
    1684:	98 2f       	mov	r25, r24
    1686:	94 71       	andi	r25, 0x14	; 20
    1688:	31 f0       	breq	.+12     	; 0x1696 <twim_interrupt_handler+0x34>
		(master_status & TWI_MASTER_RXACK_bm)) {

		transfer.bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    168a:	83 e0       	ldi	r24, 0x03	; 3
    168c:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_IO_ERROR;
    168e:	8f ef       	ldi	r24, 0xFF	; 255
    1690:	80 93 58 22 	sts	0x2258, r24	; 0x802258 <transfer+0xa>
    1694:	7a c0       	rjmp	.+244    	; 0x178a <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {
    1696:	86 ff       	sbrs	r24, 6
    1698:	43 c0       	rjmp	.+134    	; 0x1720 <twim_interrupt_handler+0xbe>
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 */
static inline void twim_write_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    169a:	ce e4       	ldi	r28, 0x4E	; 78
    169c:	d2 e2       	ldi	r29, 0x22	; 34
    169e:	aa 81       	ldd	r26, Y+2	; 0x02
    16a0:	bb 81       	ldd	r27, Y+3	; 0x03

	if (transfer.addr_count < pkg->addr_length) {
    16a2:	8c 81       	ldd	r24, Y+4	; 0x04
    16a4:	9d 81       	ldd	r25, Y+5	; 0x05
    16a6:	14 96       	adiw	r26, 0x04	; 4
    16a8:	2d 91       	ld	r18, X+
    16aa:	3c 91       	ld	r19, X
    16ac:	15 97       	sbiw	r26, 0x05	; 5
    16ae:	82 17       	cp	r24, r18
    16b0:	93 07       	cpc	r25, r19
    16b2:	6c f4       	brge	.+26     	; 0x16ce <twim_interrupt_handler+0x6c>

		const uint8_t * const data = pkg->addr;
		bus->MASTER.DATA = data[transfer.addr_count++];
    16b4:	9c 01       	movw	r18, r24
    16b6:	2f 5f       	subi	r18, 0xFF	; 255
    16b8:	3f 4f       	sbci	r19, 0xFF	; 255
    16ba:	20 93 52 22 	sts	0x2252, r18	; 0x802252 <transfer+0x4>
    16be:	30 93 53 22 	sts	0x2253, r19	; 0x802253 <transfer+0x5>
    16c2:	a8 0f       	add	r26, r24
    16c4:	b9 1f       	adc	r27, r25
    16c6:	11 96       	adiw	r26, 0x01	; 1
    16c8:	8c 91       	ld	r24, X
    16ca:	87 83       	std	Z+7, r24	; 0x07
    16cc:	5e c0       	rjmp	.+188    	; 0x178a <twim_interrupt_handler+0x128>

	} else if (transfer.data_count < pkg->length) {
    16ce:	80 91 54 22 	lds	r24, 0x2254	; 0x802254 <transfer+0x6>
    16d2:	90 91 55 22 	lds	r25, 0x2255	; 0x802255 <transfer+0x7>
    16d6:	18 96       	adiw	r26, 0x08	; 8
    16d8:	2d 91       	ld	r18, X+
    16da:	3c 91       	ld	r19, X
    16dc:	19 97       	sbiw	r26, 0x09	; 9
    16de:	82 17       	cp	r24, r18
    16e0:	93 07       	cpc	r25, r19
    16e2:	c8 f4       	brcc	.+50     	; 0x1716 <twim_interrupt_handler+0xb4>

		if (transfer.read) {
    16e4:	20 91 56 22 	lds	r18, 0x2256	; 0x802256 <transfer+0x8>
    16e8:	22 23       	and	r18, r18
    16ea:	21 f0       	breq	.+8      	; 0x16f4 <twim_interrupt_handler+0x92>

			/* Send repeated START condition (Address|R/W=1). */

			bus->MASTER.ADDR |= 0x01;
    16ec:	86 81       	ldd	r24, Z+6	; 0x06
    16ee:	81 60       	ori	r24, 0x01	; 1
    16f0:	86 83       	std	Z+6, r24	; 0x06
    16f2:	4b c0       	rjmp	.+150    	; 0x178a <twim_interrupt_handler+0x128>

		} else {
			const uint8_t * const data = pkg->buffer;
    16f4:	16 96       	adiw	r26, 0x06	; 6
    16f6:	2d 91       	ld	r18, X+
    16f8:	3c 91       	ld	r19, X
    16fa:	17 97       	sbiw	r26, 0x07	; 7
			bus->MASTER.DATA = data[transfer.data_count++];
    16fc:	ac 01       	movw	r20, r24
    16fe:	4f 5f       	subi	r20, 0xFF	; 255
    1700:	5f 4f       	sbci	r21, 0xFF	; 255
    1702:	40 93 54 22 	sts	0x2254, r20	; 0x802254 <transfer+0x6>
    1706:	50 93 55 22 	sts	0x2255, r21	; 0x802255 <transfer+0x7>
    170a:	d9 01       	movw	r26, r18
    170c:	a8 0f       	add	r26, r24
    170e:	b9 1f       	adc	r27, r25
    1710:	8c 91       	ld	r24, X
    1712:	87 83       	std	Z+7, r24	; 0x07
    1714:	3a c0       	rjmp	.+116    	; 0x178a <twim_interrupt_handler+0x128>

	} else {

		/* Send STOP condition to complete the transaction. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1716:	83 e0       	ldi	r24, 0x03	; 3
    1718:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = STATUS_OK;
    171a:	10 92 58 22 	sts	0x2258, r1	; 0x802258 <transfer+0xa>
    171e:	35 c0       	rjmp	.+106    	; 0x178a <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {

		twim_write_handler();

	} else if (master_status & TWI_MASTER_RIF_bm) {
    1720:	88 23       	and	r24, r24
    1722:	84 f5       	brge	.+96     	; 0x1784 <twim_interrupt_handler+0x122>
 *  reading bytes from the TWI slave.
 */
static inline void twim_read_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    1724:	ae e4       	ldi	r26, 0x4E	; 78
    1726:	b2 e2       	ldi	r27, 0x22	; 34
    1728:	12 96       	adiw	r26, 0x02	; 2
    172a:	cd 91       	ld	r28, X+
    172c:	dc 91       	ld	r29, X
    172e:	13 97       	sbiw	r26, 0x03	; 3

	if (transfer.data_count < pkg->length) {
    1730:	16 96       	adiw	r26, 0x06	; 6
    1732:	8d 91       	ld	r24, X+
    1734:	9c 91       	ld	r25, X
    1736:	17 97       	sbiw	r26, 0x07	; 7
    1738:	28 85       	ldd	r18, Y+8	; 0x08
    173a:	39 85       	ldd	r19, Y+9	; 0x09
    173c:	82 17       	cp	r24, r18
    173e:	93 07       	cpc	r25, r19
    1740:	d8 f4       	brcc	.+54     	; 0x1778 <twim_interrupt_handler+0x116>

		uint8_t * const data = pkg->buffer;
    1742:	6e 81       	ldd	r22, Y+6	; 0x06
    1744:	7f 81       	ldd	r23, Y+7	; 0x07
		data[transfer.data_count++] = bus->MASTER.DATA;
    1746:	9c 01       	movw	r18, r24
    1748:	2f 5f       	subi	r18, 0xFF	; 255
    174a:	3f 4f       	sbci	r19, 0xFF	; 255
    174c:	20 93 54 22 	sts	0x2254, r18	; 0x802254 <transfer+0x6>
    1750:	30 93 55 22 	sts	0x2255, r19	; 0x802255 <transfer+0x7>
    1754:	47 81       	ldd	r20, Z+7	; 0x07
    1756:	db 01       	movw	r26, r22
    1758:	a8 0f       	add	r26, r24
    175a:	b9 1f       	adc	r27, r25
    175c:	4c 93       	st	X, r20

		/* If there is more to read, issue ACK and start a byte read.
		 * Otherwise, issue NACK and STOP to complete the transaction.
		 */
		if (transfer.data_count < pkg->length) {
    175e:	88 85       	ldd	r24, Y+8	; 0x08
    1760:	99 85       	ldd	r25, Y+9	; 0x09
    1762:	28 17       	cp	r18, r24
    1764:	39 07       	cpc	r19, r25
    1766:	18 f4       	brcc	.+6      	; 0x176e <twim_interrupt_handler+0x10c>

			bus->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    1768:	82 e0       	ldi	r24, 0x02	; 2
    176a:	83 83       	std	Z+3, r24	; 0x03
    176c:	0e c0       	rjmp	.+28     	; 0x178a <twim_interrupt_handler+0x128>

		} else {

			bus->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    176e:	87 e0       	ldi	r24, 0x07	; 7
    1770:	83 83       	std	Z+3, r24	; 0x03
			transfer.status = STATUS_OK;
    1772:	10 92 58 22 	sts	0x2258, r1	; 0x802258 <transfer+0xa>
    1776:	09 c0       	rjmp	.+18     	; 0x178a <twim_interrupt_handler+0x128>

	} else {

		/* Issue STOP and buffer overflow condition. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1778:	83 e0       	ldi	r24, 0x03	; 3
    177a:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_NO_MEMORY;
    177c:	89 ef       	ldi	r24, 0xF9	; 249
    177e:	80 93 58 22 	sts	0x2258, r24	; 0x802258 <transfer+0xa>
    1782:	03 c0       	rjmp	.+6      	; 0x178a <twim_interrupt_handler+0x128>

		twim_read_handler();

	} else {

		transfer.status = ERR_PROTOCOL;
    1784:	8b ef       	ldi	r24, 0xFB	; 251
    1786:	80 93 58 22 	sts	0x2258, r24	; 0x802258 <transfer+0xa>
	}
}
    178a:	df 91       	pop	r29
    178c:	cf 91       	pop	r28
    178e:	08 95       	ret

00001790 <__vector_13>:
 * parameters specified in the global \c transfer structure.
 */
static void twim_interrupt_handler(void);

#ifdef TWIC
ISR(TWIC_TWIM_vect) { twim_interrupt_handler(); }
    1790:	1f 92       	push	r1
    1792:	0f 92       	push	r0
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	0f 92       	push	r0
    1798:	11 24       	eor	r1, r1
    179a:	0b b6       	in	r0, 0x3b	; 59
    179c:	0f 92       	push	r0
    179e:	2f 93       	push	r18
    17a0:	3f 93       	push	r19
    17a2:	4f 93       	push	r20
    17a4:	5f 93       	push	r21
    17a6:	6f 93       	push	r22
    17a8:	7f 93       	push	r23
    17aa:	8f 93       	push	r24
    17ac:	9f 93       	push	r25
    17ae:	af 93       	push	r26
    17b0:	bf 93       	push	r27
    17b2:	ef 93       	push	r30
    17b4:	ff 93       	push	r31
    17b6:	55 df       	rcall	.-342    	; 0x1662 <twim_interrupt_handler>
    17b8:	ff 91       	pop	r31
    17ba:	ef 91       	pop	r30
    17bc:	bf 91       	pop	r27
    17be:	af 91       	pop	r26
    17c0:	9f 91       	pop	r25
    17c2:	8f 91       	pop	r24
    17c4:	7f 91       	pop	r23
    17c6:	6f 91       	pop	r22
    17c8:	5f 91       	pop	r21
    17ca:	4f 91       	pop	r20
    17cc:	3f 91       	pop	r19
    17ce:	2f 91       	pop	r18
    17d0:	0f 90       	pop	r0
    17d2:	0b be       	out	0x3b, r0	; 59
    17d4:	0f 90       	pop	r0
    17d6:	0f be       	out	0x3f, r0	; 63
    17d8:	0f 90       	pop	r0
    17da:	1f 90       	pop	r1
    17dc:	18 95       	reti

000017de <__vector_46>:
#endif
#ifdef TWID
ISR(TWID_TWIM_vect) { twim_interrupt_handler(); }
#endif
#ifdef TWIE
ISR(TWIE_TWIM_vect) { twim_interrupt_handler(); }
    17de:	1f 92       	push	r1
    17e0:	0f 92       	push	r0
    17e2:	0f b6       	in	r0, 0x3f	; 63
    17e4:	0f 92       	push	r0
    17e6:	11 24       	eor	r1, r1
    17e8:	0b b6       	in	r0, 0x3b	; 59
    17ea:	0f 92       	push	r0
    17ec:	2f 93       	push	r18
    17ee:	3f 93       	push	r19
    17f0:	4f 93       	push	r20
    17f2:	5f 93       	push	r21
    17f4:	6f 93       	push	r22
    17f6:	7f 93       	push	r23
    17f8:	8f 93       	push	r24
    17fa:	9f 93       	push	r25
    17fc:	af 93       	push	r26
    17fe:	bf 93       	push	r27
    1800:	ef 93       	push	r30
    1802:	ff 93       	push	r31
    1804:	2e df       	rcall	.-420    	; 0x1662 <twim_interrupt_handler>
    1806:	ff 91       	pop	r31
    1808:	ef 91       	pop	r30
    180a:	bf 91       	pop	r27
    180c:	af 91       	pop	r26
    180e:	9f 91       	pop	r25
    1810:	8f 91       	pop	r24
    1812:	7f 91       	pop	r23
    1814:	6f 91       	pop	r22
    1816:	5f 91       	pop	r21
    1818:	4f 91       	pop	r20
    181a:	3f 91       	pop	r19
    181c:	2f 91       	pop	r18
    181e:	0f 90       	pop	r0
    1820:	0b be       	out	0x3b, r0	; 59
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63
    1826:	0f 90       	pop	r0
    1828:	1f 90       	pop	r1
    182a:	18 95       	reti

0000182c <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    182c:	4f 92       	push	r4
    182e:	5f 92       	push	r5
    1830:	6f 92       	push	r6
    1832:	7f 92       	push	r7
    1834:	8f 92       	push	r8
    1836:	9f 92       	push	r9
    1838:	af 92       	push	r10
    183a:	bf 92       	push	r11
    183c:	ef 92       	push	r14
    183e:	ff 92       	push	r15
    1840:	0f 93       	push	r16
    1842:	1f 93       	push	r17
    1844:	cf 93       	push	r28
    1846:	7c 01       	movw	r14, r24
    1848:	4a 01       	movw	r8, r20
    184a:	5b 01       	movw	r10, r22
    184c:	28 01       	movw	r4, r16
    184e:	39 01       	movw	r6, r18
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    1850:	fc 01       	movw	r30, r24
    1852:	84 81       	ldd	r24, Z+4	; 0x04
    1854:	82 ff       	sbrs	r24, 2
    1856:	16 c0       	rjmp	.+44     	; 0x1884 <usart_set_baudrate+0x58>

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    1858:	d9 01       	movw	r26, r18
    185a:	c8 01       	movw	r24, r16
    185c:	68 94       	set
    185e:	12 f8       	bld	r1, 2
    1860:	b6 95       	lsr	r27
    1862:	a7 95       	ror	r26
    1864:	97 95       	ror	r25
    1866:	87 95       	ror	r24
    1868:	16 94       	lsr	r1
    186a:	d1 f7       	brne	.-12     	; 0x1860 <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    186c:	b9 01       	movw	r22, r18
    186e:	a8 01       	movw	r20, r16
    1870:	03 2e       	mov	r0, r19
    1872:	36 e1       	ldi	r19, 0x16	; 22
    1874:	76 95       	lsr	r23
    1876:	67 95       	ror	r22
    1878:	57 95       	ror	r21
    187a:	47 95       	ror	r20
    187c:	3a 95       	dec	r19
    187e:	d1 f7       	brne	.-12     	; 0x1874 <usart_set_baudrate+0x48>
    1880:	30 2d       	mov	r19, r0
    1882:	15 c0       	rjmp	.+42     	; 0x18ae <usart_set_baudrate+0x82>

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
		max_rate /= 2;
    1884:	d9 01       	movw	r26, r18
    1886:	c8 01       	movw	r24, r16
    1888:	68 94       	set
    188a:	13 f8       	bld	r1, 3
    188c:	b6 95       	lsr	r27
    188e:	a7 95       	ror	r26
    1890:	97 95       	ror	r25
    1892:	87 95       	ror	r24
    1894:	16 94       	lsr	r1
    1896:	d1 f7       	brne	.-12     	; 0x188c <usart_set_baudrate+0x60>
		min_rate /= 2;
    1898:	b9 01       	movw	r22, r18
    189a:	a8 01       	movw	r20, r16
    189c:	03 2e       	mov	r0, r19
    189e:	37 e1       	ldi	r19, 0x17	; 23
    18a0:	76 95       	lsr	r23
    18a2:	67 95       	ror	r22
    18a4:	57 95       	ror	r21
    18a6:	47 95       	ror	r20
    18a8:	3a 95       	dec	r19
    18aa:	d1 f7       	brne	.-12     	; 0x18a0 <usart_set_baudrate+0x74>
    18ac:	30 2d       	mov	r19, r0
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    18ae:	88 15       	cp	r24, r8
    18b0:	99 05       	cpc	r25, r9
    18b2:	aa 05       	cpc	r26, r10
    18b4:	bb 05       	cpc	r27, r11
    18b6:	08 f4       	brcc	.+2      	; 0x18ba <usart_set_baudrate+0x8e>
    18b8:	a6 c0       	rjmp	.+332    	; 0x1a06 <usart_set_baudrate+0x1da>
    18ba:	84 16       	cp	r8, r20
    18bc:	95 06       	cpc	r9, r21
    18be:	a6 06       	cpc	r10, r22
    18c0:	b7 06       	cpc	r11, r23
    18c2:	08 f4       	brcc	.+2      	; 0x18c6 <usart_set_baudrate+0x9a>
    18c4:	a2 c0       	rjmp	.+324    	; 0x1a0a <usart_set_baudrate+0x1de>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    18c6:	f7 01       	movw	r30, r14
    18c8:	84 81       	ldd	r24, Z+4	; 0x04
    18ca:	82 fd       	sbrc	r24, 2
    18cc:	04 c0       	rjmp	.+8      	; 0x18d6 <usart_set_baudrate+0xaa>
		baud *= 2;
    18ce:	88 0c       	add	r8, r8
    18d0:	99 1c       	adc	r9, r9
    18d2:	aa 1c       	adc	r10, r10
    18d4:	bb 1c       	adc	r11, r11
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    18d6:	c3 01       	movw	r24, r6
    18d8:	b2 01       	movw	r22, r4
    18da:	a5 01       	movw	r20, r10
    18dc:	94 01       	movw	r18, r8
    18de:	0e 94 67 1e 	call	0x3cce	; 0x3cce <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    18e2:	2f 3f       	cpi	r18, 0xFF	; 255
    18e4:	31 05       	cpc	r19, r1
    18e6:	41 05       	cpc	r20, r1
    18e8:	51 05       	cpc	r21, r1
    18ea:	08 f4       	brcc	.+2      	; 0x18ee <usart_set_baudrate+0xc2>
    18ec:	90 c0       	rjmp	.+288    	; 0x1a0e <usart_set_baudrate+0x1e2>
    18ee:	8f ef       	ldi	r24, 0xFF	; 255
    18f0:	90 e0       	ldi	r25, 0x00	; 0
    18f2:	a0 e0       	ldi	r26, 0x00	; 0
    18f4:	b0 e0       	ldi	r27, 0x00	; 0
    18f6:	c9 ef       	ldi	r28, 0xF9	; 249
    18f8:	05 c0       	rjmp	.+10     	; 0x1904 <usart_set_baudrate+0xd8>
    18fa:	28 17       	cp	r18, r24
    18fc:	39 07       	cpc	r19, r25
    18fe:	4a 07       	cpc	r20, r26
    1900:	5b 07       	cpc	r21, r27
    1902:	58 f0       	brcs	.+22     	; 0x191a <usart_set_baudrate+0xee>
			break;
		}

		limit <<= 1;
    1904:	88 0f       	add	r24, r24
    1906:	99 1f       	adc	r25, r25
    1908:	aa 1f       	adc	r26, r26
    190a:	bb 1f       	adc	r27, r27

		if (exp < -3) {
    190c:	cd 3f       	cpi	r28, 0xFD	; 253
    190e:	0c f4       	brge	.+2      	; 0x1912 <usart_set_baudrate+0xe6>
			limit |= 1;
    1910:	81 60       	ori	r24, 0x01	; 1
    1912:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1914:	c7 30       	cpi	r28, 0x07	; 7
    1916:	89 f7       	brne	.-30     	; 0x18fa <usart_set_baudrate+0xce>
    1918:	4f c0       	rjmp	.+158    	; 0x19b8 <usart_set_baudrate+0x18c>
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    191a:	cc 23       	and	r28, r28
    191c:	0c f0       	brlt	.+2      	; 0x1920 <usart_set_baudrate+0xf4>
    191e:	4c c0       	rjmp	.+152    	; 0x19b8 <usart_set_baudrate+0x18c>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    1920:	d5 01       	movw	r26, r10
    1922:	c4 01       	movw	r24, r8
    1924:	88 0f       	add	r24, r24
    1926:	99 1f       	adc	r25, r25
    1928:	aa 1f       	adc	r26, r26
    192a:	bb 1f       	adc	r27, r27
    192c:	88 0f       	add	r24, r24
    192e:	99 1f       	adc	r25, r25
    1930:	aa 1f       	adc	r26, r26
    1932:	bb 1f       	adc	r27, r27
    1934:	88 0f       	add	r24, r24
    1936:	99 1f       	adc	r25, r25
    1938:	aa 1f       	adc	r26, r26
    193a:	bb 1f       	adc	r27, r27
    193c:	48 1a       	sub	r4, r24
    193e:	59 0a       	sbc	r5, r25
    1940:	6a 0a       	sbc	r6, r26
    1942:	7b 0a       	sbc	r7, r27
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    1944:	ce 3f       	cpi	r28, 0xFE	; 254
    1946:	f4 f4       	brge	.+60     	; 0x1984 <usart_set_baudrate+0x158>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    1948:	8d ef       	ldi	r24, 0xFD	; 253
    194a:	9f ef       	ldi	r25, 0xFF	; 255
    194c:	8c 1b       	sub	r24, r28
    194e:	91 09       	sbc	r25, r1
    1950:	c7 fd       	sbrc	r28, 7
    1952:	93 95       	inc	r25
    1954:	04 c0       	rjmp	.+8      	; 0x195e <usart_set_baudrate+0x132>
    1956:	44 0c       	add	r4, r4
    1958:	55 1c       	adc	r5, r5
    195a:	66 1c       	adc	r6, r6
    195c:	77 1c       	adc	r7, r7
    195e:	8a 95       	dec	r24
    1960:	d2 f7       	brpl	.-12     	; 0x1956 <usart_set_baudrate+0x12a>
    1962:	d5 01       	movw	r26, r10
    1964:	c4 01       	movw	r24, r8
    1966:	b6 95       	lsr	r27
    1968:	a7 95       	ror	r26
    196a:	97 95       	ror	r25
    196c:	87 95       	ror	r24
    196e:	bc 01       	movw	r22, r24
    1970:	cd 01       	movw	r24, r26
    1972:	64 0d       	add	r22, r4
    1974:	75 1d       	adc	r23, r5
    1976:	86 1d       	adc	r24, r6
    1978:	97 1d       	adc	r25, r7
    197a:	a5 01       	movw	r20, r10
    197c:	94 01       	movw	r18, r8
    197e:	0e 94 67 1e 	call	0x3cce	; 0x3cce <__udivmodsi4>
    1982:	37 c0       	rjmp	.+110    	; 0x19f2 <usart_set_baudrate+0x1c6>
		} else {
			baud <<= exp + 3;
    1984:	83 e0       	ldi	r24, 0x03	; 3
    1986:	8c 0f       	add	r24, r28
    1988:	a5 01       	movw	r20, r10
    198a:	94 01       	movw	r18, r8
    198c:	04 c0       	rjmp	.+8      	; 0x1996 <usart_set_baudrate+0x16a>
    198e:	22 0f       	add	r18, r18
    1990:	33 1f       	adc	r19, r19
    1992:	44 1f       	adc	r20, r20
    1994:	55 1f       	adc	r21, r21
    1996:	8a 95       	dec	r24
    1998:	d2 f7       	brpl	.-12     	; 0x198e <usart_set_baudrate+0x162>
			div = (cpu_hz + baud / 2) / baud;
    199a:	da 01       	movw	r26, r20
    199c:	c9 01       	movw	r24, r18
    199e:	b6 95       	lsr	r27
    19a0:	a7 95       	ror	r26
    19a2:	97 95       	ror	r25
    19a4:	87 95       	ror	r24
    19a6:	bc 01       	movw	r22, r24
    19a8:	cd 01       	movw	r24, r26
    19aa:	64 0d       	add	r22, r4
    19ac:	75 1d       	adc	r23, r5
    19ae:	86 1d       	adc	r24, r6
    19b0:	97 1d       	adc	r25, r7
    19b2:	0e 94 67 1e 	call	0x3cce	; 0x3cce <__udivmodsi4>
    19b6:	1d c0       	rjmp	.+58     	; 0x19f2 <usart_set_baudrate+0x1c6>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    19b8:	83 e0       	ldi	r24, 0x03	; 3
    19ba:	8c 0f       	add	r24, r28
    19bc:	a5 01       	movw	r20, r10
    19be:	94 01       	movw	r18, r8
    19c0:	04 c0       	rjmp	.+8      	; 0x19ca <usart_set_baudrate+0x19e>
    19c2:	22 0f       	add	r18, r18
    19c4:	33 1f       	adc	r19, r19
    19c6:	44 1f       	adc	r20, r20
    19c8:	55 1f       	adc	r21, r21
    19ca:	8a 95       	dec	r24
    19cc:	d2 f7       	brpl	.-12     	; 0x19c2 <usart_set_baudrate+0x196>
		div = (cpu_hz + baud / 2) / baud - 1;
    19ce:	da 01       	movw	r26, r20
    19d0:	c9 01       	movw	r24, r18
    19d2:	b6 95       	lsr	r27
    19d4:	a7 95       	ror	r26
    19d6:	97 95       	ror	r25
    19d8:	87 95       	ror	r24
    19da:	bc 01       	movw	r22, r24
    19dc:	cd 01       	movw	r24, r26
    19de:	64 0d       	add	r22, r4
    19e0:	75 1d       	adc	r23, r5
    19e2:	86 1d       	adc	r24, r6
    19e4:	97 1d       	adc	r25, r7
    19e6:	0e 94 67 1e 	call	0x3cce	; 0x3cce <__udivmodsi4>
    19ea:	21 50       	subi	r18, 0x01	; 1
    19ec:	31 09       	sbc	r19, r1
    19ee:	41 09       	sbc	r20, r1
    19f0:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    19f2:	83 2f       	mov	r24, r19
    19f4:	8f 70       	andi	r24, 0x0F	; 15
    19f6:	c2 95       	swap	r28
    19f8:	c0 7f       	andi	r28, 0xF0	; 240
    19fa:	c8 2b       	or	r28, r24
    19fc:	f7 01       	movw	r30, r14
    19fe:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    1a00:	26 83       	std	Z+6, r18	; 0x06

	return true;
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	18 c0       	rjmp	.+48     	; 0x1a36 <usart_set_baudrate+0x20a>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    1a06:	80 e0       	ldi	r24, 0x00	; 0
    1a08:	16 c0       	rjmp	.+44     	; 0x1a36 <usart_set_baudrate+0x20a>
    1a0a:	80 e0       	ldi	r24, 0x00	; 0
    1a0c:	14 c0       	rjmp	.+40     	; 0x1a36 <usart_set_baudrate+0x20a>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    1a0e:	d5 01       	movw	r26, r10
    1a10:	c4 01       	movw	r24, r8
    1a12:	88 0f       	add	r24, r24
    1a14:	99 1f       	adc	r25, r25
    1a16:	aa 1f       	adc	r26, r26
    1a18:	bb 1f       	adc	r27, r27
    1a1a:	88 0f       	add	r24, r24
    1a1c:	99 1f       	adc	r25, r25
    1a1e:	aa 1f       	adc	r26, r26
    1a20:	bb 1f       	adc	r27, r27
    1a22:	88 0f       	add	r24, r24
    1a24:	99 1f       	adc	r25, r25
    1a26:	aa 1f       	adc	r26, r26
    1a28:	bb 1f       	adc	r27, r27
    1a2a:	48 1a       	sub	r4, r24
    1a2c:	59 0a       	sbc	r5, r25
    1a2e:	6a 0a       	sbc	r6, r26
    1a30:	7b 0a       	sbc	r7, r27

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1a32:	c9 ef       	ldi	r28, 0xF9	; 249
    1a34:	89 cf       	rjmp	.-238    	; 0x1948 <usart_set_baudrate+0x11c>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    1a36:	cf 91       	pop	r28
    1a38:	1f 91       	pop	r17
    1a3a:	0f 91       	pop	r16
    1a3c:	ff 90       	pop	r15
    1a3e:	ef 90       	pop	r14
    1a40:	bf 90       	pop	r11
    1a42:	af 90       	pop	r10
    1a44:	9f 90       	pop	r9
    1a46:	8f 90       	pop	r8
    1a48:	7f 90       	pop	r7
    1a4a:	6f 90       	pop	r6
    1a4c:	5f 90       	pop	r5
    1a4e:	4f 90       	pop	r4
    1a50:	08 95       	ret

00001a52 <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    1a52:	0f 93       	push	r16
    1a54:	1f 93       	push	r17
    1a56:	cf 93       	push	r28
    1a58:	df 93       	push	r29
    1a5a:	ec 01       	movw	r28, r24
    1a5c:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1a5e:	00 97       	sbiw	r24, 0x00	; 0
    1a60:	09 f4       	brne	.+2      	; 0x1a64 <usart_init_rs232+0x12>
    1a62:	03 c1       	rjmp	.+518    	; 0x1c6a <usart_init_rs232+0x218>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1a64:	80 3c       	cpi	r24, 0xC0	; 192
    1a66:	91 05       	cpc	r25, r1
    1a68:	29 f4       	brne	.+10     	; 0x1a74 <usart_init_rs232+0x22>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1a6a:	60 e1       	ldi	r22, 0x10	; 16
    1a6c:	80 e0       	ldi	r24, 0x00	; 0
    1a6e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1a72:	fb c0       	rjmp	.+502    	; 0x1c6a <usart_init_rs232+0x218>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1a74:	c0 38       	cpi	r28, 0x80	; 128
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	d8 07       	cpc	r29, r24
    1a7a:	29 f4       	brne	.+10     	; 0x1a86 <usart_init_rs232+0x34>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1a7c:	62 e0       	ldi	r22, 0x02	; 2
    1a7e:	80 e0       	ldi	r24, 0x00	; 0
    1a80:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1a84:	f2 c0       	rjmp	.+484    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1a86:	c1 15       	cp	r28, r1
    1a88:	e1 e0       	ldi	r30, 0x01	; 1
    1a8a:	de 07       	cpc	r29, r30
    1a8c:	29 f4       	brne	.+10     	; 0x1a98 <usart_init_rs232+0x46>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1a8e:	61 e0       	ldi	r22, 0x01	; 1
    1a90:	80 e0       	ldi	r24, 0x00	; 0
    1a92:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1a96:	e9 c0       	rjmp	.+466    	; 0x1c6a <usart_init_rs232+0x218>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1a98:	c0 38       	cpi	r28, 0x80	; 128
    1a9a:	f3 e0       	ldi	r31, 0x03	; 3
    1a9c:	df 07       	cpc	r29, r31
    1a9e:	29 f4       	brne	.+10     	; 0x1aaa <usart_init_rs232+0x58>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1aa0:	61 e0       	ldi	r22, 0x01	; 1
    1aa2:	81 e0       	ldi	r24, 0x01	; 1
    1aa4:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1aa8:	e0 c0       	rjmp	.+448    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1aaa:	c0 39       	cpi	r28, 0x90	; 144
    1aac:	83 e0       	ldi	r24, 0x03	; 3
    1aae:	d8 07       	cpc	r29, r24
    1ab0:	29 f4       	brne	.+10     	; 0x1abc <usart_init_rs232+0x6a>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1ab2:	61 e0       	ldi	r22, 0x01	; 1
    1ab4:	82 e0       	ldi	r24, 0x02	; 2
    1ab6:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1aba:	d7 c0       	rjmp	.+430    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1abc:	c1 15       	cp	r28, r1
    1abe:	e2 e0       	ldi	r30, 0x02	; 2
    1ac0:	de 07       	cpc	r29, r30
    1ac2:	29 f4       	brne	.+10     	; 0x1ace <usart_init_rs232+0x7c>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1ac4:	62 e0       	ldi	r22, 0x02	; 2
    1ac6:	81 e0       	ldi	r24, 0x01	; 1
    1ac8:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1acc:	ce c0       	rjmp	.+412    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1ace:	c0 34       	cpi	r28, 0x40	; 64
    1ad0:	f2 e0       	ldi	r31, 0x02	; 2
    1ad2:	df 07       	cpc	r29, r31
    1ad4:	29 f4       	brne	.+10     	; 0x1ae0 <usart_init_rs232+0x8e>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1ad6:	62 e0       	ldi	r22, 0x02	; 2
    1ad8:	82 e0       	ldi	r24, 0x02	; 2
    1ada:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ade:	c5 c0       	rjmp	.+394    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1ae0:	c0 32       	cpi	r28, 0x20	; 32
    1ae2:	83 e0       	ldi	r24, 0x03	; 3
    1ae4:	d8 07       	cpc	r29, r24
    1ae6:	29 f4       	brne	.+10     	; 0x1af2 <usart_init_rs232+0xa0>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1ae8:	64 e0       	ldi	r22, 0x04	; 4
    1aea:	82 e0       	ldi	r24, 0x02	; 2
    1aec:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1af0:	bc c0       	rjmp	.+376    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1af2:	c1 15       	cp	r28, r1
    1af4:	e8 e0       	ldi	r30, 0x08	; 8
    1af6:	de 07       	cpc	r29, r30
    1af8:	29 f4       	brne	.+10     	; 0x1b04 <usart_init_rs232+0xb2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1afa:	61 e0       	ldi	r22, 0x01	; 1
    1afc:	83 e0       	ldi	r24, 0x03	; 3
    1afe:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b02:	b3 c0       	rjmp	.+358    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1b04:	c1 15       	cp	r28, r1
    1b06:	f9 e0       	ldi	r31, 0x09	; 9
    1b08:	df 07       	cpc	r29, r31
    1b0a:	29 f4       	brne	.+10     	; 0x1b16 <usart_init_rs232+0xc4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1b0c:	61 e0       	ldi	r22, 0x01	; 1
    1b0e:	84 e0       	ldi	r24, 0x04	; 4
    1b10:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b14:	aa c0       	rjmp	.+340    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1b16:	c1 15       	cp	r28, r1
    1b18:	8a e0       	ldi	r24, 0x0A	; 10
    1b1a:	d8 07       	cpc	r29, r24
    1b1c:	29 f4       	brne	.+10     	; 0x1b28 <usart_init_rs232+0xd6>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1b1e:	61 e0       	ldi	r22, 0x01	; 1
    1b20:	85 e0       	ldi	r24, 0x05	; 5
    1b22:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b26:	a1 c0       	rjmp	.+322    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1b28:	c1 15       	cp	r28, r1
    1b2a:	eb e0       	ldi	r30, 0x0B	; 11
    1b2c:	de 07       	cpc	r29, r30
    1b2e:	29 f4       	brne	.+10     	; 0x1b3a <usart_init_rs232+0xe8>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1b30:	61 e0       	ldi	r22, 0x01	; 1
    1b32:	86 e0       	ldi	r24, 0x06	; 6
    1b34:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b38:	98 c0       	rjmp	.+304    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1b3a:	c0 34       	cpi	r28, 0x40	; 64
    1b3c:	f8 e0       	ldi	r31, 0x08	; 8
    1b3e:	df 07       	cpc	r29, r31
    1b40:	29 f4       	brne	.+10     	; 0x1b4c <usart_init_rs232+0xfa>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1b42:	62 e0       	ldi	r22, 0x02	; 2
    1b44:	83 e0       	ldi	r24, 0x03	; 3
    1b46:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b4a:	8f c0       	rjmp	.+286    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1b4c:	c0 34       	cpi	r28, 0x40	; 64
    1b4e:	89 e0       	ldi	r24, 0x09	; 9
    1b50:	d8 07       	cpc	r29, r24
    1b52:	29 f4       	brne	.+10     	; 0x1b5e <usart_init_rs232+0x10c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1b54:	62 e0       	ldi	r22, 0x02	; 2
    1b56:	84 e0       	ldi	r24, 0x04	; 4
    1b58:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b5c:	86 c0       	rjmp	.+268    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1b5e:	c0 34       	cpi	r28, 0x40	; 64
    1b60:	ea e0       	ldi	r30, 0x0A	; 10
    1b62:	de 07       	cpc	r29, r30
    1b64:	29 f4       	brne	.+10     	; 0x1b70 <usart_init_rs232+0x11e>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1b66:	62 e0       	ldi	r22, 0x02	; 2
    1b68:	85 e0       	ldi	r24, 0x05	; 5
    1b6a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b6e:	7d c0       	rjmp	.+250    	; 0x1c6a <usart_init_rs232+0x218>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1b70:	c0 39       	cpi	r28, 0x90	; 144
    1b72:	f8 e0       	ldi	r31, 0x08	; 8
    1b74:	df 07       	cpc	r29, r31
    1b76:	29 f4       	brne	.+10     	; 0x1b82 <usart_init_rs232+0x130>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1b78:	64 e0       	ldi	r22, 0x04	; 4
    1b7a:	83 e0       	ldi	r24, 0x03	; 3
    1b7c:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b80:	74 c0       	rjmp	.+232    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1b82:	c0 39       	cpi	r28, 0x90	; 144
    1b84:	89 e0       	ldi	r24, 0x09	; 9
    1b86:	d8 07       	cpc	r29, r24
    1b88:	29 f4       	brne	.+10     	; 0x1b94 <usart_init_rs232+0x142>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1b8a:	64 e0       	ldi	r22, 0x04	; 4
    1b8c:	84 e0       	ldi	r24, 0x04	; 4
    1b8e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1b92:	6b c0       	rjmp	.+214    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1b94:	c0 39       	cpi	r28, 0x90	; 144
    1b96:	ea e0       	ldi	r30, 0x0A	; 10
    1b98:	de 07       	cpc	r29, r30
    1b9a:	29 f4       	brne	.+10     	; 0x1ba6 <usart_init_rs232+0x154>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1b9c:	64 e0       	ldi	r22, 0x04	; 4
    1b9e:	85 e0       	ldi	r24, 0x05	; 5
    1ba0:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ba4:	62 c0       	rjmp	.+196    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1ba6:	c0 39       	cpi	r28, 0x90	; 144
    1ba8:	fb e0       	ldi	r31, 0x0B	; 11
    1baa:	df 07       	cpc	r29, r31
    1bac:	29 f4       	brne	.+10     	; 0x1bb8 <usart_init_rs232+0x166>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1bae:	64 e0       	ldi	r22, 0x04	; 4
    1bb0:	86 e0       	ldi	r24, 0x06	; 6
    1bb2:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1bb6:	59 c0       	rjmp	.+178    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1bb8:	c0 3c       	cpi	r28, 0xC0	; 192
    1bba:	88 e0       	ldi	r24, 0x08	; 8
    1bbc:	d8 07       	cpc	r29, r24
    1bbe:	29 f4       	brne	.+10     	; 0x1bca <usart_init_rs232+0x178>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1bc0:	68 e0       	ldi	r22, 0x08	; 8
    1bc2:	83 e0       	ldi	r24, 0x03	; 3
    1bc4:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1bc8:	50 c0       	rjmp	.+160    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1bca:	c0 3c       	cpi	r28, 0xC0	; 192
    1bcc:	e9 e0       	ldi	r30, 0x09	; 9
    1bce:	de 07       	cpc	r29, r30
    1bd0:	29 f4       	brne	.+10     	; 0x1bdc <usart_init_rs232+0x18a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1bd2:	68 e0       	ldi	r22, 0x08	; 8
    1bd4:	84 e0       	ldi	r24, 0x04	; 4
    1bd6:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1bda:	47 c0       	rjmp	.+142    	; 0x1c6a <usart_init_rs232+0x218>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1bdc:	c0 3a       	cpi	r28, 0xA0	; 160
    1bde:	f8 e0       	ldi	r31, 0x08	; 8
    1be0:	df 07       	cpc	r29, r31
    1be2:	29 f4       	brne	.+10     	; 0x1bee <usart_init_rs232+0x19c>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1be4:	60 e1       	ldi	r22, 0x10	; 16
    1be6:	83 e0       	ldi	r24, 0x03	; 3
    1be8:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1bec:	3e c0       	rjmp	.+124    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1bee:	c0 3a       	cpi	r28, 0xA0	; 160
    1bf0:	89 e0       	ldi	r24, 0x09	; 9
    1bf2:	d8 07       	cpc	r29, r24
    1bf4:	29 f4       	brne	.+10     	; 0x1c00 <usart_init_rs232+0x1ae>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1bf6:	60 e1       	ldi	r22, 0x10	; 16
    1bf8:	84 e0       	ldi	r24, 0x04	; 4
    1bfa:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1bfe:	35 c0       	rjmp	.+106    	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1c00:	c0 3a       	cpi	r28, 0xA0	; 160
    1c02:	ea e0       	ldi	r30, 0x0A	; 10
    1c04:	de 07       	cpc	r29, r30
    1c06:	29 f4       	brne	.+10     	; 0x1c12 <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1c08:	60 e1       	ldi	r22, 0x10	; 16
    1c0a:	85 e0       	ldi	r24, 0x05	; 5
    1c0c:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c10:	2c c0       	rjmp	.+88     	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1c12:	c0 3a       	cpi	r28, 0xA0	; 160
    1c14:	fb e0       	ldi	r31, 0x0B	; 11
    1c16:	df 07       	cpc	r29, r31
    1c18:	29 f4       	brne	.+10     	; 0x1c24 <usart_init_rs232+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1c1a:	60 e1       	ldi	r22, 0x10	; 16
    1c1c:	86 e0       	ldi	r24, 0x06	; 6
    1c1e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c22:	23 c0       	rjmp	.+70     	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1c24:	c0 3b       	cpi	r28, 0xB0	; 176
    1c26:	88 e0       	ldi	r24, 0x08	; 8
    1c28:	d8 07       	cpc	r29, r24
    1c2a:	29 f4       	brne	.+10     	; 0x1c36 <usart_init_rs232+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1c2c:	60 e2       	ldi	r22, 0x20	; 32
    1c2e:	83 e0       	ldi	r24, 0x03	; 3
    1c30:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c34:	1a c0       	rjmp	.+52     	; 0x1c6a <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1c36:	c0 3b       	cpi	r28, 0xB0	; 176
    1c38:	e9 e0       	ldi	r30, 0x09	; 9
    1c3a:	de 07       	cpc	r29, r30
    1c3c:	29 f4       	brne	.+10     	; 0x1c48 <usart_init_rs232+0x1f6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1c3e:	60 e2       	ldi	r22, 0x20	; 32
    1c40:	84 e0       	ldi	r24, 0x04	; 4
    1c42:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c46:	11 c0       	rjmp	.+34     	; 0x1c6a <usart_init_rs232+0x218>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1c48:	c0 38       	cpi	r28, 0x80	; 128
    1c4a:	f4 e0       	ldi	r31, 0x04	; 4
    1c4c:	df 07       	cpc	r29, r31
    1c4e:	29 f4       	brne	.+10     	; 0x1c5a <usart_init_rs232+0x208>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1c50:	60 e4       	ldi	r22, 0x40	; 64
    1c52:	83 e0       	ldi	r24, 0x03	; 3
    1c54:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1c58:	08 c0       	rjmp	.+16     	; 0x1c6a <usart_init_rs232+0x218>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1c5a:	c0 3a       	cpi	r28, 0xA0	; 160
    1c5c:	84 e0       	ldi	r24, 0x04	; 4
    1c5e:	d8 07       	cpc	r29, r24
    1c60:	21 f4       	brne	.+8      	; 0x1c6a <usart_init_rs232+0x218>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1c62:	60 e4       	ldi	r22, 0x40	; 64
    1c64:	85 e0       	ldi	r24, 0x05	; 5
    1c66:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1c6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c6c:	8f 73       	andi	r24, 0x3F	; 63
    1c6e:	8d 83       	std	Y+5, r24	; 0x05
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    1c70:	f8 01       	movw	r30, r16
    1c72:	95 81       	ldd	r25, Z+5	; 0x05
    1c74:	84 81       	ldd	r24, Z+4	; 0x04
    1c76:	89 2b       	or	r24, r25
    1c78:	96 81       	ldd	r25, Z+6	; 0x06
    1c7a:	91 11       	cpse	r25, r1
    1c7c:	98 e0       	ldi	r25, 0x08	; 8
    1c7e:	89 2b       	or	r24, r25
    1c80:	8d 83       	std	Y+5, r24	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1c82:	f8 01       	movw	r30, r16
    1c84:	40 81       	ld	r20, Z
    1c86:	51 81       	ldd	r21, Z+1	; 0x01
    1c88:	62 81       	ldd	r22, Z+2	; 0x02
    1c8a:	73 81       	ldd	r23, Z+3	; 0x03
    1c8c:	00 e8       	ldi	r16, 0x80	; 128
    1c8e:	14 e8       	ldi	r17, 0x84	; 132
    1c90:	2e e1       	ldi	r18, 0x1E	; 30
    1c92:	30 e0       	ldi	r19, 0x00	; 0
    1c94:	ce 01       	movw	r24, r28
    1c96:	ca dd       	rcall	.-1132   	; 0x182c <usart_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1c98:	9c 81       	ldd	r25, Y+4	; 0x04
    1c9a:	98 60       	ori	r25, 0x08	; 8
    1c9c:	9c 83       	std	Y+4, r25	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1c9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1ca0:	90 61       	ori	r25, 0x10	; 16
    1ca2:	9c 83       	std	Y+4, r25	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    1ca4:	df 91       	pop	r29
    1ca6:	cf 91       	pop	r28
    1ca8:	1f 91       	pop	r17
    1caa:	0f 91       	pop	r16
    1cac:	08 95       	ret

00001cae <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1cae:	cf 92       	push	r12
    1cb0:	df 92       	push	r13
    1cb2:	ef 92       	push	r14
    1cb4:	ff 92       	push	r15
    1cb6:	0f 93       	push	r16
    1cb8:	1f 93       	push	r17
    1cba:	cf 93       	push	r28
    1cbc:	df 93       	push	r29
    1cbe:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1cc0:	d9 01       	movw	r26, r18
    1cc2:	c8 01       	movw	r24, r16
    1cc4:	b6 95       	lsr	r27
    1cc6:	a7 95       	ror	r26
    1cc8:	97 95       	ror	r25
    1cca:	87 95       	ror	r24
    1ccc:	48 17       	cp	r20, r24
    1cce:	59 07       	cpc	r21, r25
    1cd0:	6a 07       	cpc	r22, r26
    1cd2:	7b 07       	cpc	r23, r27
    1cd4:	78 f4       	brcc	.+30     	; 0x1cf4 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1cd6:	6a 01       	movw	r12, r20
    1cd8:	7b 01       	movw	r14, r22
    1cda:	cc 0c       	add	r12, r12
    1cdc:	dd 1c       	adc	r13, r13
    1cde:	ee 1c       	adc	r14, r14
    1ce0:	ff 1c       	adc	r15, r15
    1ce2:	c9 01       	movw	r24, r18
    1ce4:	b8 01       	movw	r22, r16
    1ce6:	a7 01       	movw	r20, r14
    1ce8:	96 01       	movw	r18, r12
    1cea:	0e 94 67 1e 	call	0x3cce	; 0x3cce <__udivmodsi4>
    1cee:	21 50       	subi	r18, 0x01	; 1
    1cf0:	31 09       	sbc	r19, r1
    1cf2:	02 c0       	rjmp	.+4      	; 0x1cf8 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1cf4:	20 e0       	ldi	r18, 0x00	; 0
    1cf6:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1cf8:	83 2f       	mov	r24, r19
    1cfa:	8f 70       	andi	r24, 0x0F	; 15
    1cfc:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1cfe:	2e 83       	std	Y+6, r18	; 0x06
}
    1d00:	df 91       	pop	r29
    1d02:	cf 91       	pop	r28
    1d04:	1f 91       	pop	r17
    1d06:	0f 91       	pop	r16
    1d08:	ff 90       	pop	r15
    1d0a:	ef 90       	pop	r14
    1d0c:	df 90       	pop	r13
    1d0e:	cf 90       	pop	r12
    1d10:	08 95       	ret

00001d12 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1d12:	df 92       	push	r13
    1d14:	ef 92       	push	r14
    1d16:	ff 92       	push	r15
    1d18:	0f 93       	push	r16
    1d1a:	1f 93       	push	r17
    1d1c:	cf 93       	push	r28
    1d1e:	df 93       	push	r29
    1d20:	1f 92       	push	r1
    1d22:	cd b7       	in	r28, 0x3d	; 61
    1d24:	de b7       	in	r29, 0x3e	; 62
    1d26:	7c 01       	movw	r14, r24
    1d28:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1d2a:	00 97       	sbiw	r24, 0x00	; 0
    1d2c:	09 f4       	brne	.+2      	; 0x1d30 <usart_init_spi+0x1e>
    1d2e:	cf c1       	rjmp	.+926    	; 0x20ce <usart_init_spi+0x3bc>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1d30:	80 3c       	cpi	r24, 0xC0	; 192
    1d32:	91 05       	cpc	r25, r1
    1d34:	29 f4       	brne	.+10     	; 0x1d40 <usart_init_spi+0x2e>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1d36:	60 e1       	ldi	r22, 0x10	; 16
    1d38:	80 e0       	ldi	r24, 0x00	; 0
    1d3a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1d3e:	c7 c1       	rjmp	.+910    	; 0x20ce <usart_init_spi+0x3bc>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1d40:	80 e8       	ldi	r24, 0x80	; 128
    1d42:	e8 16       	cp	r14, r24
    1d44:	81 e0       	ldi	r24, 0x01	; 1
    1d46:	f8 06       	cpc	r15, r24
    1d48:	29 f4       	brne	.+10     	; 0x1d54 <usart_init_spi+0x42>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1d4a:	62 e0       	ldi	r22, 0x02	; 2
    1d4c:	80 e0       	ldi	r24, 0x00	; 0
    1d4e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1d52:	bd c1       	rjmp	.+890    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1d54:	e1 14       	cp	r14, r1
    1d56:	e1 e0       	ldi	r30, 0x01	; 1
    1d58:	fe 06       	cpc	r15, r30
    1d5a:	29 f4       	brne	.+10     	; 0x1d66 <usart_init_spi+0x54>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1d5c:	61 e0       	ldi	r22, 0x01	; 1
    1d5e:	80 e0       	ldi	r24, 0x00	; 0
    1d60:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1d64:	b4 c1       	rjmp	.+872    	; 0x20ce <usart_init_spi+0x3bc>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1d66:	f0 e8       	ldi	r31, 0x80	; 128
    1d68:	ef 16       	cp	r14, r31
    1d6a:	f3 e0       	ldi	r31, 0x03	; 3
    1d6c:	ff 06       	cpc	r15, r31
    1d6e:	29 f4       	brne	.+10     	; 0x1d7a <usart_init_spi+0x68>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1d70:	61 e0       	ldi	r22, 0x01	; 1
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1d78:	aa c1       	rjmp	.+852    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1d7a:	30 e9       	ldi	r19, 0x90	; 144
    1d7c:	e3 16       	cp	r14, r19
    1d7e:	33 e0       	ldi	r19, 0x03	; 3
    1d80:	f3 06       	cpc	r15, r19
    1d82:	29 f4       	brne	.+10     	; 0x1d8e <usart_init_spi+0x7c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1d84:	61 e0       	ldi	r22, 0x01	; 1
    1d86:	82 e0       	ldi	r24, 0x02	; 2
    1d88:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1d8c:	a0 c1       	rjmp	.+832    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1d8e:	e1 14       	cp	r14, r1
    1d90:	82 e0       	ldi	r24, 0x02	; 2
    1d92:	f8 06       	cpc	r15, r24
    1d94:	29 f4       	brne	.+10     	; 0x1da0 <usart_init_spi+0x8e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1d96:	62 e0       	ldi	r22, 0x02	; 2
    1d98:	81 e0       	ldi	r24, 0x01	; 1
    1d9a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1d9e:	97 c1       	rjmp	.+814    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1da0:	e0 e4       	ldi	r30, 0x40	; 64
    1da2:	ee 16       	cp	r14, r30
    1da4:	e2 e0       	ldi	r30, 0x02	; 2
    1da6:	fe 06       	cpc	r15, r30
    1da8:	29 f4       	brne	.+10     	; 0x1db4 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1daa:	62 e0       	ldi	r22, 0x02	; 2
    1dac:	82 e0       	ldi	r24, 0x02	; 2
    1dae:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1db2:	8d c1       	rjmp	.+794    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1db4:	f0 e2       	ldi	r31, 0x20	; 32
    1db6:	ef 16       	cp	r14, r31
    1db8:	f3 e0       	ldi	r31, 0x03	; 3
    1dba:	ff 06       	cpc	r15, r31
    1dbc:	29 f4       	brne	.+10     	; 0x1dc8 <usart_init_spi+0xb6>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1dbe:	64 e0       	ldi	r22, 0x04	; 4
    1dc0:	82 e0       	ldi	r24, 0x02	; 2
    1dc2:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1dc6:	83 c1       	rjmp	.+774    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1dc8:	e1 14       	cp	r14, r1
    1dca:	38 e0       	ldi	r19, 0x08	; 8
    1dcc:	f3 06       	cpc	r15, r19
    1dce:	29 f4       	brne	.+10     	; 0x1dda <usart_init_spi+0xc8>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1dd0:	61 e0       	ldi	r22, 0x01	; 1
    1dd2:	83 e0       	ldi	r24, 0x03	; 3
    1dd4:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1dd8:	7a c1       	rjmp	.+756    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1dda:	e1 14       	cp	r14, r1
    1ddc:	89 e0       	ldi	r24, 0x09	; 9
    1dde:	f8 06       	cpc	r15, r24
    1de0:	29 f4       	brne	.+10     	; 0x1dec <usart_init_spi+0xda>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1de2:	61 e0       	ldi	r22, 0x01	; 1
    1de4:	84 e0       	ldi	r24, 0x04	; 4
    1de6:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1dea:	71 c1       	rjmp	.+738    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1dec:	e1 14       	cp	r14, r1
    1dee:	ea e0       	ldi	r30, 0x0A	; 10
    1df0:	fe 06       	cpc	r15, r30
    1df2:	29 f4       	brne	.+10     	; 0x1dfe <usart_init_spi+0xec>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1df4:	61 e0       	ldi	r22, 0x01	; 1
    1df6:	85 e0       	ldi	r24, 0x05	; 5
    1df8:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1dfc:	68 c1       	rjmp	.+720    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1dfe:	e1 14       	cp	r14, r1
    1e00:	fb e0       	ldi	r31, 0x0B	; 11
    1e02:	ff 06       	cpc	r15, r31
    1e04:	29 f4       	brne	.+10     	; 0x1e10 <usart_init_spi+0xfe>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1e06:	61 e0       	ldi	r22, 0x01	; 1
    1e08:	86 e0       	ldi	r24, 0x06	; 6
    1e0a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e0e:	5f c1       	rjmp	.+702    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1e10:	30 e4       	ldi	r19, 0x40	; 64
    1e12:	e3 16       	cp	r14, r19
    1e14:	38 e0       	ldi	r19, 0x08	; 8
    1e16:	f3 06       	cpc	r15, r19
    1e18:	29 f4       	brne	.+10     	; 0x1e24 <usart_init_spi+0x112>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1e1a:	62 e0       	ldi	r22, 0x02	; 2
    1e1c:	83 e0       	ldi	r24, 0x03	; 3
    1e1e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e22:	55 c1       	rjmp	.+682    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1e24:	80 e4       	ldi	r24, 0x40	; 64
    1e26:	e8 16       	cp	r14, r24
    1e28:	89 e0       	ldi	r24, 0x09	; 9
    1e2a:	f8 06       	cpc	r15, r24
    1e2c:	29 f4       	brne	.+10     	; 0x1e38 <usart_init_spi+0x126>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1e2e:	62 e0       	ldi	r22, 0x02	; 2
    1e30:	84 e0       	ldi	r24, 0x04	; 4
    1e32:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e36:	4b c1       	rjmp	.+662    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1e38:	e0 e4       	ldi	r30, 0x40	; 64
    1e3a:	ee 16       	cp	r14, r30
    1e3c:	ea e0       	ldi	r30, 0x0A	; 10
    1e3e:	fe 06       	cpc	r15, r30
    1e40:	29 f4       	brne	.+10     	; 0x1e4c <usart_init_spi+0x13a>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1e42:	62 e0       	ldi	r22, 0x02	; 2
    1e44:	85 e0       	ldi	r24, 0x05	; 5
    1e46:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e4a:	41 c1       	rjmp	.+642    	; 0x20ce <usart_init_spi+0x3bc>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1e4c:	f0 e9       	ldi	r31, 0x90	; 144
    1e4e:	ef 16       	cp	r14, r31
    1e50:	f8 e0       	ldi	r31, 0x08	; 8
    1e52:	ff 06       	cpc	r15, r31
    1e54:	29 f4       	brne	.+10     	; 0x1e60 <usart_init_spi+0x14e>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1e56:	64 e0       	ldi	r22, 0x04	; 4
    1e58:	83 e0       	ldi	r24, 0x03	; 3
    1e5a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e5e:	37 c1       	rjmp	.+622    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1e60:	30 e9       	ldi	r19, 0x90	; 144
    1e62:	e3 16       	cp	r14, r19
    1e64:	39 e0       	ldi	r19, 0x09	; 9
    1e66:	f3 06       	cpc	r15, r19
    1e68:	29 f4       	brne	.+10     	; 0x1e74 <usart_init_spi+0x162>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1e6a:	64 e0       	ldi	r22, 0x04	; 4
    1e6c:	84 e0       	ldi	r24, 0x04	; 4
    1e6e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e72:	2d c1       	rjmp	.+602    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1e74:	80 e9       	ldi	r24, 0x90	; 144
    1e76:	e8 16       	cp	r14, r24
    1e78:	8a e0       	ldi	r24, 0x0A	; 10
    1e7a:	f8 06       	cpc	r15, r24
    1e7c:	29 f4       	brne	.+10     	; 0x1e88 <usart_init_spi+0x176>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1e7e:	64 e0       	ldi	r22, 0x04	; 4
    1e80:	85 e0       	ldi	r24, 0x05	; 5
    1e82:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e86:	23 c1       	rjmp	.+582    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1e88:	e0 e9       	ldi	r30, 0x90	; 144
    1e8a:	ee 16       	cp	r14, r30
    1e8c:	eb e0       	ldi	r30, 0x0B	; 11
    1e8e:	fe 06       	cpc	r15, r30
    1e90:	29 f4       	brne	.+10     	; 0x1e9c <usart_init_spi+0x18a>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1e92:	64 e0       	ldi	r22, 0x04	; 4
    1e94:	86 e0       	ldi	r24, 0x06	; 6
    1e96:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1e9a:	19 c1       	rjmp	.+562    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1e9c:	f0 ec       	ldi	r31, 0xC0	; 192
    1e9e:	ef 16       	cp	r14, r31
    1ea0:	f8 e0       	ldi	r31, 0x08	; 8
    1ea2:	ff 06       	cpc	r15, r31
    1ea4:	29 f4       	brne	.+10     	; 0x1eb0 <usart_init_spi+0x19e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1ea6:	68 e0       	ldi	r22, 0x08	; 8
    1ea8:	83 e0       	ldi	r24, 0x03	; 3
    1eaa:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1eae:	0f c1       	rjmp	.+542    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1eb0:	30 ec       	ldi	r19, 0xC0	; 192
    1eb2:	e3 16       	cp	r14, r19
    1eb4:	39 e0       	ldi	r19, 0x09	; 9
    1eb6:	f3 06       	cpc	r15, r19
    1eb8:	29 f4       	brne	.+10     	; 0x1ec4 <usart_init_spi+0x1b2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1eba:	68 e0       	ldi	r22, 0x08	; 8
    1ebc:	84 e0       	ldi	r24, 0x04	; 4
    1ebe:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1ec2:	05 c1       	rjmp	.+522    	; 0x20ce <usart_init_spi+0x3bc>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1ec4:	80 ea       	ldi	r24, 0xA0	; 160
    1ec6:	e8 16       	cp	r14, r24
    1ec8:	88 e0       	ldi	r24, 0x08	; 8
    1eca:	f8 06       	cpc	r15, r24
    1ecc:	69 f4       	brne	.+26     	; 0x1ee8 <usart_init_spi+0x1d6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1ece:	60 e1       	ldi	r22, 0x10	; 16
    1ed0:	83 e0       	ldi	r24, 0x03	; 3
    1ed2:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1ed6:	e0 ea       	ldi	r30, 0xA0	; 160
    1ed8:	f8 e0       	ldi	r31, 0x08	; 8
    1eda:	84 81       	ldd	r24, Z+4	; 0x04
    1edc:	8f 7e       	andi	r24, 0xEF	; 239
    1ede:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1ee0:	f8 01       	movw	r30, r16
    1ee2:	24 81       	ldd	r18, Z+4	; 0x04
    1ee4:	22 50       	subi	r18, 0x02	; 2
    1ee6:	53 c0       	rjmp	.+166    	; 0x1f8e <usart_init_spi+0x27c>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1ee8:	f0 ea       	ldi	r31, 0xA0	; 160
    1eea:	ef 16       	cp	r14, r31
    1eec:	f9 e0       	ldi	r31, 0x09	; 9
    1eee:	ff 06       	cpc	r15, r31
    1ef0:	29 f4       	brne	.+10     	; 0x1efc <usart_init_spi+0x1ea>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1ef2:	60 e1       	ldi	r22, 0x10	; 16
    1ef4:	84 e0       	ldi	r24, 0x04	; 4
    1ef6:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1efa:	e9 c0       	rjmp	.+466    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1efc:	30 ea       	ldi	r19, 0xA0	; 160
    1efe:	e3 16       	cp	r14, r19
    1f00:	3a e0       	ldi	r19, 0x0A	; 10
    1f02:	f3 06       	cpc	r15, r19
    1f04:	29 f4       	brne	.+10     	; 0x1f10 <usart_init_spi+0x1fe>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1f06:	60 e1       	ldi	r22, 0x10	; 16
    1f08:	85 e0       	ldi	r24, 0x05	; 5
    1f0a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f0e:	df c0       	rjmp	.+446    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1f10:	80 ea       	ldi	r24, 0xA0	; 160
    1f12:	e8 16       	cp	r14, r24
    1f14:	8b e0       	ldi	r24, 0x0B	; 11
    1f16:	f8 06       	cpc	r15, r24
    1f18:	29 f4       	brne	.+10     	; 0x1f24 <usart_init_spi+0x212>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1f1a:	60 e1       	ldi	r22, 0x10	; 16
    1f1c:	86 e0       	ldi	r24, 0x06	; 6
    1f1e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f22:	d5 c0       	rjmp	.+426    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1f24:	e0 eb       	ldi	r30, 0xB0	; 176
    1f26:	ee 16       	cp	r14, r30
    1f28:	e8 e0       	ldi	r30, 0x08	; 8
    1f2a:	fe 06       	cpc	r15, r30
    1f2c:	29 f4       	brne	.+10     	; 0x1f38 <usart_init_spi+0x226>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1f2e:	60 e2       	ldi	r22, 0x20	; 32
    1f30:	83 e0       	ldi	r24, 0x03	; 3
    1f32:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f36:	cb c0       	rjmp	.+406    	; 0x20ce <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1f38:	f0 eb       	ldi	r31, 0xB0	; 176
    1f3a:	ef 16       	cp	r14, r31
    1f3c:	f9 e0       	ldi	r31, 0x09	; 9
    1f3e:	ff 06       	cpc	r15, r31
    1f40:	29 f4       	brne	.+10     	; 0x1f4c <usart_init_spi+0x23a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1f42:	60 e2       	ldi	r22, 0x20	; 32
    1f44:	84 e0       	ldi	r24, 0x04	; 4
    1f46:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f4a:	c1 c0       	rjmp	.+386    	; 0x20ce <usart_init_spi+0x3bc>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1f4c:	30 e8       	ldi	r19, 0x80	; 128
    1f4e:	e3 16       	cp	r14, r19
    1f50:	34 e0       	ldi	r19, 0x04	; 4
    1f52:	f3 06       	cpc	r15, r19
    1f54:	29 f4       	brne	.+10     	; 0x1f60 <usart_init_spi+0x24e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1f56:	60 e4       	ldi	r22, 0x40	; 64
    1f58:	83 e0       	ldi	r24, 0x03	; 3
    1f5a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f5e:	b7 c0       	rjmp	.+366    	; 0x20ce <usart_init_spi+0x3bc>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1f60:	80 ea       	ldi	r24, 0xA0	; 160
    1f62:	e8 16       	cp	r14, r24
    1f64:	84 e0       	ldi	r24, 0x04	; 4
    1f66:	f8 06       	cpc	r15, r24
    1f68:	29 f4       	brne	.+10     	; 0x1f74 <usart_init_spi+0x262>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1f6a:	60 e4       	ldi	r22, 0x40	; 64
    1f6c:	85 e0       	ldi	r24, 0x05	; 5
    1f6e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <sysclk_enable_module>
    1f72:	ad c0       	rjmp	.+346    	; 0x20ce <usart_init_spi+0x3bc>
    1f74:	f7 01       	movw	r30, r14
    1f76:	84 81       	ldd	r24, Z+4	; 0x04
    1f78:	8f 7e       	andi	r24, 0xEF	; 239
    1f7a:	84 83       	std	Z+4, r24	; 0x04
    1f7c:	fb 01       	movw	r30, r22
    1f7e:	24 81       	ldd	r18, Z+4	; 0x04
    1f80:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1f82:	c7 01       	movw	r24, r14
    1f84:	f0 ea       	ldi	r31, 0xA0	; 160
    1f86:	ef 16       	cp	r14, r31
    1f88:	f8 e0       	ldi	r31, 0x08	; 8
    1f8a:	ff 06       	cpc	r15, r31
    1f8c:	49 f4       	brne	.+18     	; 0x1fa0 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    1f8e:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    1f92:	84 fd       	sbrc	r24, 4
    1f94:	a5 c0       	rjmp	.+330    	; 0x20e0 <usart_init_spi+0x3ce>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    1f96:	0f 2e       	mov	r0, r31
    1f98:	f1 e1       	ldi	r31, 0x11	; 17
    1f9a:	df 2e       	mov	r13, r31
    1f9c:	f0 2d       	mov	r31, r0
    1f9e:	a4 c0       	rjmp	.+328    	; 0x20e8 <usart_init_spi+0x3d6>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1fa0:	80 3b       	cpi	r24, 0xB0	; 176
    1fa2:	38 e0       	ldi	r19, 0x08	; 8
    1fa4:	93 07       	cpc	r25, r19
    1fa6:	91 f0       	breq	.+36     	; 0x1fcc <usart_init_spi+0x2ba>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    1fa8:	80 3a       	cpi	r24, 0xA0	; 160
    1faa:	e9 e0       	ldi	r30, 0x09	; 9
    1fac:	9e 07       	cpc	r25, r30
    1fae:	49 f4       	brne	.+18     	; 0x1fc2 <usart_init_spi+0x2b0>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1fb0:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    1fb4:	34 fd       	sbrc	r19, 4
    1fb6:	9b c0       	rjmp	.+310    	; 0x20ee <usart_init_spi+0x3dc>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    1fb8:	0f 2e       	mov	r0, r31
    1fba:	f9 e1       	ldi	r31, 0x19	; 25
    1fbc:	df 2e       	mov	r13, r31
    1fbe:	f0 2d       	mov	r31, r0
    1fc0:	16 c0       	rjmp	.+44     	; 0x1fee <usart_init_spi+0x2dc>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    1fc2:	80 3b       	cpi	r24, 0xB0	; 176
    1fc4:	f9 e0       	ldi	r31, 0x09	; 9
    1fc6:	9f 07       	cpc	r25, r31
    1fc8:	f1 f0       	breq	.+60     	; 0x2006 <usart_init_spi+0x2f4>
    1fca:	04 c0       	rjmp	.+8      	; 0x1fd4 <usart_init_spi+0x2c2>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1fcc:	0f 2e       	mov	r0, r31
    1fce:	f5 e1       	ldi	r31, 0x15	; 21
    1fd0:	df 2e       	mov	r13, r31
    1fd2:	f0 2d       	mov	r31, r0
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    1fd4:	80 3a       	cpi	r24, 0xA0	; 160
    1fd6:	3a e0       	ldi	r19, 0x0A	; 10
    1fd8:	93 07       	cpc	r25, r19
    1fda:	49 f4       	brne	.+18     	; 0x1fee <usart_init_spi+0x2dc>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    1fdc:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    1fe0:	84 fd       	sbrc	r24, 4
    1fe2:	8a c0       	rjmp	.+276    	; 0x20f8 <usart_init_spi+0x3e6>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    1fe4:	0f 2e       	mov	r0, r31
    1fe6:	f1 e2       	ldi	r31, 0x21	; 33
    1fe8:	df 2e       	mov	r13, r31
    1fea:	f0 2d       	mov	r31, r0
    1fec:	15 c0       	rjmp	.+42     	; 0x2018 <usart_init_spi+0x306>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    1fee:	80 3a       	cpi	r24, 0xA0	; 160
    1ff0:	9b 40       	sbci	r25, 0x0B	; 11
    1ff2:	91 f4       	brne	.+36     	; 0x2018 <usart_init_spi+0x306>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    1ff4:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    1ff8:	84 fd       	sbrc	r24, 4
    1ffa:	0a c0       	rjmp	.+20     	; 0x2010 <usart_init_spi+0x2fe>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    1ffc:	0f 2e       	mov	r0, r31
    1ffe:	f9 e2       	ldi	r31, 0x29	; 41
    2000:	df 2e       	mov	r13, r31
    2002:	f0 2d       	mov	r31, r0
    2004:	09 c0       	rjmp	.+18     	; 0x2018 <usart_init_spi+0x306>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    2006:	0f 2e       	mov	r0, r31
    2008:	fd e1       	ldi	r31, 0x1D	; 29
    200a:	df 2e       	mov	r13, r31
    200c:	f0 2d       	mov	r31, r0
    200e:	04 c0       	rjmp	.+8      	; 0x2018 <usart_init_spi+0x306>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    2010:	0f 2e       	mov	r0, r31
    2012:	fd e2       	ldi	r31, 0x2D	; 45
    2014:	df 2e       	mov	r13, r31
    2016:	f0 2d       	mov	r31, r0
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2018:	ed 2d       	mov	r30, r13
    201a:	e6 95       	lsr	r30
    201c:	e6 95       	lsr	r30
    201e:	e6 95       	lsr	r30
    2020:	30 e2       	ldi	r19, 0x20	; 32
    2022:	e3 9f       	mul	r30, r19
    2024:	f0 01       	movw	r30, r0
    2026:	11 24       	eor	r1, r1
    2028:	fa 5f       	subi	r31, 0xFA	; 250
    202a:	3d 2d       	mov	r19, r13
    202c:	37 70       	andi	r19, 0x07	; 7
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    202e:	81 e0       	ldi	r24, 0x01	; 1
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	03 2e       	mov	r0, r19
    2034:	02 c0       	rjmp	.+4      	; 0x203a <usart_init_spi+0x328>
    2036:	88 0f       	add	r24, r24
    2038:	99 1f       	adc	r25, r25
    203a:	0a 94       	dec	r0
    203c:	e2 f7       	brpl	.-8      	; 0x2036 <usart_init_spi+0x324>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    203e:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    2040:	22 30       	cpi	r18, 0x02	; 2
    2042:	10 f0       	brcs	.+4      	; 0x2048 <usart_init_spi+0x336>
    2044:	40 e0       	ldi	r20, 0x00	; 0
    2046:	01 c0       	rjmp	.+2      	; 0x204a <usart_init_spi+0x338>
    2048:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    204a:	df 01       	movw	r26, r30
    204c:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    204e:	a3 0f       	add	r26, r19
    2050:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    2052:	9f b7       	in	r25, 0x3f	; 63
    2054:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    2056:	f8 94       	cli
	return flags;
    2058:	39 81       	ldd	r19, Y+1	; 0x01
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    205a:	2c 91       	ld	r18, X
    205c:	27 70       	andi	r18, 0x07	; 7
    205e:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    2060:	9c 91       	ld	r25, X
    2062:	94 2b       	or	r25, r20
    2064:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2066:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2068:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    206a:	f7 01       	movw	r30, r14
    206c:	85 81       	ldd	r24, Z+5	; 0x05
    206e:	80 6c       	ori	r24, 0xC0	; 192
    2070:	85 83       	std	Z+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    2072:	f8 01       	movw	r30, r16
    2074:	84 81       	ldd	r24, Z+4	; 0x04
    2076:	8d 7f       	andi	r24, 0xFD	; 253
    2078:	81 30       	cpi	r24, 0x01	; 1
    207a:	29 f4       	brne	.+10     	; 0x2086 <usart_init_spi+0x374>
		usart->CTRLC |= USART_UCPHA_bm;
    207c:	f7 01       	movw	r30, r14
    207e:	85 81       	ldd	r24, Z+5	; 0x05
    2080:	82 60       	ori	r24, 0x02	; 2
    2082:	85 83       	std	Z+5, r24	; 0x05
    2084:	04 c0       	rjmp	.+8      	; 0x208e <usart_init_spi+0x37c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    2086:	f7 01       	movw	r30, r14
    2088:	85 81       	ldd	r24, Z+5	; 0x05
    208a:	8d 7f       	andi	r24, 0xFD	; 253
    208c:	85 83       	std	Z+5, r24	; 0x05
	}
	if (opt->data_order) {
    208e:	f8 01       	movw	r30, r16
    2090:	85 81       	ldd	r24, Z+5	; 0x05
    2092:	88 23       	and	r24, r24
    2094:	29 f0       	breq	.+10     	; 0x20a0 <usart_init_spi+0x38e>
		(usart)->CTRLC |= USART_DORD_bm;
    2096:	f7 01       	movw	r30, r14
    2098:	85 81       	ldd	r24, Z+5	; 0x05
    209a:	84 60       	ori	r24, 0x04	; 4
    209c:	85 83       	std	Z+5, r24	; 0x05
    209e:	04 c0       	rjmp	.+8      	; 0x20a8 <usart_init_spi+0x396>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    20a0:	f7 01       	movw	r30, r14
    20a2:	85 81       	ldd	r24, Z+5	; 0x05
    20a4:	8b 7f       	andi	r24, 0xFB	; 251
    20a6:	85 83       	std	Z+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    20a8:	f8 01       	movw	r30, r16
    20aa:	40 81       	ld	r20, Z
    20ac:	51 81       	ldd	r21, Z+1	; 0x01
    20ae:	62 81       	ldd	r22, Z+2	; 0x02
    20b0:	73 81       	ldd	r23, Z+3	; 0x03
    20b2:	00 e8       	ldi	r16, 0x80	; 128
    20b4:	14 e8       	ldi	r17, 0x84	; 132
    20b6:	2e e1       	ldi	r18, 0x1E	; 30
    20b8:	30 e0       	ldi	r19, 0x00	; 0
    20ba:	c7 01       	movw	r24, r14
    20bc:	f8 dd       	rcall	.-1040   	; 0x1cae <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    20be:	f7 01       	movw	r30, r14
    20c0:	84 81       	ldd	r24, Z+4	; 0x04
    20c2:	88 60       	ori	r24, 0x08	; 8
    20c4:	84 83       	std	Z+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    20c6:	84 81       	ldd	r24, Z+4	; 0x04
    20c8:	80 61       	ori	r24, 0x10	; 16
    20ca:	84 83       	std	Z+4, r24	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    20cc:	1a c0       	rjmp	.+52     	; 0x2102 <usart_init_spi+0x3f0>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    20ce:	f7 01       	movw	r30, r14
    20d0:	84 81       	ldd	r24, Z+4	; 0x04
    20d2:	8f 7e       	andi	r24, 0xEF	; 239
    20d4:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    20d6:	f8 01       	movw	r30, r16
    20d8:	24 81       	ldd	r18, Z+4	; 0x04
    20da:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    20dc:	c7 01       	movw	r24, r14
    20de:	60 cf       	rjmp	.-320    	; 0x1fa0 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    20e0:	0f 2e       	mov	r0, r31
    20e2:	f5 e1       	ldi	r31, 0x15	; 21
    20e4:	df 2e       	mov	r13, r31
    20e6:	f0 2d       	mov	r31, r0
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    20e8:	80 ea       	ldi	r24, 0xA0	; 160
    20ea:	98 e0       	ldi	r25, 0x08	; 8
    20ec:	6a cf       	rjmp	.-300    	; 0x1fc2 <usart_init_spi+0x2b0>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    20ee:	0f 2e       	mov	r0, r31
    20f0:	fd e1       	ldi	r31, 0x1D	; 29
    20f2:	df 2e       	mov	r13, r31
    20f4:	f0 2d       	mov	r31, r0
    20f6:	7b cf       	rjmp	.-266    	; 0x1fee <usart_init_spi+0x2dc>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    20f8:	0f 2e       	mov	r0, r31
    20fa:	f5 e2       	ldi	r31, 0x25	; 37
    20fc:	df 2e       	mov	r13, r31
    20fe:	f0 2d       	mov	r31, r0
    2100:	8b cf       	rjmp	.-234    	; 0x2018 <usart_init_spi+0x306>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    2102:	0f 90       	pop	r0
    2104:	df 91       	pop	r29
    2106:	cf 91       	pop	r28
    2108:	1f 91       	pop	r17
    210a:	0f 91       	pop	r16
    210c:	ff 90       	pop	r15
    210e:	ef 90       	pop	r14
    2110:	df 90       	pop	r13
    2112:	08 95       	ret

00002114 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2114:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2116:	03 96       	adiw	r24, 0x03	; 3
    2118:	81 83       	std	Z+1, r24	; 0x01
    211a:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    211c:	2f ef       	ldi	r18, 0xFF	; 255
    211e:	3f ef       	ldi	r19, 0xFF	; 255
    2120:	23 83       	std	Z+3, r18	; 0x03
    2122:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2124:	85 83       	std	Z+5, r24	; 0x05
    2126:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2128:	87 83       	std	Z+7, r24	; 0x07
    212a:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    212c:	10 82       	st	Z, r1
    212e:	08 95       	ret

00002130 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    2130:	fc 01       	movw	r30, r24
    2132:	10 86       	std	Z+8, r1	; 0x08
    2134:	11 86       	std	Z+9, r1	; 0x09
    2136:	08 95       	ret

00002138 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2138:	cf 93       	push	r28
    213a:	df 93       	push	r29
    213c:	9c 01       	movw	r18, r24
    213e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2140:	dc 01       	movw	r26, r24
    2142:	11 96       	adiw	r26, 0x01	; 1
    2144:	cd 91       	ld	r28, X+
    2146:	dc 91       	ld	r29, X
    2148:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    214a:	c2 83       	std	Z+2, r28	; 0x02
    214c:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    214e:	8c 81       	ldd	r24, Y+4	; 0x04
    2150:	9d 81       	ldd	r25, Y+5	; 0x05
    2152:	84 83       	std	Z+4, r24	; 0x04
    2154:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2156:	8c 81       	ldd	r24, Y+4	; 0x04
    2158:	9d 81       	ldd	r25, Y+5	; 0x05
    215a:	dc 01       	movw	r26, r24
    215c:	12 96       	adiw	r26, 0x02	; 2
    215e:	6d 93       	st	X+, r22
    2160:	7c 93       	st	X, r23
    2162:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    2164:	6c 83       	std	Y+4, r22	; 0x04
    2166:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2168:	20 87       	std	Z+8, r18	; 0x08
    216a:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    216c:	f9 01       	movw	r30, r18
    216e:	80 81       	ld	r24, Z
    2170:	8f 5f       	subi	r24, 0xFF	; 255
    2172:	80 83       	st	Z, r24
}
    2174:	df 91       	pop	r29
    2176:	cf 91       	pop	r28
    2178:	08 95       	ret

0000217a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    217a:	cf 93       	push	r28
    217c:	df 93       	push	r29
    217e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2180:	48 81       	ld	r20, Y
    2182:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2184:	4f 3f       	cpi	r20, 0xFF	; 255
    2186:	2f ef       	ldi	r18, 0xFF	; 255
    2188:	52 07       	cpc	r21, r18
    218a:	21 f4       	brne	.+8      	; 0x2194 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    218c:	fc 01       	movw	r30, r24
    218e:	a7 81       	ldd	r26, Z+7	; 0x07
    2190:	b0 85       	ldd	r27, Z+8	; 0x08
    2192:	0d c0       	rjmp	.+26     	; 0x21ae <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2194:	dc 01       	movw	r26, r24
    2196:	13 96       	adiw	r26, 0x03	; 3
    2198:	01 c0       	rjmp	.+2      	; 0x219c <vListInsert+0x22>
    219a:	df 01       	movw	r26, r30
    219c:	12 96       	adiw	r26, 0x02	; 2
    219e:	ed 91       	ld	r30, X+
    21a0:	fc 91       	ld	r31, X
    21a2:	13 97       	sbiw	r26, 0x03	; 3
    21a4:	20 81       	ld	r18, Z
    21a6:	31 81       	ldd	r19, Z+1	; 0x01
    21a8:	42 17       	cp	r20, r18
    21aa:	53 07       	cpc	r21, r19
    21ac:	b0 f7       	brcc	.-20     	; 0x219a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    21ae:	12 96       	adiw	r26, 0x02	; 2
    21b0:	ed 91       	ld	r30, X+
    21b2:	fc 91       	ld	r31, X
    21b4:	13 97       	sbiw	r26, 0x03	; 3
    21b6:	ea 83       	std	Y+2, r30	; 0x02
    21b8:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    21ba:	c4 83       	std	Z+4, r28	; 0x04
    21bc:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    21be:	ac 83       	std	Y+4, r26	; 0x04
    21c0:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    21c2:	12 96       	adiw	r26, 0x02	; 2
    21c4:	cd 93       	st	X+, r28
    21c6:	dc 93       	st	X, r29
    21c8:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    21ca:	88 87       	std	Y+8, r24	; 0x08
    21cc:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    21ce:	fc 01       	movw	r30, r24
    21d0:	20 81       	ld	r18, Z
    21d2:	2f 5f       	subi	r18, 0xFF	; 255
    21d4:	20 83       	st	Z, r18
}
    21d6:	df 91       	pop	r29
    21d8:	cf 91       	pop	r28
    21da:	08 95       	ret

000021dc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    21dc:	cf 93       	push	r28
    21de:	df 93       	push	r29
    21e0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    21e2:	a0 85       	ldd	r26, Z+8	; 0x08
    21e4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    21e6:	c2 81       	ldd	r28, Z+2	; 0x02
    21e8:	d3 81       	ldd	r29, Z+3	; 0x03
    21ea:	84 81       	ldd	r24, Z+4	; 0x04
    21ec:	95 81       	ldd	r25, Z+5	; 0x05
    21ee:	8c 83       	std	Y+4, r24	; 0x04
    21f0:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    21f2:	c4 81       	ldd	r28, Z+4	; 0x04
    21f4:	d5 81       	ldd	r29, Z+5	; 0x05
    21f6:	82 81       	ldd	r24, Z+2	; 0x02
    21f8:	93 81       	ldd	r25, Z+3	; 0x03
    21fa:	8a 83       	std	Y+2, r24	; 0x02
    21fc:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    21fe:	11 96       	adiw	r26, 0x01	; 1
    2200:	8d 91       	ld	r24, X+
    2202:	9c 91       	ld	r25, X
    2204:	12 97       	sbiw	r26, 0x02	; 2
    2206:	e8 17       	cp	r30, r24
    2208:	f9 07       	cpc	r31, r25
    220a:	31 f4       	brne	.+12     	; 0x2218 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    220c:	84 81       	ldd	r24, Z+4	; 0x04
    220e:	95 81       	ldd	r25, Z+5	; 0x05
    2210:	11 96       	adiw	r26, 0x01	; 1
    2212:	8d 93       	st	X+, r24
    2214:	9c 93       	st	X, r25
    2216:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2218:	10 86       	std	Z+8, r1	; 0x08
    221a:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    221c:	8c 91       	ld	r24, X
    221e:	81 50       	subi	r24, 0x01	; 1
    2220:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    2222:	8c 91       	ld	r24, X
}
    2224:	df 91       	pop	r29
    2226:	cf 91       	pop	r28
    2228:	08 95       	ret

0000222a <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    222a:	0f 93       	push	r16
    222c:	1f 93       	push	r17
    222e:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    2230:	71 e1       	ldi	r23, 0x11	; 17
    2232:	fc 01       	movw	r30, r24
    2234:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    2236:	31 97       	sbiw	r30, 0x01	; 1
    2238:	62 e2       	ldi	r22, 0x22	; 34
    223a:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    223c:	31 97       	sbiw	r30, 0x01	; 1
    223e:	23 e3       	ldi	r18, 0x33	; 51
    2240:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    2242:	01 2e       	mov	r0, r17
    2244:	00 0c       	add	r0, r0
    2246:	22 0b       	sbc	r18, r18
    2248:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    224a:	31 97       	sbiw	r30, 0x01	; 1
    224c:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    224e:	31 97       	sbiw	r30, 0x01	; 1
    2250:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2252:	31 97       	sbiw	r30, 0x01	; 1
    2254:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    2256:	31 97       	sbiw	r30, 0x01	; 1
    2258:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    225a:	31 97       	sbiw	r30, 0x01	; 1
    225c:	20 e8       	ldi	r18, 0x80	; 128
    225e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    2260:	31 97       	sbiw	r30, 0x01	; 1
    2262:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    2264:	31 97       	sbiw	r30, 0x01	; 1
    2266:	22 e0       	ldi	r18, 0x02	; 2
    2268:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    226a:	31 97       	sbiw	r30, 0x01	; 1
    226c:	23 e0       	ldi	r18, 0x03	; 3
    226e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    2270:	31 97       	sbiw	r30, 0x01	; 1
    2272:	24 e0       	ldi	r18, 0x04	; 4
    2274:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    2276:	31 97       	sbiw	r30, 0x01	; 1
    2278:	25 e0       	ldi	r18, 0x05	; 5
    227a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    227c:	31 97       	sbiw	r30, 0x01	; 1
    227e:	26 e0       	ldi	r18, 0x06	; 6
    2280:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    2282:	31 97       	sbiw	r30, 0x01	; 1
    2284:	27 e0       	ldi	r18, 0x07	; 7
    2286:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    2288:	31 97       	sbiw	r30, 0x01	; 1
    228a:	28 e0       	ldi	r18, 0x08	; 8
    228c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    228e:	31 97       	sbiw	r30, 0x01	; 1
    2290:	29 e0       	ldi	r18, 0x09	; 9
    2292:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    2294:	31 97       	sbiw	r30, 0x01	; 1
    2296:	20 e1       	ldi	r18, 0x10	; 16
    2298:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    229a:	31 97       	sbiw	r30, 0x01	; 1
    229c:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    229e:	31 97       	sbiw	r30, 0x01	; 1
    22a0:	22 e1       	ldi	r18, 0x12	; 18
    22a2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    22a4:	31 97       	sbiw	r30, 0x01	; 1
    22a6:	23 e1       	ldi	r18, 0x13	; 19
    22a8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    22aa:	31 97       	sbiw	r30, 0x01	; 1
    22ac:	24 e1       	ldi	r18, 0x14	; 20
    22ae:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    22b0:	31 97       	sbiw	r30, 0x01	; 1
    22b2:	25 e1       	ldi	r18, 0x15	; 21
    22b4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    22b6:	31 97       	sbiw	r30, 0x01	; 1
    22b8:	26 e1       	ldi	r18, 0x16	; 22
    22ba:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    22bc:	31 97       	sbiw	r30, 0x01	; 1
    22be:	27 e1       	ldi	r18, 0x17	; 23
    22c0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    22c2:	31 97       	sbiw	r30, 0x01	; 1
    22c4:	28 e1       	ldi	r18, 0x18	; 24
    22c6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    22c8:	31 97       	sbiw	r30, 0x01	; 1
    22ca:	29 e1       	ldi	r18, 0x19	; 25
    22cc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    22ce:	31 97       	sbiw	r30, 0x01	; 1
    22d0:	20 e2       	ldi	r18, 0x20	; 32
    22d2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    22d4:	31 97       	sbiw	r30, 0x01	; 1
    22d6:	21 e2       	ldi	r18, 0x21	; 33
    22d8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    22da:	31 97       	sbiw	r30, 0x01	; 1
    22dc:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    22de:	31 97       	sbiw	r30, 0x01	; 1
    22e0:	23 e2       	ldi	r18, 0x23	; 35
    22e2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    22e4:	31 97       	sbiw	r30, 0x01	; 1
    22e6:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    22e8:	31 97       	sbiw	r30, 0x01	; 1
    22ea:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    22ec:	31 97       	sbiw	r30, 0x01	; 1
    22ee:	26 e2       	ldi	r18, 0x26	; 38
    22f0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    22f2:	31 97       	sbiw	r30, 0x01	; 1
    22f4:	27 e2       	ldi	r18, 0x27	; 39
    22f6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    22f8:	31 97       	sbiw	r30, 0x01	; 1
    22fa:	28 e2       	ldi	r18, 0x28	; 40
    22fc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    22fe:	31 97       	sbiw	r30, 0x01	; 1
    2300:	29 e2       	ldi	r18, 0x29	; 41
    2302:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    2304:	31 97       	sbiw	r30, 0x01	; 1
    2306:	20 e3       	ldi	r18, 0x30	; 48
    2308:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    230a:	31 97       	sbiw	r30, 0x01	; 1
    230c:	21 e3       	ldi	r18, 0x31	; 49
    230e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    2310:	87 97       	sbiw	r24, 0x27	; 39
    2312:	1f 91       	pop	r17
    2314:	0f 91       	pop	r16
    2316:	08 95       	ret

00002318 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    2318:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    231a:	e0 e7       	ldi	r30, 0x70	; 112
    231c:	f0 e0       	ldi	r31, 0x00	; 0
    231e:	83 81       	ldd	r24, Z+3	; 0x03
    2320:	8a 7f       	andi	r24, 0xFA	; 250
    2322:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    2324:	e0 e0       	ldi	r30, 0x00	; 0
    2326:	f8 e0       	ldi	r31, 0x08	; 8
    2328:	80 e0       	ldi	r24, 0x00	; 0
    232a:	9a ef       	ldi	r25, 0xFA	; 250
    232c:	86 a3       	std	Z+38, r24	; 0x26
    232e:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    2330:	91 e0       	ldi	r25, 0x01	; 1
    2332:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    2334:	a0 ea       	ldi	r26, 0xA0	; 160
    2336:	b0 e0       	ldi	r27, 0x00	; 0
    2338:	12 96       	adiw	r26, 0x02	; 2
    233a:	8c 91       	ld	r24, X
    233c:	12 97       	sbiw	r26, 0x02	; 2
    233e:	81 60       	ori	r24, 0x01	; 1
    2340:	12 96       	adiw	r26, 0x02	; 2
    2342:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    2344:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    2346:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    2348:	a0 91 b4 22 	lds	r26, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    234c:	b0 91 b5 22 	lds	r27, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2350:	0d 90       	ld	r0, X+
    2352:	0d be       	out	0x3d, r0	; 61
    2354:	0d 90       	ld	r0, X+
    2356:	0e be       	out	0x3e, r0	; 62
    2358:	ff 91       	pop	r31
    235a:	ef 91       	pop	r30
    235c:	df 91       	pop	r29
    235e:	cf 91       	pop	r28
    2360:	bf 91       	pop	r27
    2362:	af 91       	pop	r26
    2364:	9f 91       	pop	r25
    2366:	8f 91       	pop	r24
    2368:	7f 91       	pop	r23
    236a:	6f 91       	pop	r22
    236c:	5f 91       	pop	r21
    236e:	4f 91       	pop	r20
    2370:	3f 91       	pop	r19
    2372:	2f 91       	pop	r18
    2374:	1f 91       	pop	r17
    2376:	0f 91       	pop	r16
    2378:	ff 90       	pop	r15
    237a:	ef 90       	pop	r14
    237c:	df 90       	pop	r13
    237e:	cf 90       	pop	r12
    2380:	bf 90       	pop	r11
    2382:	af 90       	pop	r10
    2384:	9f 90       	pop	r9
    2386:	8f 90       	pop	r8
    2388:	7f 90       	pop	r7
    238a:	6f 90       	pop	r6
    238c:	5f 90       	pop	r5
    238e:	4f 90       	pop	r4
    2390:	3f 90       	pop	r3
    2392:	2f 90       	pop	r2
    2394:	1f 90       	pop	r1
    2396:	0f 90       	pop	r0
    2398:	0f be       	out	0x3f, r0	; 63
    239a:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    239c:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    239e:	81 e0       	ldi	r24, 0x01	; 1
    23a0:	08 95       	ret

000023a2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    23a2:	0f 92       	push	r0
    23a4:	0f b6       	in	r0, 0x3f	; 63
    23a6:	f8 94       	cli
    23a8:	0f 92       	push	r0
    23aa:	1f 92       	push	r1
    23ac:	11 24       	eor	r1, r1
    23ae:	2f 92       	push	r2
    23b0:	3f 92       	push	r3
    23b2:	4f 92       	push	r4
    23b4:	5f 92       	push	r5
    23b6:	6f 92       	push	r6
    23b8:	7f 92       	push	r7
    23ba:	8f 92       	push	r8
    23bc:	9f 92       	push	r9
    23be:	af 92       	push	r10
    23c0:	bf 92       	push	r11
    23c2:	cf 92       	push	r12
    23c4:	df 92       	push	r13
    23c6:	ef 92       	push	r14
    23c8:	ff 92       	push	r15
    23ca:	0f 93       	push	r16
    23cc:	1f 93       	push	r17
    23ce:	2f 93       	push	r18
    23d0:	3f 93       	push	r19
    23d2:	4f 93       	push	r20
    23d4:	5f 93       	push	r21
    23d6:	6f 93       	push	r22
    23d8:	7f 93       	push	r23
    23da:	8f 93       	push	r24
    23dc:	9f 93       	push	r25
    23de:	af 93       	push	r26
    23e0:	bf 93       	push	r27
    23e2:	cf 93       	push	r28
    23e4:	df 93       	push	r29
    23e6:	ef 93       	push	r30
    23e8:	ff 93       	push	r31
    23ea:	a0 91 b4 22 	lds	r26, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    23ee:	b0 91 b5 22 	lds	r27, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    23f2:	0d b6       	in	r0, 0x3d	; 61
    23f4:	0d 92       	st	X+, r0
    23f6:	0e b6       	in	r0, 0x3e	; 62
    23f8:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    23fa:	f5 d5       	rcall	.+3050   	; 0x2fe6 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    23fc:	a0 91 b4 22 	lds	r26, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2400:	b0 91 b5 22 	lds	r27, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2404:	0d 90       	ld	r0, X+
    2406:	0d be       	out	0x3d, r0	; 61
    2408:	0d 90       	ld	r0, X+
    240a:	0e be       	out	0x3e, r0	; 62
    240c:	ff 91       	pop	r31
    240e:	ef 91       	pop	r30
    2410:	df 91       	pop	r29
    2412:	cf 91       	pop	r28
    2414:	bf 91       	pop	r27
    2416:	af 91       	pop	r26
    2418:	9f 91       	pop	r25
    241a:	8f 91       	pop	r24
    241c:	7f 91       	pop	r23
    241e:	6f 91       	pop	r22
    2420:	5f 91       	pop	r21
    2422:	4f 91       	pop	r20
    2424:	3f 91       	pop	r19
    2426:	2f 91       	pop	r18
    2428:	1f 91       	pop	r17
    242a:	0f 91       	pop	r16
    242c:	ff 90       	pop	r15
    242e:	ef 90       	pop	r14
    2430:	df 90       	pop	r13
    2432:	cf 90       	pop	r12
    2434:	bf 90       	pop	r11
    2436:	af 90       	pop	r10
    2438:	9f 90       	pop	r9
    243a:	8f 90       	pop	r8
    243c:	7f 90       	pop	r7
    243e:	6f 90       	pop	r6
    2440:	5f 90       	pop	r5
    2442:	4f 90       	pop	r4
    2444:	3f 90       	pop	r3
    2446:	2f 90       	pop	r2
    2448:	1f 90       	pop	r1
    244a:	0f 90       	pop	r0
    244c:	0f be       	out	0x3f, r0	; 63
    244e:	0f 90       	pop	r0

    asm volatile ( "ret" );
    2450:	08 95       	ret

00002452 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    2452:	0f 92       	push	r0
    2454:	0f b6       	in	r0, 0x3f	; 63
    2456:	f8 94       	cli
    2458:	0f 92       	push	r0
    245a:	1f 92       	push	r1
    245c:	11 24       	eor	r1, r1
    245e:	2f 92       	push	r2
    2460:	3f 92       	push	r3
    2462:	4f 92       	push	r4
    2464:	5f 92       	push	r5
    2466:	6f 92       	push	r6
    2468:	7f 92       	push	r7
    246a:	8f 92       	push	r8
    246c:	9f 92       	push	r9
    246e:	af 92       	push	r10
    2470:	bf 92       	push	r11
    2472:	cf 92       	push	r12
    2474:	df 92       	push	r13
    2476:	ef 92       	push	r14
    2478:	ff 92       	push	r15
    247a:	0f 93       	push	r16
    247c:	1f 93       	push	r17
    247e:	2f 93       	push	r18
    2480:	3f 93       	push	r19
    2482:	4f 93       	push	r20
    2484:	5f 93       	push	r21
    2486:	6f 93       	push	r22
    2488:	7f 93       	push	r23
    248a:	8f 93       	push	r24
    248c:	9f 93       	push	r25
    248e:	af 93       	push	r26
    2490:	bf 93       	push	r27
    2492:	cf 93       	push	r28
    2494:	df 93       	push	r29
    2496:	ef 93       	push	r30
    2498:	ff 93       	push	r31
    249a:	a0 91 b4 22 	lds	r26, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    249e:	b0 91 b5 22 	lds	r27, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    24a2:	0d b6       	in	r0, 0x3d	; 61
    24a4:	0d 92       	st	X+, r0
    24a6:	0e b6       	in	r0, 0x3e	; 62
    24a8:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    24aa:	68 d4       	rcall	.+2256   	; 0x2d7c <xTaskIncrementTick>
    24ac:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    24ae:	9b d5       	rcall	.+2870   	; 0x2fe6 <vTaskSwitchContext>
    24b0:	a0 91 b4 22 	lds	r26, 0x22B4	; 0x8022b4 <pxCurrentTCB>
        }
        portRESTORE_CONTEXT();
    24b4:	b0 91 b5 22 	lds	r27, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    24b8:	0d 90       	ld	r0, X+
    24ba:	0d be       	out	0x3d, r0	; 61
    24bc:	0d 90       	ld	r0, X+
    24be:	0e be       	out	0x3e, r0	; 62
    24c0:	ff 91       	pop	r31
    24c2:	ef 91       	pop	r30
    24c4:	df 91       	pop	r29
    24c6:	cf 91       	pop	r28
    24c8:	bf 91       	pop	r27
    24ca:	af 91       	pop	r26
    24cc:	9f 91       	pop	r25
    24ce:	8f 91       	pop	r24
    24d0:	7f 91       	pop	r23
    24d2:	6f 91       	pop	r22
    24d4:	5f 91       	pop	r21
    24d6:	4f 91       	pop	r20
    24d8:	3f 91       	pop	r19
    24da:	2f 91       	pop	r18
    24dc:	1f 91       	pop	r17
    24de:	0f 91       	pop	r16
    24e0:	ff 90       	pop	r15
    24e2:	ef 90       	pop	r14
    24e4:	df 90       	pop	r13
    24e6:	cf 90       	pop	r12
    24e8:	bf 90       	pop	r11
    24ea:	af 90       	pop	r10
    24ec:	9f 90       	pop	r9
    24ee:	8f 90       	pop	r8
    24f0:	7f 90       	pop	r7
    24f2:	6f 90       	pop	r6
    24f4:	5f 90       	pop	r5
    24f6:	4f 90       	pop	r4
    24f8:	3f 90       	pop	r3
    24fa:	2f 90       	pop	r2
    24fc:	1f 90       	pop	r1
    24fe:	0f 90       	pop	r0
    2500:	0f be       	out	0x3f, r0	; 63
    2502:	0f 90       	pop	r0
    2504:	18 95       	reti

00002506 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2506:	cf 93       	push	r28
    2508:	df 93       	push	r29
    250a:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    250c:	27 d4       	rcall	.+2126   	; 0x2d5c <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    250e:	ce 01       	movw	r24, r28
    2510:	0e 94 91 1e 	call	0x3d22	; 0x3d22 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2514:	ec 01       	movw	r28, r24
    2516:	ea d4       	rcall	.+2516   	; 0x2eec <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2518:	ce 01       	movw	r24, r28
    251a:	df 91       	pop	r29
    251c:	cf 91       	pop	r28
    251e:	08 95       	ret

00002520 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2520:	cf 93       	push	r28
    2522:	df 93       	push	r29
	if( pv )
    2524:	00 97       	sbiw	r24, 0x00	; 0
    2526:	31 f0       	breq	.+12     	; 0x2534 <vPortFree+0x14>
    2528:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    252a:	18 d4       	rcall	.+2096   	; 0x2d5c <vTaskSuspendAll>
		{
			free( pv );
    252c:	ce 01       	movw	r24, r28
    252e:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2532:	dc d4       	rcall	.+2488   	; 0x2eec <xTaskResumeAll>
	}
}
    2534:	df 91       	pop	r29
    2536:	cf 91       	pop	r28
    2538:	08 95       	ret

0000253a <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    253a:	0f b6       	in	r0, 0x3f	; 63
    253c:	f8 94       	cli
    253e:	0f 92       	push	r0
    2540:	fc 01       	movw	r30, r24
    2542:	92 8d       	ldd	r25, Z+26	; 0x1a
    2544:	0f 90       	pop	r0
    2546:	0f be       	out	0x3f, r0	; 63
    2548:	81 e0       	ldi	r24, 0x01	; 1
    254a:	91 11       	cpse	r25, r1
    254c:	80 e0       	ldi	r24, 0x00	; 0
    254e:	08 95       	ret

00002550 <prvCopyDataToQueue>:
    2550:	0f 93       	push	r16
    2552:	1f 93       	push	r17
    2554:	cf 93       	push	r28
    2556:	df 93       	push	r29
    2558:	ec 01       	movw	r28, r24
    255a:	04 2f       	mov	r16, r20
    255c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    255e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2560:	44 23       	and	r20, r20
    2562:	b9 f1       	breq	.+110    	; 0x25d2 <prvCopyDataToQueue+0x82>
    2564:	01 11       	cpse	r16, r1
    2566:	16 c0       	rjmp	.+44     	; 0x2594 <prvCopyDataToQueue+0x44>
    2568:	50 e0       	ldi	r21, 0x00	; 0
    256a:	8a 81       	ldd	r24, Y+2	; 0x02
    256c:	9b 81       	ldd	r25, Y+3	; 0x03
    256e:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <memcpy>
    2572:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2574:	8a 81       	ldd	r24, Y+2	; 0x02
    2576:	9b 81       	ldd	r25, Y+3	; 0x03
    2578:	82 0f       	add	r24, r18
    257a:	91 1d       	adc	r25, r1
    257c:	8a 83       	std	Y+2, r24	; 0x02
    257e:	9b 83       	std	Y+3, r25	; 0x03
    2580:	2c 81       	ldd	r18, Y+4	; 0x04
    2582:	3d 81       	ldd	r19, Y+5	; 0x05
    2584:	82 17       	cp	r24, r18
    2586:	93 07       	cpc	r25, r19
    2588:	20 f1       	brcs	.+72     	; 0x25d2 <prvCopyDataToQueue+0x82>
    258a:	88 81       	ld	r24, Y
    258c:	99 81       	ldd	r25, Y+1	; 0x01
    258e:	8a 83       	std	Y+2, r24	; 0x02
    2590:	9b 83       	std	Y+3, r25	; 0x03
    2592:	1f c0       	rjmp	.+62     	; 0x25d2 <prvCopyDataToQueue+0x82>
    2594:	50 e0       	ldi	r21, 0x00	; 0
    2596:	8e 81       	ldd	r24, Y+6	; 0x06
    2598:	9f 81       	ldd	r25, Y+7	; 0x07
    259a:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <memcpy>
    259e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    25a0:	90 e0       	ldi	r25, 0x00	; 0
    25a2:	91 95       	neg	r25
    25a4:	81 95       	neg	r24
    25a6:	91 09       	sbc	r25, r1
    25a8:	2e 81       	ldd	r18, Y+6	; 0x06
    25aa:	3f 81       	ldd	r19, Y+7	; 0x07
    25ac:	28 0f       	add	r18, r24
    25ae:	39 1f       	adc	r19, r25
    25b0:	2e 83       	std	Y+6, r18	; 0x06
    25b2:	3f 83       	std	Y+7, r19	; 0x07
    25b4:	48 81       	ld	r20, Y
    25b6:	59 81       	ldd	r21, Y+1	; 0x01
    25b8:	24 17       	cp	r18, r20
    25ba:	35 07       	cpc	r19, r21
    25bc:	30 f4       	brcc	.+12     	; 0x25ca <prvCopyDataToQueue+0x7a>
    25be:	2c 81       	ldd	r18, Y+4	; 0x04
    25c0:	3d 81       	ldd	r19, Y+5	; 0x05
    25c2:	82 0f       	add	r24, r18
    25c4:	93 1f       	adc	r25, r19
    25c6:	8e 83       	std	Y+6, r24	; 0x06
    25c8:	9f 83       	std	Y+7, r25	; 0x07
    25ca:	02 30       	cpi	r16, 0x02	; 2
    25cc:	11 f4       	brne	.+4      	; 0x25d2 <prvCopyDataToQueue+0x82>
    25ce:	11 11       	cpse	r17, r1
    25d0:	11 50       	subi	r17, 0x01	; 1
    25d2:	1f 5f       	subi	r17, 0xFF	; 255
    25d4:	1a 8f       	std	Y+26, r17	; 0x1a
    25d6:	80 e0       	ldi	r24, 0x00	; 0
    25d8:	df 91       	pop	r29
    25da:	cf 91       	pop	r28
    25dc:	1f 91       	pop	r17
    25de:	0f 91       	pop	r16
    25e0:	08 95       	ret

000025e2 <prvCopyDataFromQueue>:
    25e2:	fc 01       	movw	r30, r24
    25e4:	44 8d       	ldd	r20, Z+28	; 0x1c
    25e6:	44 23       	and	r20, r20
    25e8:	a9 f0       	breq	.+42     	; 0x2614 <prvCopyDataFromQueue+0x32>
    25ea:	50 e0       	ldi	r21, 0x00	; 0
    25ec:	26 81       	ldd	r18, Z+6	; 0x06
    25ee:	37 81       	ldd	r19, Z+7	; 0x07
    25f0:	24 0f       	add	r18, r20
    25f2:	35 1f       	adc	r19, r21
    25f4:	26 83       	std	Z+6, r18	; 0x06
    25f6:	37 83       	std	Z+7, r19	; 0x07
    25f8:	84 81       	ldd	r24, Z+4	; 0x04
    25fa:	95 81       	ldd	r25, Z+5	; 0x05
    25fc:	28 17       	cp	r18, r24
    25fe:	39 07       	cpc	r19, r25
    2600:	20 f0       	brcs	.+8      	; 0x260a <prvCopyDataFromQueue+0x28>
    2602:	80 81       	ld	r24, Z
    2604:	91 81       	ldd	r25, Z+1	; 0x01
    2606:	86 83       	std	Z+6, r24	; 0x06
    2608:	97 83       	std	Z+7, r25	; 0x07
    260a:	cb 01       	movw	r24, r22
    260c:	66 81       	ldd	r22, Z+6	; 0x06
    260e:	77 81       	ldd	r23, Z+7	; 0x07
    2610:	0c 94 b2 1f 	jmp	0x3f64	; 0x3f64 <memcpy>
    2614:	08 95       	ret

00002616 <prvUnlockQueue>:
    2616:	ef 92       	push	r14
    2618:	ff 92       	push	r15
    261a:	0f 93       	push	r16
    261c:	1f 93       	push	r17
    261e:	cf 93       	push	r28
    2620:	8c 01       	movw	r16, r24
    2622:	0f b6       	in	r0, 0x3f	; 63
    2624:	f8 94       	cli
    2626:	0f 92       	push	r0
    2628:	fc 01       	movw	r30, r24
    262a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    262c:	1c 16       	cp	r1, r28
    262e:	9c f4       	brge	.+38     	; 0x2656 <prvUnlockQueue+0x40>
    2630:	81 89       	ldd	r24, Z+17	; 0x11
    2632:	81 11       	cpse	r24, r1
    2634:	06 c0       	rjmp	.+12     	; 0x2642 <prvUnlockQueue+0x2c>
    2636:	0f c0       	rjmp	.+30     	; 0x2656 <prvUnlockQueue+0x40>
    2638:	f8 01       	movw	r30, r16
    263a:	81 89       	ldd	r24, Z+17	; 0x11
    263c:	81 11       	cpse	r24, r1
    263e:	05 c0       	rjmp	.+10     	; 0x264a <prvUnlockQueue+0x34>
    2640:	0a c0       	rjmp	.+20     	; 0x2656 <prvUnlockQueue+0x40>
    2642:	78 01       	movw	r14, r16
    2644:	f1 e1       	ldi	r31, 0x11	; 17
    2646:	ef 0e       	add	r14, r31
    2648:	f1 1c       	adc	r15, r1
    264a:	c7 01       	movw	r24, r14
    264c:	59 d5       	rcall	.+2738   	; 0x3100 <xTaskRemoveFromEventList>
    264e:	81 11       	cpse	r24, r1
    2650:	d3 d5       	rcall	.+2982   	; 0x31f8 <vTaskMissedYield>
    2652:	c1 50       	subi	r28, 0x01	; 1
    2654:	89 f7       	brne	.-30     	; 0x2638 <prvUnlockQueue+0x22>
    2656:	8f ef       	ldi	r24, 0xFF	; 255
    2658:	f8 01       	movw	r30, r16
    265a:	86 8f       	std	Z+30, r24	; 0x1e
    265c:	0f 90       	pop	r0
    265e:	0f be       	out	0x3f, r0	; 63
    2660:	0f b6       	in	r0, 0x3f	; 63
    2662:	f8 94       	cli
    2664:	0f 92       	push	r0
    2666:	c5 8d       	ldd	r28, Z+29	; 0x1d
    2668:	1c 16       	cp	r1, r28
    266a:	9c f4       	brge	.+38     	; 0x2692 <prvUnlockQueue+0x7c>
    266c:	80 85       	ldd	r24, Z+8	; 0x08
    266e:	81 11       	cpse	r24, r1
    2670:	06 c0       	rjmp	.+12     	; 0x267e <prvUnlockQueue+0x68>
    2672:	0f c0       	rjmp	.+30     	; 0x2692 <prvUnlockQueue+0x7c>
    2674:	f8 01       	movw	r30, r16
    2676:	80 85       	ldd	r24, Z+8	; 0x08
    2678:	81 11       	cpse	r24, r1
    267a:	05 c0       	rjmp	.+10     	; 0x2686 <prvUnlockQueue+0x70>
    267c:	0a c0       	rjmp	.+20     	; 0x2692 <prvUnlockQueue+0x7c>
    267e:	78 01       	movw	r14, r16
    2680:	f8 e0       	ldi	r31, 0x08	; 8
    2682:	ef 0e       	add	r14, r31
    2684:	f1 1c       	adc	r15, r1
    2686:	c7 01       	movw	r24, r14
    2688:	3b d5       	rcall	.+2678   	; 0x3100 <xTaskRemoveFromEventList>
    268a:	81 11       	cpse	r24, r1
    268c:	b5 d5       	rcall	.+2922   	; 0x31f8 <vTaskMissedYield>
    268e:	c1 50       	subi	r28, 0x01	; 1
    2690:	89 f7       	brne	.-30     	; 0x2674 <prvUnlockQueue+0x5e>
    2692:	8f ef       	ldi	r24, 0xFF	; 255
    2694:	f8 01       	movw	r30, r16
    2696:	85 8f       	std	Z+29, r24	; 0x1d
    2698:	0f 90       	pop	r0
    269a:	0f be       	out	0x3f, r0	; 63
    269c:	cf 91       	pop	r28
    269e:	1f 91       	pop	r17
    26a0:	0f 91       	pop	r16
    26a2:	ff 90       	pop	r15
    26a4:	ef 90       	pop	r14
    26a6:	08 95       	ret

000026a8 <xQueueGenericReset>:
    26a8:	cf 93       	push	r28
    26aa:	df 93       	push	r29
    26ac:	ec 01       	movw	r28, r24
    26ae:	0f b6       	in	r0, 0x3f	; 63
    26b0:	f8 94       	cli
    26b2:	0f 92       	push	r0
    26b4:	e8 81       	ld	r30, Y
    26b6:	f9 81       	ldd	r31, Y+1	; 0x01
    26b8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    26ba:	2c 8d       	ldd	r18, Y+28	; 0x1c
    26bc:	90 e0       	ldi	r25, 0x00	; 0
    26be:	30 e0       	ldi	r19, 0x00	; 0
    26c0:	82 9f       	mul	r24, r18
    26c2:	a0 01       	movw	r20, r0
    26c4:	83 9f       	mul	r24, r19
    26c6:	50 0d       	add	r21, r0
    26c8:	92 9f       	mul	r25, r18
    26ca:	50 0d       	add	r21, r0
    26cc:	11 24       	eor	r1, r1
    26ce:	4e 0f       	add	r20, r30
    26d0:	5f 1f       	adc	r21, r31
    26d2:	4c 83       	std	Y+4, r20	; 0x04
    26d4:	5d 83       	std	Y+5, r21	; 0x05
    26d6:	1a 8e       	std	Y+26, r1	; 0x1a
    26d8:	ea 83       	std	Y+2, r30	; 0x02
    26da:	fb 83       	std	Y+3, r31	; 0x03
    26dc:	01 97       	sbiw	r24, 0x01	; 1
    26de:	82 9f       	mul	r24, r18
    26e0:	a0 01       	movw	r20, r0
    26e2:	83 9f       	mul	r24, r19
    26e4:	50 0d       	add	r21, r0
    26e6:	92 9f       	mul	r25, r18
    26e8:	50 0d       	add	r21, r0
    26ea:	11 24       	eor	r1, r1
    26ec:	cf 01       	movw	r24, r30
    26ee:	84 0f       	add	r24, r20
    26f0:	95 1f       	adc	r25, r21
    26f2:	8e 83       	std	Y+6, r24	; 0x06
    26f4:	9f 83       	std	Y+7, r25	; 0x07
    26f6:	8f ef       	ldi	r24, 0xFF	; 255
    26f8:	8d 8f       	std	Y+29, r24	; 0x1d
    26fa:	8e 8f       	std	Y+30, r24	; 0x1e
    26fc:	61 11       	cpse	r22, r1
    26fe:	0a c0       	rjmp	.+20     	; 0x2714 <xQueueGenericReset+0x6c>
    2700:	88 85       	ldd	r24, Y+8	; 0x08
    2702:	88 23       	and	r24, r24
    2704:	69 f0       	breq	.+26     	; 0x2720 <xQueueGenericReset+0x78>
    2706:	ce 01       	movw	r24, r28
    2708:	08 96       	adiw	r24, 0x08	; 8
    270a:	fa d4       	rcall	.+2548   	; 0x3100 <xTaskRemoveFromEventList>
    270c:	88 23       	and	r24, r24
    270e:	41 f0       	breq	.+16     	; 0x2720 <xQueueGenericReset+0x78>
    2710:	48 de       	rcall	.-880    	; 0x23a2 <vPortYield>
    2712:	06 c0       	rjmp	.+12     	; 0x2720 <xQueueGenericReset+0x78>
    2714:	ce 01       	movw	r24, r28
    2716:	08 96       	adiw	r24, 0x08	; 8
    2718:	fd dc       	rcall	.-1542   	; 0x2114 <vListInitialise>
    271a:	ce 01       	movw	r24, r28
    271c:	41 96       	adiw	r24, 0x11	; 17
    271e:	fa dc       	rcall	.-1548   	; 0x2114 <vListInitialise>
    2720:	0f 90       	pop	r0
    2722:	0f be       	out	0x3f, r0	; 63
    2724:	81 e0       	ldi	r24, 0x01	; 1
    2726:	df 91       	pop	r29
    2728:	cf 91       	pop	r28
    272a:	08 95       	ret

0000272c <xQueueGenericCreate>:
    272c:	0f 93       	push	r16
    272e:	1f 93       	push	r17
    2730:	cf 93       	push	r28
    2732:	df 93       	push	r29
    2734:	08 2f       	mov	r16, r24
    2736:	16 2f       	mov	r17, r22
    2738:	86 9f       	mul	r24, r22
    273a:	c0 01       	movw	r24, r0
    273c:	11 24       	eor	r1, r1
    273e:	4f 96       	adiw	r24, 0x1f	; 31
    2740:	e2 de       	rcall	.-572    	; 0x2506 <pvPortMalloc>
    2742:	ec 01       	movw	r28, r24
    2744:	00 97       	sbiw	r24, 0x00	; 0
    2746:	69 f0       	breq	.+26     	; 0x2762 <xQueueGenericCreate+0x36>
    2748:	11 11       	cpse	r17, r1
    274a:	03 c0       	rjmp	.+6      	; 0x2752 <xQueueGenericCreate+0x26>
    274c:	88 83       	st	Y, r24
    274e:	99 83       	std	Y+1, r25	; 0x01
    2750:	03 c0       	rjmp	.+6      	; 0x2758 <xQueueGenericCreate+0x2c>
    2752:	4f 96       	adiw	r24, 0x1f	; 31
    2754:	88 83       	st	Y, r24
    2756:	99 83       	std	Y+1, r25	; 0x01
    2758:	0b 8f       	std	Y+27, r16	; 0x1b
    275a:	1c 8f       	std	Y+28, r17	; 0x1c
    275c:	61 e0       	ldi	r22, 0x01	; 1
    275e:	ce 01       	movw	r24, r28
    2760:	a3 df       	rcall	.-186    	; 0x26a8 <xQueueGenericReset>
    2762:	ce 01       	movw	r24, r28
    2764:	df 91       	pop	r29
    2766:	cf 91       	pop	r28
    2768:	1f 91       	pop	r17
    276a:	0f 91       	pop	r16
    276c:	08 95       	ret

0000276e <xQueueGenericSend>:
    276e:	af 92       	push	r10
    2770:	bf 92       	push	r11
    2772:	cf 92       	push	r12
    2774:	df 92       	push	r13
    2776:	ef 92       	push	r14
    2778:	ff 92       	push	r15
    277a:	0f 93       	push	r16
    277c:	1f 93       	push	r17
    277e:	cf 93       	push	r28
    2780:	df 93       	push	r29
    2782:	cd b7       	in	r28, 0x3d	; 61
    2784:	de b7       	in	r29, 0x3e	; 62
    2786:	25 97       	sbiw	r28, 0x05	; 5
    2788:	cd bf       	out	0x3d, r28	; 61
    278a:	de bf       	out	0x3e, r29	; 62
    278c:	8c 01       	movw	r16, r24
    278e:	6b 01       	movw	r12, r22
    2790:	4c 83       	std	Y+4, r20	; 0x04
    2792:	5d 83       	std	Y+5, r21	; 0x05
    2794:	a2 2e       	mov	r10, r18
    2796:	b1 2c       	mov	r11, r1
    2798:	7c 01       	movw	r14, r24
    279a:	88 e0       	ldi	r24, 0x08	; 8
    279c:	e8 0e       	add	r14, r24
    279e:	f1 1c       	adc	r15, r1
    27a0:	0f b6       	in	r0, 0x3f	; 63
    27a2:	f8 94       	cli
    27a4:	0f 92       	push	r0
    27a6:	f8 01       	movw	r30, r16
    27a8:	92 8d       	ldd	r25, Z+26	; 0x1a
    27aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    27ac:	98 17       	cp	r25, r24
    27ae:	18 f0       	brcs	.+6      	; 0x27b6 <xQueueGenericSend+0x48>
    27b0:	f2 e0       	ldi	r31, 0x02	; 2
    27b2:	af 12       	cpse	r10, r31
    27b4:	15 c0       	rjmp	.+42     	; 0x27e0 <xQueueGenericSend+0x72>
    27b6:	4a 2d       	mov	r20, r10
    27b8:	b6 01       	movw	r22, r12
    27ba:	c8 01       	movw	r24, r16
    27bc:	c9 de       	rcall	.-622    	; 0x2550 <prvCopyDataToQueue>
    27be:	f8 01       	movw	r30, r16
    27c0:	91 89       	ldd	r25, Z+17	; 0x11
    27c2:	99 23       	and	r25, r25
    27c4:	39 f0       	breq	.+14     	; 0x27d4 <xQueueGenericSend+0x66>
    27c6:	c8 01       	movw	r24, r16
    27c8:	41 96       	adiw	r24, 0x11	; 17
    27ca:	9a d4       	rcall	.+2356   	; 0x3100 <xTaskRemoveFromEventList>
    27cc:	88 23       	and	r24, r24
    27ce:	21 f0       	breq	.+8      	; 0x27d8 <xQueueGenericSend+0x6a>
    27d0:	e8 dd       	rcall	.-1072   	; 0x23a2 <vPortYield>
    27d2:	02 c0       	rjmp	.+4      	; 0x27d8 <xQueueGenericSend+0x6a>
    27d4:	81 11       	cpse	r24, r1
    27d6:	e5 dd       	rcall	.-1078   	; 0x23a2 <vPortYield>
    27d8:	0f 90       	pop	r0
    27da:	0f be       	out	0x3f, r0	; 63
    27dc:	81 e0       	ldi	r24, 0x01	; 1
    27de:	46 c0       	rjmp	.+140    	; 0x286c <xQueueGenericSend+0xfe>
    27e0:	8c 81       	ldd	r24, Y+4	; 0x04
    27e2:	9d 81       	ldd	r25, Y+5	; 0x05
    27e4:	89 2b       	or	r24, r25
    27e6:	21 f4       	brne	.+8      	; 0x27f0 <xQueueGenericSend+0x82>
    27e8:	0f 90       	pop	r0
    27ea:	0f be       	out	0x3f, r0	; 63
    27ec:	80 e0       	ldi	r24, 0x00	; 0
    27ee:	3e c0       	rjmp	.+124    	; 0x286c <xQueueGenericSend+0xfe>
    27f0:	b1 10       	cpse	r11, r1
    27f2:	05 c0       	rjmp	.+10     	; 0x27fe <xQueueGenericSend+0x90>
    27f4:	ce 01       	movw	r24, r28
    27f6:	01 96       	adiw	r24, 0x01	; 1
    27f8:	c9 d4       	rcall	.+2450   	; 0x318c <vTaskInternalSetTimeOutState>
    27fa:	bb 24       	eor	r11, r11
    27fc:	b3 94       	inc	r11
    27fe:	0f 90       	pop	r0
    2800:	0f be       	out	0x3f, r0	; 63
    2802:	ac d2       	rcall	.+1368   	; 0x2d5c <vTaskSuspendAll>
    2804:	0f b6       	in	r0, 0x3f	; 63
    2806:	f8 94       	cli
    2808:	0f 92       	push	r0
    280a:	f8 01       	movw	r30, r16
    280c:	85 8d       	ldd	r24, Z+29	; 0x1d
    280e:	8f 3f       	cpi	r24, 0xFF	; 255
    2810:	09 f4       	brne	.+2      	; 0x2814 <xQueueGenericSend+0xa6>
    2812:	15 8e       	std	Z+29, r1	; 0x1d
    2814:	f8 01       	movw	r30, r16
    2816:	86 8d       	ldd	r24, Z+30	; 0x1e
    2818:	8f 3f       	cpi	r24, 0xFF	; 255
    281a:	09 f4       	brne	.+2      	; 0x281e <xQueueGenericSend+0xb0>
    281c:	16 8e       	std	Z+30, r1	; 0x1e
    281e:	0f 90       	pop	r0
    2820:	0f be       	out	0x3f, r0	; 63
    2822:	be 01       	movw	r22, r28
    2824:	6c 5f       	subi	r22, 0xFC	; 252
    2826:	7f 4f       	sbci	r23, 0xFF	; 255
    2828:	ce 01       	movw	r24, r28
    282a:	01 96       	adiw	r24, 0x01	; 1
    282c:	ba d4       	rcall	.+2420   	; 0x31a2 <xTaskCheckForTimeOut>
    282e:	81 11       	cpse	r24, r1
    2830:	19 c0       	rjmp	.+50     	; 0x2864 <xQueueGenericSend+0xf6>
    2832:	0f b6       	in	r0, 0x3f	; 63
    2834:	f8 94       	cli
    2836:	0f 92       	push	r0
    2838:	f8 01       	movw	r30, r16
    283a:	92 8d       	ldd	r25, Z+26	; 0x1a
    283c:	0f 90       	pop	r0
    283e:	0f be       	out	0x3f, r0	; 63
    2840:	83 8d       	ldd	r24, Z+27	; 0x1b
    2842:	98 13       	cpse	r25, r24
    2844:	0b c0       	rjmp	.+22     	; 0x285c <xQueueGenericSend+0xee>
    2846:	6c 81       	ldd	r22, Y+4	; 0x04
    2848:	7d 81       	ldd	r23, Y+5	; 0x05
    284a:	c7 01       	movw	r24, r14
    284c:	32 d4       	rcall	.+2148   	; 0x30b2 <vTaskPlaceOnEventList>
    284e:	c8 01       	movw	r24, r16
    2850:	e2 de       	rcall	.-572    	; 0x2616 <prvUnlockQueue>
    2852:	4c d3       	rcall	.+1688   	; 0x2eec <xTaskResumeAll>
    2854:	81 11       	cpse	r24, r1
    2856:	a4 cf       	rjmp	.-184    	; 0x27a0 <xQueueGenericSend+0x32>
    2858:	a4 dd       	rcall	.-1208   	; 0x23a2 <vPortYield>
    285a:	a2 cf       	rjmp	.-188    	; 0x27a0 <xQueueGenericSend+0x32>
    285c:	c8 01       	movw	r24, r16
    285e:	db de       	rcall	.-586    	; 0x2616 <prvUnlockQueue>
    2860:	45 d3       	rcall	.+1674   	; 0x2eec <xTaskResumeAll>
    2862:	9e cf       	rjmp	.-196    	; 0x27a0 <xQueueGenericSend+0x32>
    2864:	c8 01       	movw	r24, r16
    2866:	d7 de       	rcall	.-594    	; 0x2616 <prvUnlockQueue>
    2868:	41 d3       	rcall	.+1666   	; 0x2eec <xTaskResumeAll>
    286a:	80 e0       	ldi	r24, 0x00	; 0
    286c:	25 96       	adiw	r28, 0x05	; 5
    286e:	cd bf       	out	0x3d, r28	; 61
    2870:	de bf       	out	0x3e, r29	; 62
    2872:	df 91       	pop	r29
    2874:	cf 91       	pop	r28
    2876:	1f 91       	pop	r17
    2878:	0f 91       	pop	r16
    287a:	ff 90       	pop	r15
    287c:	ef 90       	pop	r14
    287e:	df 90       	pop	r13
    2880:	cf 90       	pop	r12
    2882:	bf 90       	pop	r11
    2884:	af 90       	pop	r10
    2886:	08 95       	ret

00002888 <xQueueGenericSendFromISR>:
    2888:	ef 92       	push	r14
    288a:	ff 92       	push	r15
    288c:	0f 93       	push	r16
    288e:	1f 93       	push	r17
    2890:	cf 93       	push	r28
    2892:	df 93       	push	r29
    2894:	8a 01       	movw	r16, r20
    2896:	fc 01       	movw	r30, r24
    2898:	52 8d       	ldd	r21, Z+26	; 0x1a
    289a:	33 8d       	ldd	r19, Z+27	; 0x1b
    289c:	53 17       	cp	r21, r19
    289e:	10 f0       	brcs	.+4      	; 0x28a4 <xQueueGenericSendFromISR+0x1c>
    28a0:	22 30       	cpi	r18, 0x02	; 2
    28a2:	f1 f4       	brne	.+60     	; 0x28e0 <xQueueGenericSendFromISR+0x58>
    28a4:	42 2f       	mov	r20, r18
    28a6:	78 01       	movw	r14, r16
    28a8:	ec 01       	movw	r28, r24
    28aa:	1e 8d       	ldd	r17, Y+30	; 0x1e
    28ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28ae:	ce 01       	movw	r24, r28
    28b0:	4f de       	rcall	.-866    	; 0x2550 <prvCopyDataToQueue>
    28b2:	1f 3f       	cpi	r17, 0xFF	; 255
    28b4:	79 f4       	brne	.+30     	; 0x28d4 <xQueueGenericSendFromISR+0x4c>
    28b6:	89 89       	ldd	r24, Y+17	; 0x11
    28b8:	88 23       	and	r24, r24
    28ba:	a1 f0       	breq	.+40     	; 0x28e4 <xQueueGenericSendFromISR+0x5c>
    28bc:	ce 01       	movw	r24, r28
    28be:	41 96       	adiw	r24, 0x11	; 17
    28c0:	1f d4       	rcall	.+2110   	; 0x3100 <xTaskRemoveFromEventList>
    28c2:	88 23       	and	r24, r24
    28c4:	89 f0       	breq	.+34     	; 0x28e8 <xQueueGenericSendFromISR+0x60>
    28c6:	e1 14       	cp	r14, r1
    28c8:	f1 04       	cpc	r15, r1
    28ca:	81 f0       	breq	.+32     	; 0x28ec <xQueueGenericSendFromISR+0x64>
    28cc:	81 e0       	ldi	r24, 0x01	; 1
    28ce:	f7 01       	movw	r30, r14
    28d0:	80 83       	st	Z, r24
    28d2:	0d c0       	rjmp	.+26     	; 0x28ee <xQueueGenericSendFromISR+0x66>
    28d4:	ff 24       	eor	r15, r15
    28d6:	f3 94       	inc	r15
    28d8:	f1 0e       	add	r15, r17
    28da:	fe 8e       	std	Y+30, r15	; 0x1e
    28dc:	81 e0       	ldi	r24, 0x01	; 1
    28de:	07 c0       	rjmp	.+14     	; 0x28ee <xQueueGenericSendFromISR+0x66>
    28e0:	80 e0       	ldi	r24, 0x00	; 0
    28e2:	05 c0       	rjmp	.+10     	; 0x28ee <xQueueGenericSendFromISR+0x66>
    28e4:	81 e0       	ldi	r24, 0x01	; 1
    28e6:	03 c0       	rjmp	.+6      	; 0x28ee <xQueueGenericSendFromISR+0x66>
    28e8:	81 e0       	ldi	r24, 0x01	; 1
    28ea:	01 c0       	rjmp	.+2      	; 0x28ee <xQueueGenericSendFromISR+0x66>
    28ec:	81 e0       	ldi	r24, 0x01	; 1
    28ee:	df 91       	pop	r29
    28f0:	cf 91       	pop	r28
    28f2:	1f 91       	pop	r17
    28f4:	0f 91       	pop	r16
    28f6:	ff 90       	pop	r15
    28f8:	ef 90       	pop	r14
    28fa:	08 95       	ret

000028fc <xQueueReceive>:
    28fc:	af 92       	push	r10
    28fe:	bf 92       	push	r11
    2900:	cf 92       	push	r12
    2902:	df 92       	push	r13
    2904:	ef 92       	push	r14
    2906:	ff 92       	push	r15
    2908:	0f 93       	push	r16
    290a:	1f 93       	push	r17
    290c:	cf 93       	push	r28
    290e:	df 93       	push	r29
    2910:	cd b7       	in	r28, 0x3d	; 61
    2912:	de b7       	in	r29, 0x3e	; 62
    2914:	25 97       	sbiw	r28, 0x05	; 5
    2916:	cd bf       	out	0x3d, r28	; 61
    2918:	de bf       	out	0x3e, r29	; 62
    291a:	8c 01       	movw	r16, r24
    291c:	5b 01       	movw	r10, r22
    291e:	4c 83       	std	Y+4, r20	; 0x04
    2920:	5d 83       	std	Y+5, r21	; 0x05
    2922:	e1 2c       	mov	r14, r1
    2924:	6c 01       	movw	r12, r24
    2926:	81 e1       	ldi	r24, 0x11	; 17
    2928:	c8 0e       	add	r12, r24
    292a:	d1 1c       	adc	r13, r1
    292c:	0f b6       	in	r0, 0x3f	; 63
    292e:	f8 94       	cli
    2930:	0f 92       	push	r0
    2932:	f8 01       	movw	r30, r16
    2934:	f2 8c       	ldd	r15, Z+26	; 0x1a
    2936:	ff 20       	and	r15, r15
    2938:	91 f0       	breq	.+36     	; 0x295e <xQueueReceive+0x62>
    293a:	b5 01       	movw	r22, r10
    293c:	c8 01       	movw	r24, r16
    293e:	51 de       	rcall	.-862    	; 0x25e2 <prvCopyDataFromQueue>
    2940:	fa 94       	dec	r15
    2942:	f8 01       	movw	r30, r16
    2944:	f2 8e       	std	Z+26, r15	; 0x1a
    2946:	80 85       	ldd	r24, Z+8	; 0x08
    2948:	88 23       	and	r24, r24
    294a:	29 f0       	breq	.+10     	; 0x2956 <xQueueReceive+0x5a>
    294c:	c8 01       	movw	r24, r16
    294e:	08 96       	adiw	r24, 0x08	; 8
    2950:	d7 d3       	rcall	.+1966   	; 0x3100 <xTaskRemoveFromEventList>
    2952:	81 11       	cpse	r24, r1
    2954:	26 dd       	rcall	.-1460   	; 0x23a2 <vPortYield>
    2956:	0f 90       	pop	r0
    2958:	0f be       	out	0x3f, r0	; 63
    295a:	81 e0       	ldi	r24, 0x01	; 1
    295c:	45 c0       	rjmp	.+138    	; 0x29e8 <xQueueReceive+0xec>
    295e:	8c 81       	ldd	r24, Y+4	; 0x04
    2960:	9d 81       	ldd	r25, Y+5	; 0x05
    2962:	89 2b       	or	r24, r25
    2964:	21 f4       	brne	.+8      	; 0x296e <xQueueReceive+0x72>
    2966:	0f 90       	pop	r0
    2968:	0f be       	out	0x3f, r0	; 63
    296a:	80 e0       	ldi	r24, 0x00	; 0
    296c:	3d c0       	rjmp	.+122    	; 0x29e8 <xQueueReceive+0xec>
    296e:	e1 10       	cpse	r14, r1
    2970:	05 c0       	rjmp	.+10     	; 0x297c <xQueueReceive+0x80>
    2972:	ce 01       	movw	r24, r28
    2974:	01 96       	adiw	r24, 0x01	; 1
    2976:	0a d4       	rcall	.+2068   	; 0x318c <vTaskInternalSetTimeOutState>
    2978:	ee 24       	eor	r14, r14
    297a:	e3 94       	inc	r14
    297c:	0f 90       	pop	r0
    297e:	0f be       	out	0x3f, r0	; 63
    2980:	ed d1       	rcall	.+986    	; 0x2d5c <vTaskSuspendAll>
    2982:	0f b6       	in	r0, 0x3f	; 63
    2984:	f8 94       	cli
    2986:	0f 92       	push	r0
    2988:	f8 01       	movw	r30, r16
    298a:	85 8d       	ldd	r24, Z+29	; 0x1d
    298c:	8f 3f       	cpi	r24, 0xFF	; 255
    298e:	09 f4       	brne	.+2      	; 0x2992 <xQueueReceive+0x96>
    2990:	15 8e       	std	Z+29, r1	; 0x1d
    2992:	f8 01       	movw	r30, r16
    2994:	86 8d       	ldd	r24, Z+30	; 0x1e
    2996:	8f 3f       	cpi	r24, 0xFF	; 255
    2998:	09 f4       	brne	.+2      	; 0x299c <xQueueReceive+0xa0>
    299a:	16 8e       	std	Z+30, r1	; 0x1e
    299c:	0f 90       	pop	r0
    299e:	0f be       	out	0x3f, r0	; 63
    29a0:	be 01       	movw	r22, r28
    29a2:	6c 5f       	subi	r22, 0xFC	; 252
    29a4:	7f 4f       	sbci	r23, 0xFF	; 255
    29a6:	ce 01       	movw	r24, r28
    29a8:	01 96       	adiw	r24, 0x01	; 1
    29aa:	fb d3       	rcall	.+2038   	; 0x31a2 <xTaskCheckForTimeOut>
    29ac:	81 11       	cpse	r24, r1
    29ae:	13 c0       	rjmp	.+38     	; 0x29d6 <xQueueReceive+0xda>
    29b0:	c8 01       	movw	r24, r16
    29b2:	c3 dd       	rcall	.-1146   	; 0x253a <prvIsQueueEmpty>
    29b4:	88 23       	and	r24, r24
    29b6:	59 f0       	breq	.+22     	; 0x29ce <xQueueReceive+0xd2>
    29b8:	6c 81       	ldd	r22, Y+4	; 0x04
    29ba:	7d 81       	ldd	r23, Y+5	; 0x05
    29bc:	c6 01       	movw	r24, r12
    29be:	79 d3       	rcall	.+1778   	; 0x30b2 <vTaskPlaceOnEventList>
    29c0:	c8 01       	movw	r24, r16
    29c2:	29 de       	rcall	.-942    	; 0x2616 <prvUnlockQueue>
    29c4:	93 d2       	rcall	.+1318   	; 0x2eec <xTaskResumeAll>
    29c6:	81 11       	cpse	r24, r1
    29c8:	b1 cf       	rjmp	.-158    	; 0x292c <xQueueReceive+0x30>
    29ca:	eb dc       	rcall	.-1578   	; 0x23a2 <vPortYield>
    29cc:	af cf       	rjmp	.-162    	; 0x292c <xQueueReceive+0x30>
    29ce:	c8 01       	movw	r24, r16
    29d0:	22 de       	rcall	.-956    	; 0x2616 <prvUnlockQueue>
    29d2:	8c d2       	rcall	.+1304   	; 0x2eec <xTaskResumeAll>
    29d4:	ab cf       	rjmp	.-170    	; 0x292c <xQueueReceive+0x30>
    29d6:	c8 01       	movw	r24, r16
    29d8:	1e de       	rcall	.-964    	; 0x2616 <prvUnlockQueue>
    29da:	88 d2       	rcall	.+1296   	; 0x2eec <xTaskResumeAll>
    29dc:	c8 01       	movw	r24, r16
    29de:	ad dd       	rcall	.-1190   	; 0x253a <prvIsQueueEmpty>
    29e0:	88 23       	and	r24, r24
    29e2:	09 f4       	brne	.+2      	; 0x29e6 <xQueueReceive+0xea>
    29e4:	a3 cf       	rjmp	.-186    	; 0x292c <xQueueReceive+0x30>
    29e6:	80 e0       	ldi	r24, 0x00	; 0
    29e8:	25 96       	adiw	r28, 0x05	; 5
    29ea:	cd bf       	out	0x3d, r28	; 61
    29ec:	de bf       	out	0x3e, r29	; 62
    29ee:	df 91       	pop	r29
    29f0:	cf 91       	pop	r28
    29f2:	1f 91       	pop	r17
    29f4:	0f 91       	pop	r16
    29f6:	ff 90       	pop	r15
    29f8:	ef 90       	pop	r14
    29fa:	df 90       	pop	r13
    29fc:	cf 90       	pop	r12
    29fe:	bf 90       	pop	r11
    2a00:	af 90       	pop	r10
    2a02:	08 95       	ret

00002a04 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    2a04:	cf 93       	push	r28
    2a06:	df 93       	push	r29
    2a08:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    2a0a:	0f b6       	in	r0, 0x3f	; 63
    2a0c:	f8 94       	cli
    2a0e:	0f 92       	push	r0
    2a10:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2a12:	8f 3f       	cpi	r24, 0xFF	; 255
    2a14:	09 f4       	brne	.+2      	; 0x2a18 <vQueueWaitForMessageRestricted+0x14>
    2a16:	1d 8e       	std	Y+29, r1	; 0x1d
    2a18:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2a1a:	8f 3f       	cpi	r24, 0xFF	; 255
    2a1c:	09 f4       	brne	.+2      	; 0x2a20 <vQueueWaitForMessageRestricted+0x1c>
    2a1e:	1e 8e       	std	Y+30, r1	; 0x1e
    2a20:	0f 90       	pop	r0
    2a22:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2a24:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2a26:	81 11       	cpse	r24, r1
    2a28:	03 c0       	rjmp	.+6      	; 0x2a30 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2a2a:	ce 01       	movw	r24, r28
    2a2c:	41 96       	adiw	r24, 0x11	; 17
    2a2e:	51 d3       	rcall	.+1698   	; 0x30d2 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    2a30:	ce 01       	movw	r24, r28
    2a32:	f1 dd       	rcall	.-1054   	; 0x2616 <prvUnlockQueue>
	}
    2a34:	df 91       	pop	r29
    2a36:	cf 91       	pop	r28
    2a38:	08 95       	ret

00002a3a <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    2a3a:	e0 91 73 22 	lds	r30, 0x2273	; 0x802273 <pxDelayedTaskList>
    2a3e:	f0 91 74 22 	lds	r31, 0x2274	; 0x802274 <pxDelayedTaskList+0x1>
    2a42:	80 81       	ld	r24, Z
    2a44:	81 11       	cpse	r24, r1
    2a46:	07 c0       	rjmp	.+14     	; 0x2a56 <prvResetNextTaskUnblockTime+0x1c>
    2a48:	8f ef       	ldi	r24, 0xFF	; 255
    2a4a:	9f ef       	ldi	r25, 0xFF	; 255
    2a4c:	80 93 5c 22 	sts	0x225C, r24	; 0x80225c <xNextTaskUnblockTime>
    2a50:	90 93 5d 22 	sts	0x225D, r25	; 0x80225d <xNextTaskUnblockTime+0x1>
    2a54:	08 95       	ret
    2a56:	e0 91 73 22 	lds	r30, 0x2273	; 0x802273 <pxDelayedTaskList>
    2a5a:	f0 91 74 22 	lds	r31, 0x2274	; 0x802274 <pxDelayedTaskList+0x1>
    2a5e:	05 80       	ldd	r0, Z+5	; 0x05
    2a60:	f6 81       	ldd	r31, Z+6	; 0x06
    2a62:	e0 2d       	mov	r30, r0
    2a64:	06 80       	ldd	r0, Z+6	; 0x06
    2a66:	f7 81       	ldd	r31, Z+7	; 0x07
    2a68:	e0 2d       	mov	r30, r0
    2a6a:	82 81       	ldd	r24, Z+2	; 0x02
    2a6c:	93 81       	ldd	r25, Z+3	; 0x03
    2a6e:	80 93 5c 22 	sts	0x225C, r24	; 0x80225c <xNextTaskUnblockTime>
    2a72:	90 93 5d 22 	sts	0x225D, r25	; 0x80225d <xNextTaskUnblockTime+0x1>
    2a76:	08 95       	ret

00002a78 <prvIdleTask>:
    2a78:	c7 e8       	ldi	r28, 0x87	; 135
    2a7a:	d2 e2       	ldi	r29, 0x22	; 34
    2a7c:	88 81       	ld	r24, Y
    2a7e:	82 30       	cpi	r24, 0x02	; 2
    2a80:	e8 f3       	brcs	.-6      	; 0x2a7c <prvIdleTask+0x4>
    2a82:	8f dc       	rcall	.-1762   	; 0x23a2 <vPortYield>
    2a84:	fb cf       	rjmp	.-10     	; 0x2a7c <prvIdleTask+0x4>

00002a86 <prvAddCurrentTaskToDelayedList>:
    2a86:	0f 93       	push	r16
    2a88:	1f 93       	push	r17
    2a8a:	cf 93       	push	r28
    2a8c:	df 93       	push	r29
    2a8e:	ec 01       	movw	r28, r24
    2a90:	00 91 65 22 	lds	r16, 0x2265	; 0x802265 <xTickCount>
    2a94:	10 91 66 22 	lds	r17, 0x2266	; 0x802266 <xTickCount+0x1>
    2a98:	80 91 b4 22 	lds	r24, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2a9c:	90 91 b5 22 	lds	r25, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2aa0:	02 96       	adiw	r24, 0x02	; 2
    2aa2:	9c db       	rcall	.-2248   	; 0x21dc <uxListRemove>
    2aa4:	c0 0f       	add	r28, r16
    2aa6:	d1 1f       	adc	r29, r17
    2aa8:	e0 91 b4 22 	lds	r30, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2aac:	f0 91 b5 22 	lds	r31, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2ab0:	c2 83       	std	Z+2, r28	; 0x02
    2ab2:	d3 83       	std	Z+3, r29	; 0x03
    2ab4:	c0 17       	cp	r28, r16
    2ab6:	d1 07       	cpc	r29, r17
    2ab8:	60 f4       	brcc	.+24     	; 0x2ad2 <prvAddCurrentTaskToDelayedList+0x4c>
    2aba:	60 91 b4 22 	lds	r22, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2abe:	70 91 b5 22 	lds	r23, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2ac2:	80 91 71 22 	lds	r24, 0x2271	; 0x802271 <pxOverflowDelayedTaskList>
    2ac6:	90 91 72 22 	lds	r25, 0x2272	; 0x802272 <pxOverflowDelayedTaskList+0x1>
    2aca:	6e 5f       	subi	r22, 0xFE	; 254
    2acc:	7f 4f       	sbci	r23, 0xFF	; 255
    2ace:	55 db       	rcall	.-2390   	; 0x217a <vListInsert>
    2ad0:	16 c0       	rjmp	.+44     	; 0x2afe <prvAddCurrentTaskToDelayedList+0x78>
    2ad2:	60 91 b4 22 	lds	r22, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2ad6:	70 91 b5 22 	lds	r23, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2ada:	80 91 73 22 	lds	r24, 0x2273	; 0x802273 <pxDelayedTaskList>
    2ade:	90 91 74 22 	lds	r25, 0x2274	; 0x802274 <pxDelayedTaskList+0x1>
    2ae2:	6e 5f       	subi	r22, 0xFE	; 254
    2ae4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae6:	49 db       	rcall	.-2414   	; 0x217a <vListInsert>
    2ae8:	80 91 5c 22 	lds	r24, 0x225C	; 0x80225c <xNextTaskUnblockTime>
    2aec:	90 91 5d 22 	lds	r25, 0x225D	; 0x80225d <xNextTaskUnblockTime+0x1>
    2af0:	c8 17       	cp	r28, r24
    2af2:	d9 07       	cpc	r29, r25
    2af4:	20 f4       	brcc	.+8      	; 0x2afe <prvAddCurrentTaskToDelayedList+0x78>
    2af6:	c0 93 5c 22 	sts	0x225C, r28	; 0x80225c <xNextTaskUnblockTime>
    2afa:	d0 93 5d 22 	sts	0x225D, r29	; 0x80225d <xNextTaskUnblockTime+0x1>
    2afe:	df 91       	pop	r29
    2b00:	cf 91       	pop	r28
    2b02:	1f 91       	pop	r17
    2b04:	0f 91       	pop	r16
    2b06:	08 95       	ret

00002b08 <xTaskCreate>:
    2b08:	4f 92       	push	r4
    2b0a:	5f 92       	push	r5
    2b0c:	6f 92       	push	r6
    2b0e:	7f 92       	push	r7
    2b10:	8f 92       	push	r8
    2b12:	9f 92       	push	r9
    2b14:	af 92       	push	r10
    2b16:	bf 92       	push	r11
    2b18:	cf 92       	push	r12
    2b1a:	df 92       	push	r13
    2b1c:	ef 92       	push	r14
    2b1e:	ff 92       	push	r15
    2b20:	0f 93       	push	r16
    2b22:	1f 93       	push	r17
    2b24:	cf 93       	push	r28
    2b26:	df 93       	push	r29
    2b28:	4c 01       	movw	r8, r24
    2b2a:	6b 01       	movw	r12, r22
    2b2c:	5a 01       	movw	r10, r20
    2b2e:	29 01       	movw	r4, r18
    2b30:	ca 01       	movw	r24, r20
    2b32:	e9 dc       	rcall	.-1582   	; 0x2506 <pvPortMalloc>
    2b34:	3c 01       	movw	r6, r24
    2b36:	89 2b       	or	r24, r25
    2b38:	09 f4       	brne	.+2      	; 0x2b3c <xTaskCreate+0x34>
    2b3a:	d3 c0       	rjmp	.+422    	; 0x2ce2 <xTaskCreate+0x1da>
    2b3c:	86 e2       	ldi	r24, 0x26	; 38
    2b3e:	90 e0       	ldi	r25, 0x00	; 0
    2b40:	e2 dc       	rcall	.-1596   	; 0x2506 <pvPortMalloc>
    2b42:	ec 01       	movw	r28, r24
    2b44:	89 2b       	or	r24, r25
    2b46:	59 f0       	breq	.+22     	; 0x2b5e <xTaskCreate+0x56>
    2b48:	6f 8a       	std	Y+23, r6	; 0x17
    2b4a:	78 8e       	std	Y+24, r7	; 0x18
    2b4c:	81 e0       	ldi	r24, 0x01	; 1
    2b4e:	a8 1a       	sub	r10, r24
    2b50:	b1 08       	sbc	r11, r1
    2b52:	a6 0c       	add	r10, r6
    2b54:	b7 1c       	adc	r11, r7
    2b56:	c1 14       	cp	r12, r1
    2b58:	d1 04       	cpc	r13, r1
    2b5a:	21 f4       	brne	.+8      	; 0x2b64 <xTaskCreate+0x5c>
    2b5c:	1f c0       	rjmp	.+62     	; 0x2b9c <xTaskCreate+0x94>
    2b5e:	c3 01       	movw	r24, r6
    2b60:	df dc       	rcall	.-1602   	; 0x2520 <vPortFree>
    2b62:	bf c0       	rjmp	.+382    	; 0x2ce2 <xTaskCreate+0x1da>
    2b64:	d6 01       	movw	r26, r12
    2b66:	8c 91       	ld	r24, X
    2b68:	89 8f       	std	Y+25, r24	; 0x19
    2b6a:	8c 91       	ld	r24, X
    2b6c:	88 23       	and	r24, r24
    2b6e:	a1 f0       	breq	.+40     	; 0x2b98 <xTaskCreate+0x90>
    2b70:	ae 01       	movw	r20, r28
    2b72:	46 5e       	subi	r20, 0xE6	; 230
    2b74:	5f 4f       	sbci	r21, 0xFF	; 255
    2b76:	f6 01       	movw	r30, r12
    2b78:	31 96       	adiw	r30, 0x01	; 1
    2b7a:	b8 e0       	ldi	r27, 0x08	; 8
    2b7c:	cb 0e       	add	r12, r27
    2b7e:	d1 1c       	adc	r13, r1
    2b80:	cf 01       	movw	r24, r30
    2b82:	21 91       	ld	r18, Z+
    2b84:	da 01       	movw	r26, r20
    2b86:	2d 93       	st	X+, r18
    2b88:	ad 01       	movw	r20, r26
    2b8a:	dc 01       	movw	r26, r24
    2b8c:	8c 91       	ld	r24, X
    2b8e:	88 23       	and	r24, r24
    2b90:	19 f0       	breq	.+6      	; 0x2b98 <xTaskCreate+0x90>
    2b92:	ce 16       	cp	r12, r30
    2b94:	df 06       	cpc	r13, r31
    2b96:	a1 f7       	brne	.-24     	; 0x2b80 <xTaskCreate+0x78>
    2b98:	18 a2       	std	Y+32, r1	; 0x20
    2b9a:	01 c0       	rjmp	.+2      	; 0x2b9e <xTaskCreate+0x96>
    2b9c:	19 8e       	std	Y+25, r1	; 0x19
    2b9e:	05 30       	cpi	r16, 0x05	; 5
    2ba0:	08 f0       	brcs	.+2      	; 0x2ba4 <xTaskCreate+0x9c>
    2ba2:	04 e0       	ldi	r16, 0x04	; 4
    2ba4:	0e 8b       	std	Y+22, r16	; 0x16
    2ba6:	6e 01       	movw	r12, r28
    2ba8:	b2 e0       	ldi	r27, 0x02	; 2
    2baa:	cb 0e       	add	r12, r27
    2bac:	d1 1c       	adc	r13, r1
    2bae:	c6 01       	movw	r24, r12
    2bb0:	bf da       	rcall	.-2690   	; 0x2130 <vListInitialiseItem>
    2bb2:	ce 01       	movw	r24, r28
    2bb4:	0c 96       	adiw	r24, 0x0c	; 12
    2bb6:	bc da       	rcall	.-2696   	; 0x2130 <vListInitialiseItem>
    2bb8:	c8 87       	std	Y+8, r28	; 0x08
    2bba:	d9 87       	std	Y+9, r29	; 0x09
    2bbc:	85 e0       	ldi	r24, 0x05	; 5
    2bbe:	90 e0       	ldi	r25, 0x00	; 0
    2bc0:	80 1b       	sub	r24, r16
    2bc2:	91 09       	sbc	r25, r1
    2bc4:	8c 87       	std	Y+12, r24	; 0x0c
    2bc6:	9d 87       	std	Y+13, r25	; 0x0d
    2bc8:	ca 8b       	std	Y+18, r28	; 0x12
    2bca:	db 8b       	std	Y+19, r29	; 0x13
    2bcc:	19 a2       	std	Y+33, r1	; 0x21
    2bce:	1a a2       	std	Y+34, r1	; 0x22
    2bd0:	1b a2       	std	Y+35, r1	; 0x23
    2bd2:	1c a2       	std	Y+36, r1	; 0x24
    2bd4:	1d a2       	std	Y+37, r1	; 0x25
    2bd6:	a2 01       	movw	r20, r4
    2bd8:	b4 01       	movw	r22, r8
    2bda:	c5 01       	movw	r24, r10
    2bdc:	26 db       	rcall	.-2484   	; 0x222a <pxPortInitialiseStack>
    2bde:	88 83       	st	Y, r24
    2be0:	99 83       	std	Y+1, r25	; 0x01
    2be2:	e1 14       	cp	r14, r1
    2be4:	f1 04       	cpc	r15, r1
    2be6:	19 f0       	breq	.+6      	; 0x2bee <xTaskCreate+0xe6>
    2be8:	f7 01       	movw	r30, r14
    2bea:	c0 83       	st	Z, r28
    2bec:	d1 83       	std	Z+1, r29	; 0x01
    2bee:	0f b6       	in	r0, 0x3f	; 63
    2bf0:	f8 94       	cli
    2bf2:	0f 92       	push	r0
    2bf4:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <uxCurrentNumberOfTasks>
    2bf8:	8f 5f       	subi	r24, 0xFF	; 255
    2bfa:	80 93 67 22 	sts	0x2267, r24	; 0x802267 <uxCurrentNumberOfTasks>
    2bfe:	80 91 b4 22 	lds	r24, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2c02:	90 91 b5 22 	lds	r25, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2c06:	89 2b       	or	r24, r25
    2c08:	69 f5       	brne	.+90     	; 0x2c64 <xTaskCreate+0x15c>
    2c0a:	c0 93 b4 22 	sts	0x22B4, r28	; 0x8022b4 <pxCurrentTCB>
    2c0e:	d0 93 b5 22 	sts	0x22B5, r29	; 0x8022b5 <pxCurrentTCB+0x1>
    2c12:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <uxCurrentNumberOfTasks>
    2c16:	81 30       	cpi	r24, 0x01	; 1
    2c18:	a9 f5       	brne	.+106    	; 0x2c84 <xTaskCreate+0x17c>
    2c1a:	07 e8       	ldi	r16, 0x87	; 135
    2c1c:	12 e2       	ldi	r17, 0x22	; 34
    2c1e:	0f 2e       	mov	r0, r31
    2c20:	f4 eb       	ldi	r31, 0xB4	; 180
    2c22:	ef 2e       	mov	r14, r31
    2c24:	f2 e2       	ldi	r31, 0x22	; 34
    2c26:	ff 2e       	mov	r15, r31
    2c28:	f0 2d       	mov	r31, r0
    2c2a:	c8 01       	movw	r24, r16
    2c2c:	73 da       	rcall	.-2842   	; 0x2114 <vListInitialise>
    2c2e:	07 5f       	subi	r16, 0xF7	; 247
    2c30:	1f 4f       	sbci	r17, 0xFF	; 255
    2c32:	0e 15       	cp	r16, r14
    2c34:	1f 05       	cpc	r17, r15
    2c36:	c9 f7       	brne	.-14     	; 0x2c2a <xTaskCreate+0x122>
    2c38:	8e e7       	ldi	r24, 0x7E	; 126
    2c3a:	92 e2       	ldi	r25, 0x22	; 34
    2c3c:	6b da       	rcall	.-2858   	; 0x2114 <vListInitialise>
    2c3e:	85 e7       	ldi	r24, 0x75	; 117
    2c40:	92 e2       	ldi	r25, 0x22	; 34
    2c42:	68 da       	rcall	.-2864   	; 0x2114 <vListInitialise>
    2c44:	88 e6       	ldi	r24, 0x68	; 104
    2c46:	92 e2       	ldi	r25, 0x22	; 34
    2c48:	65 da       	rcall	.-2870   	; 0x2114 <vListInitialise>
    2c4a:	8e e7       	ldi	r24, 0x7E	; 126
    2c4c:	92 e2       	ldi	r25, 0x22	; 34
    2c4e:	80 93 73 22 	sts	0x2273, r24	; 0x802273 <pxDelayedTaskList>
    2c52:	90 93 74 22 	sts	0x2274, r25	; 0x802274 <pxDelayedTaskList+0x1>
    2c56:	85 e7       	ldi	r24, 0x75	; 117
    2c58:	92 e2       	ldi	r25, 0x22	; 34
    2c5a:	80 93 71 22 	sts	0x2271, r24	; 0x802271 <pxOverflowDelayedTaskList>
    2c5e:	90 93 72 22 	sts	0x2272, r25	; 0x802272 <pxOverflowDelayedTaskList+0x1>
    2c62:	10 c0       	rjmp	.+32     	; 0x2c84 <xTaskCreate+0x17c>
    2c64:	80 91 63 22 	lds	r24, 0x2263	; 0x802263 <xSchedulerRunning>
    2c68:	81 11       	cpse	r24, r1
    2c6a:	0c c0       	rjmp	.+24     	; 0x2c84 <xTaskCreate+0x17c>
    2c6c:	e0 91 b4 22 	lds	r30, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2c70:	f0 91 b5 22 	lds	r31, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2c74:	96 89       	ldd	r25, Z+22	; 0x16
    2c76:	8e 89       	ldd	r24, Y+22	; 0x16
    2c78:	89 17       	cp	r24, r25
    2c7a:	20 f0       	brcs	.+8      	; 0x2c84 <xTaskCreate+0x17c>
    2c7c:	c0 93 b4 22 	sts	0x22B4, r28	; 0x8022b4 <pxCurrentTCB>
    2c80:	d0 93 b5 22 	sts	0x22B5, r29	; 0x8022b5 <pxCurrentTCB+0x1>
    2c84:	80 91 5e 22 	lds	r24, 0x225E	; 0x80225e <uxTaskNumber>
    2c88:	8f 5f       	subi	r24, 0xFF	; 255
    2c8a:	80 93 5e 22 	sts	0x225E, r24	; 0x80225e <uxTaskNumber>
    2c8e:	8e 89       	ldd	r24, Y+22	; 0x16
    2c90:	90 91 64 22 	lds	r25, 0x2264	; 0x802264 <uxTopReadyPriority>
    2c94:	98 17       	cp	r25, r24
    2c96:	10 f4       	brcc	.+4      	; 0x2c9c <xTaskCreate+0x194>
    2c98:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <uxTopReadyPriority>
    2c9c:	90 e0       	ldi	r25, 0x00	; 0
    2c9e:	9c 01       	movw	r18, r24
    2ca0:	22 0f       	add	r18, r18
    2ca2:	33 1f       	adc	r19, r19
    2ca4:	22 0f       	add	r18, r18
    2ca6:	33 1f       	adc	r19, r19
    2ca8:	22 0f       	add	r18, r18
    2caa:	33 1f       	adc	r19, r19
    2cac:	82 0f       	add	r24, r18
    2cae:	93 1f       	adc	r25, r19
    2cb0:	b6 01       	movw	r22, r12
    2cb2:	89 57       	subi	r24, 0x79	; 121
    2cb4:	9d 4d       	sbci	r25, 0xDD	; 221
    2cb6:	40 da       	rcall	.-2944   	; 0x2138 <vListInsertEnd>
    2cb8:	0f 90       	pop	r0
    2cba:	0f be       	out	0x3f, r0	; 63
    2cbc:	80 91 63 22 	lds	r24, 0x2263	; 0x802263 <xSchedulerRunning>
    2cc0:	88 23       	and	r24, r24
    2cc2:	59 f0       	breq	.+22     	; 0x2cda <xTaskCreate+0x1d2>
    2cc4:	e0 91 b4 22 	lds	r30, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2cc8:	f0 91 b5 22 	lds	r31, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2ccc:	96 89       	ldd	r25, Z+22	; 0x16
    2cce:	8e 89       	ldd	r24, Y+22	; 0x16
    2cd0:	98 17       	cp	r25, r24
    2cd2:	28 f4       	brcc	.+10     	; 0x2cde <xTaskCreate+0x1d6>
    2cd4:	66 db       	rcall	.-2356   	; 0x23a2 <vPortYield>
    2cd6:	81 e0       	ldi	r24, 0x01	; 1
    2cd8:	05 c0       	rjmp	.+10     	; 0x2ce4 <xTaskCreate+0x1dc>
    2cda:	81 e0       	ldi	r24, 0x01	; 1
    2cdc:	03 c0       	rjmp	.+6      	; 0x2ce4 <xTaskCreate+0x1dc>
    2cde:	81 e0       	ldi	r24, 0x01	; 1
    2ce0:	01 c0       	rjmp	.+2      	; 0x2ce4 <xTaskCreate+0x1dc>
    2ce2:	8f ef       	ldi	r24, 0xFF	; 255
    2ce4:	df 91       	pop	r29
    2ce6:	cf 91       	pop	r28
    2ce8:	1f 91       	pop	r17
    2cea:	0f 91       	pop	r16
    2cec:	ff 90       	pop	r15
    2cee:	ef 90       	pop	r14
    2cf0:	df 90       	pop	r13
    2cf2:	cf 90       	pop	r12
    2cf4:	bf 90       	pop	r11
    2cf6:	af 90       	pop	r10
    2cf8:	9f 90       	pop	r9
    2cfa:	8f 90       	pop	r8
    2cfc:	7f 90       	pop	r7
    2cfe:	6f 90       	pop	r6
    2d00:	5f 90       	pop	r5
    2d02:	4f 90       	pop	r4
    2d04:	08 95       	ret

00002d06 <vTaskStartScheduler>:
    2d06:	ef 92       	push	r14
    2d08:	ff 92       	push	r15
    2d0a:	0f 93       	push	r16
    2d0c:	0f 2e       	mov	r0, r31
    2d0e:	fa e5       	ldi	r31, 0x5A	; 90
    2d10:	ef 2e       	mov	r14, r31
    2d12:	f2 e2       	ldi	r31, 0x22	; 34
    2d14:	ff 2e       	mov	r15, r31
    2d16:	f0 2d       	mov	r31, r0
    2d18:	00 e0       	ldi	r16, 0x00	; 0
    2d1a:	20 e0       	ldi	r18, 0x00	; 0
    2d1c:	30 e0       	ldi	r19, 0x00	; 0
    2d1e:	45 e5       	ldi	r20, 0x55	; 85
    2d20:	50 e0       	ldi	r21, 0x00	; 0
    2d22:	64 e1       	ldi	r22, 0x14	; 20
    2d24:	70 e2       	ldi	r23, 0x20	; 32
    2d26:	8c e3       	ldi	r24, 0x3C	; 60
    2d28:	95 e1       	ldi	r25, 0x15	; 21
    2d2a:	ee de       	rcall	.-548    	; 0x2b08 <xTaskCreate>
    2d2c:	81 30       	cpi	r24, 0x01	; 1
    2d2e:	91 f4       	brne	.+36     	; 0x2d54 <vTaskStartScheduler+0x4e>
    2d30:	cc d2       	rcall	.+1432   	; 0x32ca <xTimerCreateTimerTask>
    2d32:	81 30       	cpi	r24, 0x01	; 1
    2d34:	79 f4       	brne	.+30     	; 0x2d54 <vTaskStartScheduler+0x4e>
    2d36:	f8 94       	cli
    2d38:	8f ef       	ldi	r24, 0xFF	; 255
    2d3a:	9f ef       	ldi	r25, 0xFF	; 255
    2d3c:	80 93 5c 22 	sts	0x225C, r24	; 0x80225c <xNextTaskUnblockTime>
    2d40:	90 93 5d 22 	sts	0x225D, r25	; 0x80225d <xNextTaskUnblockTime+0x1>
    2d44:	81 e0       	ldi	r24, 0x01	; 1
    2d46:	80 93 63 22 	sts	0x2263, r24	; 0x802263 <xSchedulerRunning>
    2d4a:	10 92 65 22 	sts	0x2265, r1	; 0x802265 <xTickCount>
    2d4e:	10 92 66 22 	sts	0x2266, r1	; 0x802266 <xTickCount+0x1>
    2d52:	e2 da       	rcall	.-2620   	; 0x2318 <xPortStartScheduler>
    2d54:	0f 91       	pop	r16
    2d56:	ff 90       	pop	r15
    2d58:	ef 90       	pop	r14
    2d5a:	08 95       	ret

00002d5c <vTaskSuspendAll>:
    2d5c:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <uxSchedulerSuspended>
    2d60:	8f 5f       	subi	r24, 0xFF	; 255
    2d62:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <uxSchedulerSuspended>
    2d66:	08 95       	ret

00002d68 <xTaskGetTickCount>:
    2d68:	0f b6       	in	r0, 0x3f	; 63
    2d6a:	f8 94       	cli
    2d6c:	0f 92       	push	r0
    2d6e:	80 91 65 22 	lds	r24, 0x2265	; 0x802265 <xTickCount>
    2d72:	90 91 66 22 	lds	r25, 0x2266	; 0x802266 <xTickCount+0x1>
    2d76:	0f 90       	pop	r0
    2d78:	0f be       	out	0x3f, r0	; 63
    2d7a:	08 95       	ret

00002d7c <xTaskIncrementTick>:
    2d7c:	df 92       	push	r13
    2d7e:	ef 92       	push	r14
    2d80:	ff 92       	push	r15
    2d82:	0f 93       	push	r16
    2d84:	1f 93       	push	r17
    2d86:	cf 93       	push	r28
    2d88:	df 93       	push	r29
    2d8a:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <uxSchedulerSuspended>
    2d8e:	81 11       	cpse	r24, r1
    2d90:	9a c0       	rjmp	.+308    	; 0x2ec6 <xTaskIncrementTick+0x14a>
    2d92:	e0 90 65 22 	lds	r14, 0x2265	; 0x802265 <xTickCount>
    2d96:	f0 90 66 22 	lds	r15, 0x2266	; 0x802266 <xTickCount+0x1>
    2d9a:	8f ef       	ldi	r24, 0xFF	; 255
    2d9c:	e8 1a       	sub	r14, r24
    2d9e:	f8 0a       	sbc	r15, r24
    2da0:	e0 92 65 22 	sts	0x2265, r14	; 0x802265 <xTickCount>
    2da4:	f0 92 66 22 	sts	0x2266, r15	; 0x802266 <xTickCount+0x1>
    2da8:	e1 14       	cp	r14, r1
    2daa:	f1 04       	cpc	r15, r1
    2dac:	b1 f4       	brne	.+44     	; 0x2dda <xTaskIncrementTick+0x5e>
    2dae:	80 91 73 22 	lds	r24, 0x2273	; 0x802273 <pxDelayedTaskList>
    2db2:	90 91 74 22 	lds	r25, 0x2274	; 0x802274 <pxDelayedTaskList+0x1>
    2db6:	20 91 71 22 	lds	r18, 0x2271	; 0x802271 <pxOverflowDelayedTaskList>
    2dba:	30 91 72 22 	lds	r19, 0x2272	; 0x802272 <pxOverflowDelayedTaskList+0x1>
    2dbe:	20 93 73 22 	sts	0x2273, r18	; 0x802273 <pxDelayedTaskList>
    2dc2:	30 93 74 22 	sts	0x2274, r19	; 0x802274 <pxDelayedTaskList+0x1>
    2dc6:	80 93 71 22 	sts	0x2271, r24	; 0x802271 <pxOverflowDelayedTaskList>
    2dca:	90 93 72 22 	sts	0x2272, r25	; 0x802272 <pxOverflowDelayedTaskList+0x1>
    2dce:	80 91 5f 22 	lds	r24, 0x225F	; 0x80225f <xNumOfOverflows>
    2dd2:	8f 5f       	subi	r24, 0xFF	; 255
    2dd4:	80 93 5f 22 	sts	0x225F, r24	; 0x80225f <xNumOfOverflows>
    2dd8:	30 de       	rcall	.-928    	; 0x2a3a <prvResetNextTaskUnblockTime>
    2dda:	80 91 5c 22 	lds	r24, 0x225C	; 0x80225c <xNextTaskUnblockTime>
    2dde:	90 91 5d 22 	lds	r25, 0x225D	; 0x80225d <xNextTaskUnblockTime+0x1>
    2de2:	e8 16       	cp	r14, r24
    2de4:	f9 06       	cpc	r15, r25
    2de6:	10 f4       	brcc	.+4      	; 0x2dec <xTaskIncrementTick+0x70>
    2de8:	d1 2c       	mov	r13, r1
    2dea:	4f c0       	rjmp	.+158    	; 0x2e8a <xTaskIncrementTick+0x10e>
    2dec:	d1 2c       	mov	r13, r1
    2dee:	e0 91 73 22 	lds	r30, 0x2273	; 0x802273 <pxDelayedTaskList>
    2df2:	f0 91 74 22 	lds	r31, 0x2274	; 0x802274 <pxDelayedTaskList+0x1>
    2df6:	80 81       	ld	r24, Z
    2df8:	81 11       	cpse	r24, r1
    2dfa:	07 c0       	rjmp	.+14     	; 0x2e0a <xTaskIncrementTick+0x8e>
    2dfc:	8f ef       	ldi	r24, 0xFF	; 255
    2dfe:	9f ef       	ldi	r25, 0xFF	; 255
    2e00:	80 93 5c 22 	sts	0x225C, r24	; 0x80225c <xNextTaskUnblockTime>
    2e04:	90 93 5d 22 	sts	0x225D, r25	; 0x80225d <xNextTaskUnblockTime+0x1>
    2e08:	40 c0       	rjmp	.+128    	; 0x2e8a <xTaskIncrementTick+0x10e>
    2e0a:	e0 91 73 22 	lds	r30, 0x2273	; 0x802273 <pxDelayedTaskList>
    2e0e:	f0 91 74 22 	lds	r31, 0x2274	; 0x802274 <pxDelayedTaskList+0x1>
    2e12:	05 80       	ldd	r0, Z+5	; 0x05
    2e14:	f6 81       	ldd	r31, Z+6	; 0x06
    2e16:	e0 2d       	mov	r30, r0
    2e18:	c6 81       	ldd	r28, Z+6	; 0x06
    2e1a:	d7 81       	ldd	r29, Z+7	; 0x07
    2e1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e20:	e8 16       	cp	r14, r24
    2e22:	f9 06       	cpc	r15, r25
    2e24:	28 f4       	brcc	.+10     	; 0x2e30 <xTaskIncrementTick+0xb4>
    2e26:	80 93 5c 22 	sts	0x225C, r24	; 0x80225c <xNextTaskUnblockTime>
    2e2a:	90 93 5d 22 	sts	0x225D, r25	; 0x80225d <xNextTaskUnblockTime+0x1>
    2e2e:	2d c0       	rjmp	.+90     	; 0x2e8a <xTaskIncrementTick+0x10e>
    2e30:	8e 01       	movw	r16, r28
    2e32:	0e 5f       	subi	r16, 0xFE	; 254
    2e34:	1f 4f       	sbci	r17, 0xFF	; 255
    2e36:	c8 01       	movw	r24, r16
    2e38:	d1 d9       	rcall	.-3166   	; 0x21dc <uxListRemove>
    2e3a:	8c 89       	ldd	r24, Y+20	; 0x14
    2e3c:	9d 89       	ldd	r25, Y+21	; 0x15
    2e3e:	89 2b       	or	r24, r25
    2e40:	19 f0       	breq	.+6      	; 0x2e48 <xTaskIncrementTick+0xcc>
    2e42:	ce 01       	movw	r24, r28
    2e44:	0c 96       	adiw	r24, 0x0c	; 12
    2e46:	ca d9       	rcall	.-3180   	; 0x21dc <uxListRemove>
    2e48:	8e 89       	ldd	r24, Y+22	; 0x16
    2e4a:	90 91 64 22 	lds	r25, 0x2264	; 0x802264 <uxTopReadyPriority>
    2e4e:	98 17       	cp	r25, r24
    2e50:	10 f4       	brcc	.+4      	; 0x2e56 <xTaskIncrementTick+0xda>
    2e52:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <uxTopReadyPriority>
    2e56:	90 e0       	ldi	r25, 0x00	; 0
    2e58:	9c 01       	movw	r18, r24
    2e5a:	22 0f       	add	r18, r18
    2e5c:	33 1f       	adc	r19, r19
    2e5e:	22 0f       	add	r18, r18
    2e60:	33 1f       	adc	r19, r19
    2e62:	22 0f       	add	r18, r18
    2e64:	33 1f       	adc	r19, r19
    2e66:	82 0f       	add	r24, r18
    2e68:	93 1f       	adc	r25, r19
    2e6a:	b8 01       	movw	r22, r16
    2e6c:	89 57       	subi	r24, 0x79	; 121
    2e6e:	9d 4d       	sbci	r25, 0xDD	; 221
    2e70:	63 d9       	rcall	.-3386   	; 0x2138 <vListInsertEnd>
    2e72:	e0 91 b4 22 	lds	r30, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2e76:	f0 91 b5 22 	lds	r31, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2e7a:	9e 89       	ldd	r25, Y+22	; 0x16
    2e7c:	86 89       	ldd	r24, Z+22	; 0x16
    2e7e:	98 17       	cp	r25, r24
    2e80:	08 f4       	brcc	.+2      	; 0x2e84 <xTaskIncrementTick+0x108>
    2e82:	b5 cf       	rjmp	.-150    	; 0x2dee <xTaskIncrementTick+0x72>
    2e84:	dd 24       	eor	r13, r13
    2e86:	d3 94       	inc	r13
    2e88:	b2 cf       	rjmp	.-156    	; 0x2dee <xTaskIncrementTick+0x72>
    2e8a:	e0 91 b4 22 	lds	r30, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2e8e:	f0 91 b5 22 	lds	r31, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2e92:	86 89       	ldd	r24, Z+22	; 0x16
    2e94:	90 e0       	ldi	r25, 0x00	; 0
    2e96:	fc 01       	movw	r30, r24
    2e98:	ee 0f       	add	r30, r30
    2e9a:	ff 1f       	adc	r31, r31
    2e9c:	ee 0f       	add	r30, r30
    2e9e:	ff 1f       	adc	r31, r31
    2ea0:	ee 0f       	add	r30, r30
    2ea2:	ff 1f       	adc	r31, r31
    2ea4:	8e 0f       	add	r24, r30
    2ea6:	9f 1f       	adc	r25, r31
    2ea8:	fc 01       	movw	r30, r24
    2eaa:	e9 57       	subi	r30, 0x79	; 121
    2eac:	fd 4d       	sbci	r31, 0xDD	; 221
    2eae:	80 81       	ld	r24, Z
    2eb0:	82 30       	cpi	r24, 0x02	; 2
    2eb2:	10 f0       	brcs	.+4      	; 0x2eb8 <xTaskIncrementTick+0x13c>
    2eb4:	dd 24       	eor	r13, r13
    2eb6:	d3 94       	inc	r13
    2eb8:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <xYieldPending>
    2ebc:	88 23       	and	r24, r24
    2ebe:	69 f0       	breq	.+26     	; 0x2eda <xTaskIncrementTick+0x15e>
    2ec0:	dd 24       	eor	r13, r13
    2ec2:	d3 94       	inc	r13
    2ec4:	0a c0       	rjmp	.+20     	; 0x2eda <xTaskIncrementTick+0x15e>
    2ec6:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <xPendedTicks>
    2eca:	90 91 62 22 	lds	r25, 0x2262	; 0x802262 <xPendedTicks+0x1>
    2ece:	01 96       	adiw	r24, 0x01	; 1
    2ed0:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <xPendedTicks>
    2ed4:	90 93 62 22 	sts	0x2262, r25	; 0x802262 <xPendedTicks+0x1>
    2ed8:	d1 2c       	mov	r13, r1
    2eda:	8d 2d       	mov	r24, r13
    2edc:	df 91       	pop	r29
    2ede:	cf 91       	pop	r28
    2ee0:	1f 91       	pop	r17
    2ee2:	0f 91       	pop	r16
    2ee4:	ff 90       	pop	r15
    2ee6:	ef 90       	pop	r14
    2ee8:	df 90       	pop	r13
    2eea:	08 95       	ret

00002eec <xTaskResumeAll>:
    2eec:	df 92       	push	r13
    2eee:	ef 92       	push	r14
    2ef0:	ff 92       	push	r15
    2ef2:	0f 93       	push	r16
    2ef4:	1f 93       	push	r17
    2ef6:	cf 93       	push	r28
    2ef8:	df 93       	push	r29
    2efa:	0f b6       	in	r0, 0x3f	; 63
    2efc:	f8 94       	cli
    2efe:	0f 92       	push	r0
    2f00:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <uxSchedulerSuspended>
    2f04:	81 50       	subi	r24, 0x01	; 1
    2f06:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <uxSchedulerSuspended>
    2f0a:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <uxSchedulerSuspended>
    2f0e:	81 11       	cpse	r24, r1
    2f10:	5d c0       	rjmp	.+186    	; 0x2fcc <xTaskResumeAll+0xe0>
    2f12:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <uxCurrentNumberOfTasks>
    2f16:	81 11       	cpse	r24, r1
    2f18:	30 c0       	rjmp	.+96     	; 0x2f7a <xTaskResumeAll+0x8e>
    2f1a:	5b c0       	rjmp	.+182    	; 0x2fd2 <xTaskResumeAll+0xe6>
    2f1c:	d7 01       	movw	r26, r14
    2f1e:	15 96       	adiw	r26, 0x05	; 5
    2f20:	ed 91       	ld	r30, X+
    2f22:	fc 91       	ld	r31, X
    2f24:	16 97       	sbiw	r26, 0x06	; 6
    2f26:	c6 81       	ldd	r28, Z+6	; 0x06
    2f28:	d7 81       	ldd	r29, Z+7	; 0x07
    2f2a:	ce 01       	movw	r24, r28
    2f2c:	0c 96       	adiw	r24, 0x0c	; 12
    2f2e:	56 d9       	rcall	.-3412   	; 0x21dc <uxListRemove>
    2f30:	8e 01       	movw	r16, r28
    2f32:	0e 5f       	subi	r16, 0xFE	; 254
    2f34:	1f 4f       	sbci	r17, 0xFF	; 255
    2f36:	c8 01       	movw	r24, r16
    2f38:	51 d9       	rcall	.-3422   	; 0x21dc <uxListRemove>
    2f3a:	8e 89       	ldd	r24, Y+22	; 0x16
    2f3c:	90 91 64 22 	lds	r25, 0x2264	; 0x802264 <uxTopReadyPriority>
    2f40:	98 17       	cp	r25, r24
    2f42:	10 f4       	brcc	.+4      	; 0x2f48 <xTaskResumeAll+0x5c>
    2f44:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <uxTopReadyPriority>
    2f48:	90 e0       	ldi	r25, 0x00	; 0
    2f4a:	9c 01       	movw	r18, r24
    2f4c:	22 0f       	add	r18, r18
    2f4e:	33 1f       	adc	r19, r19
    2f50:	22 0f       	add	r18, r18
    2f52:	33 1f       	adc	r19, r19
    2f54:	22 0f       	add	r18, r18
    2f56:	33 1f       	adc	r19, r19
    2f58:	82 0f       	add	r24, r18
    2f5a:	93 1f       	adc	r25, r19
    2f5c:	b8 01       	movw	r22, r16
    2f5e:	89 57       	subi	r24, 0x79	; 121
    2f60:	9d 4d       	sbci	r25, 0xDD	; 221
    2f62:	ea d8       	rcall	.-3628   	; 0x2138 <vListInsertEnd>
    2f64:	e0 91 b4 22 	lds	r30, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    2f68:	f0 91 b5 22 	lds	r31, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    2f6c:	9e 89       	ldd	r25, Y+22	; 0x16
    2f6e:	86 89       	ldd	r24, Z+22	; 0x16
    2f70:	98 17       	cp	r25, r24
    2f72:	68 f0       	brcs	.+26     	; 0x2f8e <xTaskResumeAll+0xa2>
    2f74:	d0 92 60 22 	sts	0x2260, r13	; 0x802260 <xYieldPending>
    2f78:	0a c0       	rjmp	.+20     	; 0x2f8e <xTaskResumeAll+0xa2>
    2f7a:	c0 e0       	ldi	r28, 0x00	; 0
    2f7c:	d0 e0       	ldi	r29, 0x00	; 0
    2f7e:	0f 2e       	mov	r0, r31
    2f80:	f8 e6       	ldi	r31, 0x68	; 104
    2f82:	ef 2e       	mov	r14, r31
    2f84:	f2 e2       	ldi	r31, 0x22	; 34
    2f86:	ff 2e       	mov	r15, r31
    2f88:	f0 2d       	mov	r31, r0
    2f8a:	dd 24       	eor	r13, r13
    2f8c:	d3 94       	inc	r13
    2f8e:	f7 01       	movw	r30, r14
    2f90:	80 81       	ld	r24, Z
    2f92:	81 11       	cpse	r24, r1
    2f94:	c3 cf       	rjmp	.-122    	; 0x2f1c <xTaskResumeAll+0x30>
    2f96:	cd 2b       	or	r28, r29
    2f98:	09 f0       	breq	.+2      	; 0x2f9c <xTaskResumeAll+0xb0>
    2f9a:	4f dd       	rcall	.-1378   	; 0x2a3a <prvResetNextTaskUnblockTime>
    2f9c:	c0 91 61 22 	lds	r28, 0x2261	; 0x802261 <xPendedTicks>
    2fa0:	d0 91 62 22 	lds	r29, 0x2262	; 0x802262 <xPendedTicks+0x1>
    2fa4:	20 97       	sbiw	r28, 0x00	; 0
    2fa6:	59 f0       	breq	.+22     	; 0x2fbe <xTaskResumeAll+0xd2>
    2fa8:	11 e0       	ldi	r17, 0x01	; 1
    2faa:	e8 de       	rcall	.-560    	; 0x2d7c <xTaskIncrementTick>
    2fac:	81 11       	cpse	r24, r1
    2fae:	10 93 60 22 	sts	0x2260, r17	; 0x802260 <xYieldPending>
    2fb2:	21 97       	sbiw	r28, 0x01	; 1
    2fb4:	d1 f7       	brne	.-12     	; 0x2faa <xTaskResumeAll+0xbe>
    2fb6:	10 92 61 22 	sts	0x2261, r1	; 0x802261 <xPendedTicks>
    2fba:	10 92 62 22 	sts	0x2262, r1	; 0x802262 <xPendedTicks+0x1>
    2fbe:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <xYieldPending>
    2fc2:	88 23       	and	r24, r24
    2fc4:	29 f0       	breq	.+10     	; 0x2fd0 <xTaskResumeAll+0xe4>
    2fc6:	ed d9       	rcall	.-3110   	; 0x23a2 <vPortYield>
    2fc8:	81 e0       	ldi	r24, 0x01	; 1
    2fca:	03 c0       	rjmp	.+6      	; 0x2fd2 <xTaskResumeAll+0xe6>
    2fcc:	80 e0       	ldi	r24, 0x00	; 0
    2fce:	01 c0       	rjmp	.+2      	; 0x2fd2 <xTaskResumeAll+0xe6>
    2fd0:	80 e0       	ldi	r24, 0x00	; 0
    2fd2:	0f 90       	pop	r0
    2fd4:	0f be       	out	0x3f, r0	; 63
    2fd6:	df 91       	pop	r29
    2fd8:	cf 91       	pop	r28
    2fda:	1f 91       	pop	r17
    2fdc:	0f 91       	pop	r16
    2fde:	ff 90       	pop	r15
    2fe0:	ef 90       	pop	r14
    2fe2:	df 90       	pop	r13
    2fe4:	08 95       	ret

00002fe6 <vTaskSwitchContext>:
    2fe6:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <uxSchedulerSuspended>
    2fea:	88 23       	and	r24, r24
    2fec:	21 f0       	breq	.+8      	; 0x2ff6 <vTaskSwitchContext+0x10>
    2fee:	81 e0       	ldi	r24, 0x01	; 1
    2ff0:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <xYieldPending>
    2ff4:	08 95       	ret
    2ff6:	10 92 60 22 	sts	0x2260, r1	; 0x802260 <xYieldPending>
    2ffa:	20 91 64 22 	lds	r18, 0x2264	; 0x802264 <uxTopReadyPriority>
    2ffe:	82 2f       	mov	r24, r18
    3000:	90 e0       	ldi	r25, 0x00	; 0
    3002:	fc 01       	movw	r30, r24
    3004:	ee 0f       	add	r30, r30
    3006:	ff 1f       	adc	r31, r31
    3008:	ee 0f       	add	r30, r30
    300a:	ff 1f       	adc	r31, r31
    300c:	ee 0f       	add	r30, r30
    300e:	ff 1f       	adc	r31, r31
    3010:	e8 0f       	add	r30, r24
    3012:	f9 1f       	adc	r31, r25
    3014:	e9 57       	subi	r30, 0x79	; 121
    3016:	fd 4d       	sbci	r31, 0xDD	; 221
    3018:	30 81       	ld	r19, Z
    301a:	31 11       	cpse	r19, r1
    301c:	11 c0       	rjmp	.+34     	; 0x3040 <vTaskSwitchContext+0x5a>
    301e:	21 50       	subi	r18, 0x01	; 1
    3020:	82 2f       	mov	r24, r18
    3022:	90 e0       	ldi	r25, 0x00	; 0
    3024:	fc 01       	movw	r30, r24
    3026:	ee 0f       	add	r30, r30
    3028:	ff 1f       	adc	r31, r31
    302a:	ee 0f       	add	r30, r30
    302c:	ff 1f       	adc	r31, r31
    302e:	ee 0f       	add	r30, r30
    3030:	ff 1f       	adc	r31, r31
    3032:	e8 0f       	add	r30, r24
    3034:	f9 1f       	adc	r31, r25
    3036:	e9 57       	subi	r30, 0x79	; 121
    3038:	fd 4d       	sbci	r31, 0xDD	; 221
    303a:	30 81       	ld	r19, Z
    303c:	33 23       	and	r19, r19
    303e:	79 f3       	breq	.-34     	; 0x301e <vTaskSwitchContext+0x38>
    3040:	ac 01       	movw	r20, r24
    3042:	44 0f       	add	r20, r20
    3044:	55 1f       	adc	r21, r21
    3046:	44 0f       	add	r20, r20
    3048:	55 1f       	adc	r21, r21
    304a:	44 0f       	add	r20, r20
    304c:	55 1f       	adc	r21, r21
    304e:	48 0f       	add	r20, r24
    3050:	59 1f       	adc	r21, r25
    3052:	da 01       	movw	r26, r20
    3054:	a9 57       	subi	r26, 0x79	; 121
    3056:	bd 4d       	sbci	r27, 0xDD	; 221
    3058:	11 96       	adiw	r26, 0x01	; 1
    305a:	ed 91       	ld	r30, X+
    305c:	fc 91       	ld	r31, X
    305e:	12 97       	sbiw	r26, 0x02	; 2
    3060:	02 80       	ldd	r0, Z+2	; 0x02
    3062:	f3 81       	ldd	r31, Z+3	; 0x03
    3064:	e0 2d       	mov	r30, r0
    3066:	11 96       	adiw	r26, 0x01	; 1
    3068:	ed 93       	st	X+, r30
    306a:	fc 93       	st	X, r31
    306c:	12 97       	sbiw	r26, 0x02	; 2
    306e:	46 57       	subi	r20, 0x76	; 118
    3070:	5d 4d       	sbci	r21, 0xDD	; 221
    3072:	e4 17       	cp	r30, r20
    3074:	f5 07       	cpc	r31, r21
    3076:	29 f4       	brne	.+10     	; 0x3082 <vTaskSwitchContext+0x9c>
    3078:	42 81       	ldd	r20, Z+2	; 0x02
    307a:	53 81       	ldd	r21, Z+3	; 0x03
    307c:	fd 01       	movw	r30, r26
    307e:	41 83       	std	Z+1, r20	; 0x01
    3080:	52 83       	std	Z+2, r21	; 0x02
    3082:	fc 01       	movw	r30, r24
    3084:	ee 0f       	add	r30, r30
    3086:	ff 1f       	adc	r31, r31
    3088:	ee 0f       	add	r30, r30
    308a:	ff 1f       	adc	r31, r31
    308c:	ee 0f       	add	r30, r30
    308e:	ff 1f       	adc	r31, r31
    3090:	8e 0f       	add	r24, r30
    3092:	9f 1f       	adc	r25, r31
    3094:	fc 01       	movw	r30, r24
    3096:	e9 57       	subi	r30, 0x79	; 121
    3098:	fd 4d       	sbci	r31, 0xDD	; 221
    309a:	01 80       	ldd	r0, Z+1	; 0x01
    309c:	f2 81       	ldd	r31, Z+2	; 0x02
    309e:	e0 2d       	mov	r30, r0
    30a0:	86 81       	ldd	r24, Z+6	; 0x06
    30a2:	97 81       	ldd	r25, Z+7	; 0x07
    30a4:	80 93 b4 22 	sts	0x22B4, r24	; 0x8022b4 <pxCurrentTCB>
    30a8:	90 93 b5 22 	sts	0x22B5, r25	; 0x8022b5 <pxCurrentTCB+0x1>
    30ac:	20 93 64 22 	sts	0x2264, r18	; 0x802264 <uxTopReadyPriority>
    30b0:	08 95       	ret

000030b2 <vTaskPlaceOnEventList>:
    30b2:	cf 93       	push	r28
    30b4:	df 93       	push	r29
    30b6:	eb 01       	movw	r28, r22
    30b8:	60 91 b4 22 	lds	r22, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    30bc:	70 91 b5 22 	lds	r23, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    30c0:	64 5f       	subi	r22, 0xF4	; 244
    30c2:	7f 4f       	sbci	r23, 0xFF	; 255
    30c4:	5a d8       	rcall	.-3916   	; 0x217a <vListInsert>
    30c6:	61 e0       	ldi	r22, 0x01	; 1
    30c8:	ce 01       	movw	r24, r28
    30ca:	dd dc       	rcall	.-1606   	; 0x2a86 <prvAddCurrentTaskToDelayedList>
    30cc:	df 91       	pop	r29
    30ce:	cf 91       	pop	r28
    30d0:	08 95       	ret

000030d2 <vTaskPlaceOnEventListRestricted>:
    30d2:	0f 93       	push	r16
    30d4:	1f 93       	push	r17
    30d6:	cf 93       	push	r28
    30d8:	8b 01       	movw	r16, r22
    30da:	c4 2f       	mov	r28, r20
    30dc:	60 91 b4 22 	lds	r22, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    30e0:	70 91 b5 22 	lds	r23, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    30e4:	64 5f       	subi	r22, 0xF4	; 244
    30e6:	7f 4f       	sbci	r23, 0xFF	; 255
    30e8:	27 d8       	rcall	.-4018   	; 0x2138 <vListInsertEnd>
    30ea:	cc 23       	and	r28, r28
    30ec:	11 f0       	breq	.+4      	; 0x30f2 <vTaskPlaceOnEventListRestricted+0x20>
    30ee:	0f ef       	ldi	r16, 0xFF	; 255
    30f0:	1f ef       	ldi	r17, 0xFF	; 255
    30f2:	6c 2f       	mov	r22, r28
    30f4:	c8 01       	movw	r24, r16
    30f6:	c7 dc       	rcall	.-1650   	; 0x2a86 <prvAddCurrentTaskToDelayedList>
    30f8:	cf 91       	pop	r28
    30fa:	1f 91       	pop	r17
    30fc:	0f 91       	pop	r16
    30fe:	08 95       	ret

00003100 <xTaskRemoveFromEventList>:
    3100:	0f 93       	push	r16
    3102:	1f 93       	push	r17
    3104:	cf 93       	push	r28
    3106:	df 93       	push	r29
    3108:	dc 01       	movw	r26, r24
    310a:	15 96       	adiw	r26, 0x05	; 5
    310c:	ed 91       	ld	r30, X+
    310e:	fc 91       	ld	r31, X
    3110:	16 97       	sbiw	r26, 0x06	; 6
    3112:	c6 81       	ldd	r28, Z+6	; 0x06
    3114:	d7 81       	ldd	r29, Z+7	; 0x07
    3116:	8e 01       	movw	r16, r28
    3118:	04 5f       	subi	r16, 0xF4	; 244
    311a:	1f 4f       	sbci	r17, 0xFF	; 255
    311c:	c8 01       	movw	r24, r16
    311e:	5e d8       	rcall	.-3908   	; 0x21dc <uxListRemove>
    3120:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <uxSchedulerSuspended>
    3124:	81 11       	cpse	r24, r1
    3126:	1b c0       	rjmp	.+54     	; 0x315e <xTaskRemoveFromEventList+0x5e>
    3128:	0a 50       	subi	r16, 0x0A	; 10
    312a:	11 09       	sbc	r17, r1
    312c:	c8 01       	movw	r24, r16
    312e:	56 d8       	rcall	.-3924   	; 0x21dc <uxListRemove>
    3130:	8e 89       	ldd	r24, Y+22	; 0x16
    3132:	90 91 64 22 	lds	r25, 0x2264	; 0x802264 <uxTopReadyPriority>
    3136:	98 17       	cp	r25, r24
    3138:	10 f4       	brcc	.+4      	; 0x313e <xTaskRemoveFromEventList+0x3e>
    313a:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <uxTopReadyPriority>
    313e:	90 e0       	ldi	r25, 0x00	; 0
    3140:	9c 01       	movw	r18, r24
    3142:	22 0f       	add	r18, r18
    3144:	33 1f       	adc	r19, r19
    3146:	22 0f       	add	r18, r18
    3148:	33 1f       	adc	r19, r19
    314a:	22 0f       	add	r18, r18
    314c:	33 1f       	adc	r19, r19
    314e:	82 0f       	add	r24, r18
    3150:	93 1f       	adc	r25, r19
    3152:	b8 01       	movw	r22, r16
    3154:	89 57       	subi	r24, 0x79	; 121
    3156:	9d 4d       	sbci	r25, 0xDD	; 221
    3158:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInsertEnd>
    315c:	05 c0       	rjmp	.+10     	; 0x3168 <xTaskRemoveFromEventList+0x68>
    315e:	b8 01       	movw	r22, r16
    3160:	88 e6       	ldi	r24, 0x68	; 104
    3162:	92 e2       	ldi	r25, 0x22	; 34
    3164:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInsertEnd>
    3168:	e0 91 b4 22 	lds	r30, 0x22B4	; 0x8022b4 <pxCurrentTCB>
    316c:	f0 91 b5 22 	lds	r31, 0x22B5	; 0x8022b5 <pxCurrentTCB+0x1>
    3170:	9e 89       	ldd	r25, Y+22	; 0x16
    3172:	86 89       	ldd	r24, Z+22	; 0x16
    3174:	89 17       	cp	r24, r25
    3176:	20 f4       	brcc	.+8      	; 0x3180 <xTaskRemoveFromEventList+0x80>
    3178:	81 e0       	ldi	r24, 0x01	; 1
    317a:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <xYieldPending>
    317e:	01 c0       	rjmp	.+2      	; 0x3182 <xTaskRemoveFromEventList+0x82>
    3180:	80 e0       	ldi	r24, 0x00	; 0
    3182:	df 91       	pop	r29
    3184:	cf 91       	pop	r28
    3186:	1f 91       	pop	r17
    3188:	0f 91       	pop	r16
    318a:	08 95       	ret

0000318c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    318c:	20 91 5f 22 	lds	r18, 0x225F	; 0x80225f <xNumOfOverflows>
    3190:	fc 01       	movw	r30, r24
    3192:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    3194:	20 91 65 22 	lds	r18, 0x2265	; 0x802265 <xTickCount>
    3198:	30 91 66 22 	lds	r19, 0x2266	; 0x802266 <xTickCount+0x1>
    319c:	21 83       	std	Z+1, r18	; 0x01
    319e:	32 83       	std	Z+2, r19	; 0x02
    31a0:	08 95       	ret

000031a2 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    31a2:	0f b6       	in	r0, 0x3f	; 63
    31a4:	f8 94       	cli
    31a6:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    31a8:	20 91 65 22 	lds	r18, 0x2265	; 0x802265 <xTickCount>
    31ac:	30 91 66 22 	lds	r19, 0x2266	; 0x802266 <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    31b0:	dc 01       	movw	r26, r24
    31b2:	11 96       	adiw	r26, 0x01	; 1
    31b4:	4d 91       	ld	r20, X+
    31b6:	5c 91       	ld	r21, X
    31b8:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    31ba:	e0 91 5f 22 	lds	r30, 0x225F	; 0x80225f <xNumOfOverflows>
    31be:	fc 91       	ld	r31, X
    31c0:	fe 17       	cp	r31, r30
    31c2:	19 f0       	breq	.+6      	; 0x31ca <xTaskCheckForTimeOut+0x28>
    31c4:	24 17       	cp	r18, r20
    31c6:	35 07       	cpc	r19, r21
    31c8:	98 f4       	brcc	.+38     	; 0x31f0 <xTaskCheckForTimeOut+0x4e>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    31ca:	24 1b       	sub	r18, r20
    31cc:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    31ce:	fb 01       	movw	r30, r22
    31d0:	40 81       	ld	r20, Z
    31d2:	51 81       	ldd	r21, Z+1	; 0x01
    31d4:	24 17       	cp	r18, r20
    31d6:	35 07       	cpc	r19, r21
    31d8:	38 f4       	brcc	.+14     	; 0x31e8 <xTaskCheckForTimeOut+0x46>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    31da:	42 1b       	sub	r20, r18
    31dc:	53 0b       	sbc	r21, r19
    31de:	40 83       	st	Z, r20
    31e0:	51 83       	std	Z+1, r21	; 0x01
			vTaskInternalSetTimeOutState( pxTimeOut );
    31e2:	d4 df       	rcall	.-88     	; 0x318c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    31e4:	80 e0       	ldi	r24, 0x00	; 0
    31e6:	05 c0       	rjmp	.+10     	; 0x31f2 <xTaskCheckForTimeOut+0x50>
		}
		else
		{
			*pxTicksToWait = 0;
    31e8:	10 82       	st	Z, r1
    31ea:	11 82       	std	Z+1, r1	; 0x01
			xReturn = pdTRUE;
    31ec:	81 e0       	ldi	r24, 0x01	; 1
    31ee:	01 c0       	rjmp	.+2      	; 0x31f2 <xTaskCheckForTimeOut+0x50>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    31f0:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    31f2:	0f 90       	pop	r0
    31f4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    31f6:	08 95       	ret

000031f8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    31f8:	81 e0       	ldi	r24, 0x01	; 1
    31fa:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <xYieldPending>
    31fe:	08 95       	ret

00003200 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    3200:	80 91 63 22 	lds	r24, 0x2263	; 0x802263 <xSchedulerRunning>
    3204:	88 23       	and	r24, r24
    3206:	31 f0       	breq	.+12     	; 0x3214 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3208:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <uxSchedulerSuspended>
    320c:	88 23       	and	r24, r24
    320e:	21 f0       	breq	.+8      	; 0x3218 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    3210:	80 e0       	ldi	r24, 0x00	; 0
    3212:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    3214:	81 e0       	ldi	r24, 0x01	; 1
    3216:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    3218:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    321a:	08 95       	ret

0000321c <prvInsertTimerInActiveList>:
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    321c:	fc 01       	movw	r30, r24
    321e:	62 83       	std	Z+2, r22	; 0x02
    3220:	73 83       	std	Z+3, r23	; 0x03
    3222:	80 87       	std	Z+8, r24	; 0x08
    3224:	91 87       	std	Z+9, r25	; 0x09
    3226:	46 17       	cp	r20, r22
    3228:	57 07       	cpc	r21, r23
    322a:	90 f0       	brcs	.+36     	; 0x3250 <prvInsertTimerInActiveList+0x34>
    322c:	42 1b       	sub	r20, r18
    322e:	53 0b       	sbc	r21, r19
    3230:	84 85       	ldd	r24, Z+12	; 0x0c
    3232:	95 85       	ldd	r25, Z+13	; 0x0d
    3234:	48 17       	cp	r20, r24
    3236:	59 07       	cpc	r21, r25
    3238:	e0 f4       	brcc	.+56     	; 0x3272 <prvInsertTimerInActiveList+0x56>
    323a:	bf 01       	movw	r22, r30
    323c:	6e 5f       	subi	r22, 0xFE	; 254
    323e:	7f 4f       	sbci	r23, 0xFF	; 255
    3240:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <pxOverflowTimerList>
    3244:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <pxOverflowTimerList+0x1>
    3248:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsert>
    324c:	80 e0       	ldi	r24, 0x00	; 0
    324e:	08 95       	ret
    3250:	42 17       	cp	r20, r18
    3252:	53 07       	cpc	r21, r19
    3254:	18 f4       	brcc	.+6      	; 0x325c <prvInsertTimerInActiveList+0x40>
    3256:	62 17       	cp	r22, r18
    3258:	73 07       	cpc	r23, r19
    325a:	68 f4       	brcc	.+26     	; 0x3276 <prvInsertTimerInActiveList+0x5a>
    325c:	bf 01       	movw	r22, r30
    325e:	6e 5f       	subi	r22, 0xFE	; 254
    3260:	7f 4f       	sbci	r23, 0xFF	; 255
    3262:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <pxCurrentTimerList>
    3266:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <pxCurrentTimerList+0x1>
    326a:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsert>
    326e:	80 e0       	ldi	r24, 0x00	; 0
    3270:	08 95       	ret
    3272:	81 e0       	ldi	r24, 0x01	; 1
    3274:	08 95       	ret
    3276:	81 e0       	ldi	r24, 0x01	; 1
    3278:	08 95       	ret

0000327a <prvCheckForValidListAndQueue>:
    327a:	0f b6       	in	r0, 0x3f	; 63
    327c:	f8 94       	cli
    327e:	0f 92       	push	r0
    3280:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <xTimerQueue>
    3284:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <xTimerQueue+0x1>
    3288:	89 2b       	or	r24, r25
    328a:	e1 f4       	brne	.+56     	; 0x32c4 <prvCheckForValidListAndQueue+0x4a>
    328c:	89 ec       	ldi	r24, 0xC9	; 201
    328e:	92 e2       	ldi	r25, 0x22	; 34
    3290:	0e 94 8a 10 	call	0x2114	; 0x2114 <vListInitialise>
    3294:	80 ec       	ldi	r24, 0xC0	; 192
    3296:	92 e2       	ldi	r25, 0x22	; 34
    3298:	0e 94 8a 10 	call	0x2114	; 0x2114 <vListInitialise>
    329c:	89 ec       	ldi	r24, 0xC9	; 201
    329e:	92 e2       	ldi	r25, 0x22	; 34
    32a0:	80 93 be 22 	sts	0x22BE, r24	; 0x8022be <pxCurrentTimerList>
    32a4:	90 93 bf 22 	sts	0x22BF, r25	; 0x8022bf <pxCurrentTimerList+0x1>
    32a8:	80 ec       	ldi	r24, 0xC0	; 192
    32aa:	92 e2       	ldi	r25, 0x22	; 34
    32ac:	80 93 bc 22 	sts	0x22BC, r24	; 0x8022bc <pxOverflowTimerList>
    32b0:	90 93 bd 22 	sts	0x22BD, r25	; 0x8022bd <pxOverflowTimerList+0x1>
    32b4:	40 e0       	ldi	r20, 0x00	; 0
    32b6:	65 e0       	ldi	r22, 0x05	; 5
    32b8:	8a e0       	ldi	r24, 0x0A	; 10
    32ba:	38 da       	rcall	.-2960   	; 0x272c <xQueueGenericCreate>
    32bc:	80 93 ba 22 	sts	0x22BA, r24	; 0x8022ba <xTimerQueue>
    32c0:	90 93 bb 22 	sts	0x22BB, r25	; 0x8022bb <xTimerQueue+0x1>
    32c4:	0f 90       	pop	r0
    32c6:	0f be       	out	0x3f, r0	; 63
    32c8:	08 95       	ret

000032ca <xTimerCreateTimerTask>:
    32ca:	ef 92       	push	r14
    32cc:	ff 92       	push	r15
    32ce:	0f 93       	push	r16
    32d0:	d4 df       	rcall	.-88     	; 0x327a <prvCheckForValidListAndQueue>
    32d2:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <xTimerQueue>
    32d6:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <xTimerQueue+0x1>
    32da:	89 2b       	or	r24, r25
    32dc:	89 f0       	breq	.+34     	; 0x3300 <xTimerCreateTimerTask+0x36>
    32de:	0f 2e       	mov	r0, r31
    32e0:	f8 eb       	ldi	r31, 0xB8	; 184
    32e2:	ef 2e       	mov	r14, r31
    32e4:	f2 e2       	ldi	r31, 0x22	; 34
    32e6:	ff 2e       	mov	r15, r31
    32e8:	f0 2d       	mov	r31, r0
    32ea:	03 e0       	ldi	r16, 0x03	; 3
    32ec:	20 e0       	ldi	r18, 0x00	; 0
    32ee:	30 e0       	ldi	r19, 0x00	; 0
    32f0:	45 e5       	ldi	r20, 0x55	; 85
    32f2:	50 e0       	ldi	r21, 0x00	; 0
    32f4:	69 e1       	ldi	r22, 0x19	; 25
    32f6:	70 e2       	ldi	r23, 0x20	; 32
    32f8:	85 e3       	ldi	r24, 0x35	; 53
    32fa:	9a e1       	ldi	r25, 0x1A	; 26
    32fc:	05 dc       	rcall	.-2038   	; 0x2b08 <xTaskCreate>
    32fe:	01 c0       	rjmp	.+2      	; 0x3302 <xTimerCreateTimerTask+0x38>
    3300:	80 e0       	ldi	r24, 0x00	; 0
    3302:	0f 91       	pop	r16
    3304:	ff 90       	pop	r15
    3306:	ef 90       	pop	r14
    3308:	08 95       	ret

0000330a <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    330a:	0f 93       	push	r16
    330c:	1f 93       	push	r17
    330e:	cf 93       	push	r28
    3310:	df 93       	push	r29
    3312:	cd b7       	in	r28, 0x3d	; 61
    3314:	de b7       	in	r29, 0x3e	; 62
    3316:	25 97       	sbiw	r28, 0x05	; 5
    3318:	cd bf       	out	0x3d, r28	; 61
    331a:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    331c:	e0 91 ba 22 	lds	r30, 0x22BA	; 0x8022ba <xTimerQueue>
    3320:	f0 91 bb 22 	lds	r31, 0x22BB	; 0x8022bb <xTimerQueue+0x1>
    3324:	30 97       	sbiw	r30, 0x00	; 0
    3326:	51 f1       	breq	.+84     	; 0x337c <xTimerGenericCommand+0x72>
    3328:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    332a:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    332c:	4a 83       	std	Y+2, r20	; 0x02
    332e:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    3330:	8c 83       	std	Y+4, r24	; 0x04
    3332:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3334:	66 30       	cpi	r22, 0x06	; 6
    3336:	d4 f4       	brge	.+52     	; 0x336c <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3338:	63 df       	rcall	.-314    	; 0x3200 <xTaskGetSchedulerState>
    333a:	82 30       	cpi	r24, 0x02	; 2
    333c:	59 f4       	brne	.+22     	; 0x3354 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    333e:	20 e0       	ldi	r18, 0x00	; 0
    3340:	a8 01       	movw	r20, r16
    3342:	be 01       	movw	r22, r28
    3344:	6f 5f       	subi	r22, 0xFF	; 255
    3346:	7f 4f       	sbci	r23, 0xFF	; 255
    3348:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <xTimerQueue>
    334c:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <xTimerQueue+0x1>
    3350:	0e da       	rcall	.-3044   	; 0x276e <xQueueGenericSend>
    3352:	15 c0       	rjmp	.+42     	; 0x337e <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3354:	20 e0       	ldi	r18, 0x00	; 0
    3356:	40 e0       	ldi	r20, 0x00	; 0
    3358:	50 e0       	ldi	r21, 0x00	; 0
    335a:	be 01       	movw	r22, r28
    335c:	6f 5f       	subi	r22, 0xFF	; 255
    335e:	7f 4f       	sbci	r23, 0xFF	; 255
    3360:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <xTimerQueue>
    3364:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <xTimerQueue+0x1>
    3368:	02 da       	rcall	.-3068   	; 0x276e <xQueueGenericSend>
    336a:	09 c0       	rjmp	.+18     	; 0x337e <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    336c:	20 e0       	ldi	r18, 0x00	; 0
    336e:	ad 01       	movw	r20, r26
    3370:	be 01       	movw	r22, r28
    3372:	6f 5f       	subi	r22, 0xFF	; 255
    3374:	7f 4f       	sbci	r23, 0xFF	; 255
    3376:	cf 01       	movw	r24, r30
    3378:	87 da       	rcall	.-2802   	; 0x2888 <xQueueGenericSendFromISR>
    337a:	01 c0       	rjmp	.+2      	; 0x337e <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    337c:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    337e:	25 96       	adiw	r28, 0x05	; 5
    3380:	cd bf       	out	0x3d, r28	; 61
    3382:	de bf       	out	0x3e, r29	; 62
    3384:	df 91       	pop	r29
    3386:	cf 91       	pop	r28
    3388:	1f 91       	pop	r17
    338a:	0f 91       	pop	r16
    338c:	08 95       	ret

0000338e <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    338e:	af 92       	push	r10
    3390:	bf 92       	push	r11
    3392:	cf 92       	push	r12
    3394:	df 92       	push	r13
    3396:	ef 92       	push	r14
    3398:	ff 92       	push	r15
    339a:	0f 93       	push	r16
    339c:	1f 93       	push	r17
    339e:	cf 93       	push	r28
    33a0:	df 93       	push	r29
    33a2:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    33a4:	e1 dc       	rcall	.-1598   	; 0x2d68 <xTaskGetTickCount>
    33a6:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    33a8:	80 91 b6 22 	lds	r24, 0x22B6	; 0x8022b6 <xLastTime.4598>
    33ac:	90 91 b7 22 	lds	r25, 0x22B7	; 0x8022b7 <xLastTime.4598+0x1>
    33b0:	e8 16       	cp	r14, r24
    33b2:	f9 06       	cpc	r15, r25
    33b4:	08 f0       	brcs	.+2      	; 0x33b8 <prvSampleTimeNow+0x2a>
    33b6:	47 c0       	rjmp	.+142    	; 0x3446 <prvSampleTimeNow+0xb8>
    33b8:	2f c0       	rjmp	.+94     	; 0x3418 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    33ba:	05 80       	ldd	r0, Z+5	; 0x05
    33bc:	f6 81       	ldd	r31, Z+6	; 0x06
    33be:	e0 2d       	mov	r30, r0
    33c0:	a0 80       	ld	r10, Z
    33c2:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    33c4:	c6 81       	ldd	r28, Z+6	; 0x06
    33c6:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    33c8:	8e 01       	movw	r16, r28
    33ca:	0e 5f       	subi	r16, 0xFE	; 254
    33cc:	1f 4f       	sbci	r17, 0xFF	; 255
    33ce:	c8 01       	movw	r24, r16
    33d0:	0e 94 ee 10 	call	0x21dc	; 0x21dc <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    33d4:	e8 89       	ldd	r30, Y+16	; 0x10
    33d6:	f9 89       	ldd	r31, Y+17	; 0x11
    33d8:	ce 01       	movw	r24, r28
    33da:	19 95       	eicall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    33dc:	8a 89       	ldd	r24, Y+18	; 0x12
    33de:	82 ff       	sbrs	r24, 2
    33e0:	1b c0       	rjmp	.+54     	; 0x3418 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    33e2:	8c 85       	ldd	r24, Y+12	; 0x0c
    33e4:	9d 85       	ldd	r25, Y+13	; 0x0d
    33e6:	8a 0d       	add	r24, r10
    33e8:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    33ea:	a8 16       	cp	r10, r24
    33ec:	b9 06       	cpc	r11, r25
    33ee:	60 f4       	brcc	.+24     	; 0x3408 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    33f0:	8a 83       	std	Y+2, r24	; 0x02
    33f2:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    33f4:	c8 87       	std	Y+8, r28	; 0x08
    33f6:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    33f8:	b8 01       	movw	r22, r16
    33fa:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <pxCurrentTimerList>
    33fe:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <pxCurrentTimerList+0x1>
    3402:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsert>
    3406:	08 c0       	rjmp	.+16     	; 0x3418 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3408:	00 e0       	ldi	r16, 0x00	; 0
    340a:	10 e0       	ldi	r17, 0x00	; 0
    340c:	20 e0       	ldi	r18, 0x00	; 0
    340e:	30 e0       	ldi	r19, 0x00	; 0
    3410:	a5 01       	movw	r20, r10
    3412:	60 e0       	ldi	r22, 0x00	; 0
    3414:	ce 01       	movw	r24, r28
    3416:	79 df       	rcall	.-270    	; 0x330a <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3418:	e0 91 be 22 	lds	r30, 0x22BE	; 0x8022be <pxCurrentTimerList>
    341c:	f0 91 bf 22 	lds	r31, 0x22BF	; 0x8022bf <pxCurrentTimerList+0x1>
    3420:	80 81       	ld	r24, Z
    3422:	81 11       	cpse	r24, r1
    3424:	ca cf       	rjmp	.-108    	; 0x33ba <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    3426:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <pxOverflowTimerList>
    342a:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <pxOverflowTimerList+0x1>
    342e:	80 93 be 22 	sts	0x22BE, r24	; 0x8022be <pxCurrentTimerList>
    3432:	90 93 bf 22 	sts	0x22BF, r25	; 0x8022bf <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    3436:	e0 93 bc 22 	sts	0x22BC, r30	; 0x8022bc <pxOverflowTimerList>
    343a:	f0 93 bd 22 	sts	0x22BD, r31	; 0x8022bd <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    343e:	81 e0       	ldi	r24, 0x01	; 1
    3440:	f6 01       	movw	r30, r12
    3442:	80 83       	st	Z, r24
    3444:	02 c0       	rjmp	.+4      	; 0x344a <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3446:	f6 01       	movw	r30, r12
    3448:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    344a:	e0 92 b6 22 	sts	0x22B6, r14	; 0x8022b6 <xLastTime.4598>
    344e:	f0 92 b7 22 	sts	0x22B7, r15	; 0x8022b7 <xLastTime.4598+0x1>

	return xTimeNow;
}
    3452:	c7 01       	movw	r24, r14
    3454:	df 91       	pop	r29
    3456:	cf 91       	pop	r28
    3458:	1f 91       	pop	r17
    345a:	0f 91       	pop	r16
    345c:	ff 90       	pop	r15
    345e:	ef 90       	pop	r14
    3460:	df 90       	pop	r13
    3462:	cf 90       	pop	r12
    3464:	bf 90       	pop	r11
    3466:	af 90       	pop	r10
    3468:	08 95       	ret

0000346a <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    346a:	cf 93       	push	r28
    346c:	df 93       	push	r29
    346e:	00 d0       	rcall	.+0      	; 0x3470 <prvTimerTask+0x6>
    3470:	00 d0       	rcall	.+0      	; 0x3472 <prvTimerTask+0x8>
    3472:	cd b7       	in	r28, 0x3d	; 61
    3474:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3476:	ce 01       	movw	r24, r28
    3478:	01 96       	adiw	r24, 0x01	; 1
    347a:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    347c:	e8 2e       	mov	r14, r24
    347e:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3480:	e0 91 be 22 	lds	r30, 0x22BE	; 0x8022be <pxCurrentTimerList>
    3484:	f0 91 bf 22 	lds	r31, 0x22BF	; 0x8022bf <pxCurrentTimerList+0x1>
    3488:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    348a:	88 23       	and	r24, r24
    348c:	09 f4       	brne	.+2      	; 0x3490 <prvTimerTask+0x26>
    348e:	cf c0       	rjmp	.+414    	; 0x362e <prvTimerTask+0x1c4>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3490:	05 80       	ldd	r0, Z+5	; 0x05
    3492:	f6 81       	ldd	r31, Z+6	; 0x06
    3494:	e0 2d       	mov	r30, r0
    3496:	c0 80       	ld	r12, Z
    3498:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    349a:	60 dc       	rcall	.-1856   	; 0x2d5c <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    349c:	c5 01       	movw	r24, r10
    349e:	77 df       	rcall	.-274    	; 0x338e <prvSampleTimeNow>
    34a0:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    34a2:	89 81       	ldd	r24, Y+1	; 0x01
    34a4:	81 11       	cpse	r24, r1
    34a6:	46 c0       	rjmp	.+140    	; 0x3534 <prvTimerTask+0xca>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    34a8:	0c 15       	cp	r16, r12
    34aa:	1d 05       	cpc	r17, r13
			{
				( void ) xTaskResumeAll();
    34ac:	a0 f1       	brcs	.+104    	; 0x3516 <prvTimerTask+0xac>
    34ae:	1e dd       	rcall	.-1476   	; 0x2eec <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    34b0:	e0 91 be 22 	lds	r30, 0x22BE	; 0x8022be <pxCurrentTimerList>
    34b4:	f0 91 bf 22 	lds	r31, 0x22BF	; 0x8022bf <pxCurrentTimerList+0x1>
    34b8:	05 80       	ldd	r0, Z+5	; 0x05
    34ba:	f6 81       	ldd	r31, Z+6	; 0x06
    34bc:	e0 2d       	mov	r30, r0
    34be:	86 80       	ldd	r8, Z+6	; 0x06
    34c0:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    34c2:	c4 01       	movw	r24, r8
    34c4:	02 96       	adiw	r24, 0x02	; 2
    34c6:	0e 94 ee 10 	call	0x21dc	; 0x21dc <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    34ca:	d4 01       	movw	r26, r8
    34cc:	52 96       	adiw	r26, 0x12	; 18
    34ce:	8c 91       	ld	r24, X
    34d0:	52 97       	sbiw	r26, 0x12	; 18
    34d2:	82 ff       	sbrs	r24, 2
    34d4:	15 c0       	rjmp	.+42     	; 0x3500 <prvTimerTask+0x96>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    34d6:	1c 96       	adiw	r26, 0x0c	; 12
    34d8:	6d 91       	ld	r22, X+
    34da:	7c 91       	ld	r23, X
    34dc:	1d 97       	sbiw	r26, 0x0d	; 13
    34de:	6c 0d       	add	r22, r12
    34e0:	7d 1d       	adc	r23, r13
    34e2:	96 01       	movw	r18, r12
    34e4:	a8 01       	movw	r20, r16
    34e6:	c4 01       	movw	r24, r8
    34e8:	99 de       	rcall	.-718    	; 0x321c <prvInsertTimerInActiveList>
    34ea:	88 23       	and	r24, r24
    34ec:	61 f0       	breq	.+24     	; 0x3506 <prvTimerTask+0x9c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    34ee:	00 e0       	ldi	r16, 0x00	; 0
    34f0:	10 e0       	ldi	r17, 0x00	; 0
    34f2:	20 e0       	ldi	r18, 0x00	; 0
    34f4:	30 e0       	ldi	r19, 0x00	; 0
    34f6:	a6 01       	movw	r20, r12
    34f8:	60 e0       	ldi	r22, 0x00	; 0
    34fa:	c4 01       	movw	r24, r8
    34fc:	06 df       	rcall	.-500    	; 0x330a <xTimerGenericCommand>
    34fe:	03 c0       	rjmp	.+6      	; 0x3506 <prvTimerTask+0x9c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3500:	8e 7f       	andi	r24, 0xFE	; 254
    3502:	f4 01       	movw	r30, r8
    3504:	82 8b       	std	Z+18, r24	; 0x12
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3506:	d4 01       	movw	r26, r8
    3508:	50 96       	adiw	r26, 0x10	; 16
    350a:	ed 91       	ld	r30, X+
    350c:	fc 91       	ld	r31, X
    350e:	51 97       	sbiw	r26, 0x11	; 17
    3510:	c4 01       	movw	r24, r8
    3512:	19 95       	eicall
    3514:	80 c0       	rjmp	.+256    	; 0x3616 <prvTimerTask+0x1ac>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3516:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3518:	b6 01       	movw	r22, r12
    351a:	60 1b       	sub	r22, r16
    351c:	71 0b       	sbc	r23, r17
    351e:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <xTimerQueue>
    3522:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <xTimerQueue+0x1>

				if( xTaskResumeAll() == pdFALSE )
    3526:	6e da       	rcall	.-2852   	; 0x2a04 <vQueueWaitForMessageRestricted>
    3528:	e1 dc       	rcall	.-1598   	; 0x2eec <xTaskResumeAll>
    352a:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    352c:	74 c0       	rjmp	.+232    	; 0x3616 <prvTimerTask+0x1ac>
    352e:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    3532:	71 c0       	rjmp	.+226    	; 0x3616 <prvTimerTask+0x1ac>
    3534:	db dc       	rcall	.-1610   	; 0x2eec <xTaskResumeAll>
    3536:	6f c0       	rjmp	.+222    	; 0x3616 <prvTimerTask+0x1ac>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3538:	89 81       	ldd	r24, Y+1	; 0x01
    353a:	88 23       	and	r24, r24
    353c:	0c f4       	brge	.+2      	; 0x3540 <prvTimerTask+0xd6>
    353e:	6b c0       	rjmp	.+214    	; 0x3616 <prvTimerTask+0x1ac>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    3540:	cc 80       	ldd	r12, Y+4	; 0x04
    3542:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    3544:	f6 01       	movw	r30, r12
    3546:	82 85       	ldd	r24, Z+10	; 0x0a
    3548:	93 85       	ldd	r25, Z+11	; 0x0b
    354a:	89 2b       	or	r24, r25
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    354c:	21 f0       	breq	.+8      	; 0x3556 <prvTimerTask+0xec>
    354e:	c6 01       	movw	r24, r12
    3550:	02 96       	adiw	r24, 0x02	; 2
    3552:	0e 94 ee 10 	call	0x21dc	; 0x21dc <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3556:	ce 01       	movw	r24, r28
    3558:	06 96       	adiw	r24, 0x06	; 6
    355a:	19 df       	rcall	.-462    	; 0x338e <prvSampleTimeNow>
    355c:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    355e:	e9 81       	ldd	r30, Y+1	; 0x01
    3560:	0e 2e       	mov	r0, r30
    3562:	00 0c       	add	r0, r0
    3564:	ff 0b       	sbc	r31, r31
    3566:	ea 30       	cpi	r30, 0x0A	; 10
    3568:	f1 05       	cpc	r31, r1
    356a:	08 f0       	brcs	.+2      	; 0x356e <prvTimerTask+0x104>
    356c:	54 c0       	rjmp	.+168    	; 0x3616 <prvTimerTask+0x1ac>
    356e:	88 27       	eor	r24, r24
    3570:	e2 50       	subi	r30, 0x02	; 2
    3572:	ff 4f       	sbci	r31, 0xFF	; 255
    3574:	8f 4f       	sbci	r24, 0xFF	; 255
    3576:	cd c3       	rjmp	.+1946   	; 0x3d12 <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    3578:	d6 01       	movw	r26, r12
    357a:	52 96       	adiw	r26, 0x12	; 18
    357c:	8c 91       	ld	r24, X
    357e:	52 97       	sbiw	r26, 0x12	; 18
    3580:	81 60       	ori	r24, 0x01	; 1
    3582:	52 96       	adiw	r26, 0x12	; 18
    3584:	8c 93       	st	X, r24
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    3586:	52 97       	sbiw	r26, 0x12	; 18
    3588:	2a 81       	ldd	r18, Y+2	; 0x02
    358a:	3b 81       	ldd	r19, Y+3	; 0x03
    358c:	1c 96       	adiw	r26, 0x0c	; 12
    358e:	6d 91       	ld	r22, X+
    3590:	7c 91       	ld	r23, X
    3592:	1d 97       	sbiw	r26, 0x0d	; 13
    3594:	62 0f       	add	r22, r18
    3596:	73 1f       	adc	r23, r19
    3598:	c6 01       	movw	r24, r12
    359a:	40 de       	rcall	.-896    	; 0x321c <prvInsertTimerInActiveList>
    359c:	88 23       	and	r24, r24
    359e:	d9 f1       	breq	.+118    	; 0x3616 <prvTimerTask+0x1ac>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    35a0:	d6 01       	movw	r26, r12
    35a2:	50 96       	adiw	r26, 0x10	; 16
    35a4:	ed 91       	ld	r30, X+
    35a6:	fc 91       	ld	r31, X
    35a8:	51 97       	sbiw	r26, 0x11	; 17
    35aa:	c6 01       	movw	r24, r12
    35ac:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    35ae:	f6 01       	movw	r30, r12
    35b0:	82 89       	ldd	r24, Z+18	; 0x12
    35b2:	82 ff       	sbrs	r24, 2
    35b4:	30 c0       	rjmp	.+96     	; 0x3616 <prvTimerTask+0x1ac>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    35b6:	4a 81       	ldd	r20, Y+2	; 0x02
    35b8:	5b 81       	ldd	r21, Y+3	; 0x03
    35ba:	84 85       	ldd	r24, Z+12	; 0x0c
    35bc:	95 85       	ldd	r25, Z+13	; 0x0d
    35be:	48 0f       	add	r20, r24
    35c0:	59 1f       	adc	r21, r25
    35c2:	00 e0       	ldi	r16, 0x00	; 0
    35c4:	10 e0       	ldi	r17, 0x00	; 0
    35c6:	20 e0       	ldi	r18, 0x00	; 0
    35c8:	30 e0       	ldi	r19, 0x00	; 0
    35ca:	60 e0       	ldi	r22, 0x00	; 0
    35cc:	c6 01       	movw	r24, r12
    35ce:	9d de       	rcall	.-710    	; 0x330a <xTimerGenericCommand>
    35d0:	22 c0       	rjmp	.+68     	; 0x3616 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    35d2:	d6 01       	movw	r26, r12
    35d4:	52 96       	adiw	r26, 0x12	; 18
    35d6:	8c 91       	ld	r24, X
    35d8:	52 97       	sbiw	r26, 0x12	; 18
    35da:	8e 7f       	andi	r24, 0xFE	; 254
    35dc:	52 96       	adiw	r26, 0x12	; 18
    35de:	8c 93       	st	X, r24
    35e0:	1a c0       	rjmp	.+52     	; 0x3616 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    35e2:	f6 01       	movw	r30, r12
    35e4:	82 89       	ldd	r24, Z+18	; 0x12
    35e6:	81 60       	ori	r24, 0x01	; 1
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    35e8:	82 8b       	std	Z+18, r24	; 0x12
    35ea:	6a 81       	ldd	r22, Y+2	; 0x02
    35ec:	7b 81       	ldd	r23, Y+3	; 0x03
    35ee:	64 87       	std	Z+12, r22	; 0x0c
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    35f0:	75 87       	std	Z+13, r23	; 0x0d
    35f2:	64 0f       	add	r22, r20
    35f4:	75 1f       	adc	r23, r21
    35f6:	9a 01       	movw	r18, r20
    35f8:	c6 01       	movw	r24, r12
    35fa:	10 de       	rcall	.-992    	; 0x321c <prvInsertTimerInActiveList>
    35fc:	0c c0       	rjmp	.+24     	; 0x3616 <prvTimerTask+0x1ac>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    35fe:	d6 01       	movw	r26, r12
    3600:	52 96       	adiw	r26, 0x12	; 18
    3602:	8c 91       	ld	r24, X
    3604:	81 fd       	sbrc	r24, 1
    3606:	04 c0       	rjmp	.+8      	; 0x3610 <prvTimerTask+0x1a6>
						{
							vPortFree( pxTimer );
    3608:	c6 01       	movw	r24, r12
    360a:	0e 94 90 12 	call	0x2520	; 0x2520 <vPortFree>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    360e:	03 c0       	rjmp	.+6      	; 0x3616 <prvTimerTask+0x1ac>
    3610:	8e 7f       	andi	r24, 0xFE	; 254
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3612:	f6 01       	movw	r30, r12
    3614:	82 8b       	std	Z+18, r24	; 0x12
    3616:	40 e0       	ldi	r20, 0x00	; 0
    3618:	50 e0       	ldi	r21, 0x00	; 0
    361a:	6e 2d       	mov	r22, r14
    361c:	7f 2d       	mov	r23, r15
    361e:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <xTimerQueue>
    3622:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <xTimerQueue+0x1>
    3626:	6a d9       	rcall	.-3372   	; 0x28fc <xQueueReceive>
    3628:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    362a:	86 cf       	rjmp	.-244    	; 0x3538 <prvTimerTask+0xce>
    362c:	29 cf       	rjmp	.-430    	; 0x3480 <prvTimerTask+0x16>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    362e:	96 db       	rcall	.-2260   	; 0x2d5c <vTaskSuspendAll>
    3630:	c5 01       	movw	r24, r10
    3632:	ad de       	rcall	.-678    	; 0x338e <prvSampleTimeNow>
    3634:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    3636:	89 81       	ldd	r24, Y+1	; 0x01
    3638:	81 11       	cpse	r24, r1
    363a:	7c cf       	rjmp	.-264    	; 0x3534 <prvTimerTask+0xca>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    363c:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <pxOverflowTimerList>
    3640:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <pxOverflowTimerList+0x1>
    3644:	80 81       	ld	r24, Z
    3646:	41 e0       	ldi	r20, 0x01	; 1
    3648:	81 11       	cpse	r24, r1
    364a:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    364c:	c1 2c       	mov	r12, r1
    364e:	d1 2c       	mov	r13, r1
    3650:	63 cf       	rjmp	.-314    	; 0x3518 <prvTimerTask+0xae>

00003652 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
    3652:	04 c0       	rjmp	.+8      	; 0x365c <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
    3654:	61 50       	subi	r22, 0x01	; 1
    3656:	71 09       	sbc	r23, r1
    3658:	81 09       	sbc	r24, r1
    365a:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
    365c:	61 15       	cp	r22, r1
    365e:	71 05       	cpc	r23, r1
    3660:	81 05       	cpc	r24, r1
    3662:	91 05       	cpc	r25, r1
    3664:	b9 f7       	brne	.-18     	; 0x3654 <__portable_avr_delay_cycles+0x2>
    3666:	08 95       	ret

00003668 <monitor_current>:
		gpio_set_pin_low(PIN4_bm); // Deactivate the buzzer
	}
}


static portTASK_FUNCTION_PROTO(monitor_current, p_) {
    3668:	cf 93       	push	r28
    366a:	df 93       	push	r29
    366c:	00 d0       	rcall	.+0      	; 0x366e <monitor_current+0x6>
    366e:	cd b7       	in	r28, 0x3d	; 61
    3670:	de b7       	in	r29, 0x3e	; 62
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
}

static uint16_t adc_read(){
	uint16_t result;
	adc_enable(&MY_ADC);
    3672:	e1 2c       	mov	r14, r1
    3674:	68 94       	set
    3676:	ff 24       	eor	r15, r15
    3678:	f1 f8       	bld	r15, 1
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    367a:	55 24       	eor	r5, r5
    367c:	53 94       	inc	r5
		
		// Calculate current
		float current = calculate_current(adc_result);

		// Display current via USART
		snprintf(strbufadc, sizeof(strbufadc), "Current: %.2f A\r\n", current);
    367e:	0f 2e       	mov	r0, r31
    3680:	f1 e2       	ldi	r31, 0x21	; 33
    3682:	8f 2e       	mov	r8, r31
    3684:	f0 e2       	ldi	r31, 0x20	; 32
    3686:	9f 2e       	mov	r9, r31
    3688:	f0 2d       	mov	r31, r0
    368a:	68 94       	set
    368c:	44 24       	eor	r4, r4
    368e:	47 f8       	bld	r4, 7
    3690:	0f 2e       	mov	r0, r31
    3692:	f2 ed       	ldi	r31, 0xD2	; 210
    3694:	af 2e       	mov	r10, r31
    3696:	f2 e2       	ldi	r31, 0x22	; 34
    3698:	bf 2e       	mov	r11, r31
    369a:	f0 2d       	mov	r31, r0
}

static void sendChar(char c)
{
	
	while( !(USARTC0_STATUS & USART_DREIF_bm) ); //Wait until DATA buffer is empty
    369c:	01 ea       	ldi	r16, 0xA1	; 161
    369e:	18 e0       	ldi	r17, 0x08	; 8
	
	USARTC0_DATA = c;
    36a0:	0f 2e       	mov	r0, r31
    36a2:	f0 ea       	ldi	r31, 0xA0	; 160
    36a4:	cf 2e       	mov	r12, r31
    36a6:	f8 e0       	ldi	r31, 0x08	; 8
    36a8:	df 2e       	mov	r13, r31
    36aa:	f0 2d       	mov	r31, r0
	PORTC.DIRSET = PIN7_bm; // Set PC3 as output
}

static void led_control(bool state) {
	if (state) {
		PORTC.OUTSET = PIN7_bm; // Turn on the LED
    36ac:	0f 2e       	mov	r0, r31
    36ae:	f0 e4       	ldi	r31, 0x40	; 64
    36b0:	6f 2e       	mov	r6, r31
    36b2:	f6 e0       	ldi	r31, 0x06	; 6
    36b4:	7f 2e       	mov	r7, r31
    36b6:	f0 2d       	mov	r31, r0
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
}

static uint16_t adc_read(){
	uint16_t result;
	adc_enable(&MY_ADC);
    36b8:	c7 01       	movw	r24, r14
    36ba:	0e 94 36 08 	call	0x106c	; 0x106c <adc_enable>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    36be:	8f b7       	in	r24, 0x3f	; 63
    36c0:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    36c2:	f8 94       	cli
	return flags;
    36c4:	99 81       	ldd	r25, Y+1	; 0x01
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    36c6:	d7 01       	movw	r26, r14
    36c8:	8c 91       	ld	r24, X
    36ca:	84 60       	ori	r24, 0x04	; 4
    36cc:	8c 93       	st	X, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    36ce:	9f bf       	out	0x3f, r25	; 63
 *
 * \return Mask with interrupt flags.
 */
static inline uint8_t adc_get_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	return (adc->INTFLAGS >> ADC_CH0IF_bp) & ch_mask;
    36d0:	f7 01       	movw	r30, r14
    36d2:	86 81       	ldd	r24, Z+6	; 0x06
 * \arg \c ADC_CHn , where \c n specifies the channel. (These can be OR'ed
 * together.)
 */
static inline void adc_wait_for_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	do { } while (adc_get_interrupt_flag(adc, ch_mask) != ch_mask);
    36d4:	80 ff       	sbrs	r24, 0
    36d6:	fc cf       	rjmp	.-8      	; 0x36d0 <monitor_current+0x68>
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    36d8:	56 82       	std	Z+6, r5	; 0x06
	adc_start_conversion(&MY_ADC, MY_ADC_CH);
	adc_wait_for_interrupt_flag(&MY_ADC, MY_ADC_CH);
	result = adc_get_result(&MY_ADC, MY_ADC_CH);
    36da:	64 a1       	ldd	r22, Z+36	; 0x24
    36dc:	75 a1       	ldd	r23, Z+37	; 0x25

	// Subtract the midpoint (2.5V) to get differential voltage
	float differential_voltage = voltage - (VREF / 2);

	// Calculate current
	return differential_voltage / ACS712_SENSITIVITY;
    36de:	80 e0       	ldi	r24, 0x00	; 0
    36e0:	90 e0       	ldi	r25, 0x00	; 0
    36e2:	dc d1       	rcall	.+952    	; 0x3a9c <__floatunsisf>
    36e4:	20 e0       	ldi	r18, 0x00	; 0
    36e6:	30 ef       	ldi	r19, 0xF0	; 240
    36e8:	4f e7       	ldi	r20, 0x7F	; 127
    36ea:	55 e4       	ldi	r21, 0x45	; 69
    36ec:	6f d1       	rcall	.+734    	; 0x39cc <__divsf3>
    36ee:	23 e3       	ldi	r18, 0x33	; 51
    36f0:	33 e3       	ldi	r19, 0x33	; 51
    36f2:	43 e5       	ldi	r20, 0x53	; 83
    36f4:	50 e4       	ldi	r21, 0x40	; 64
    36f6:	64 d2       	rcall	.+1224   	; 0x3bc0 <__mulsf3>
    36f8:	23 e3       	ldi	r18, 0x33	; 51
    36fa:	33 e3       	ldi	r19, 0x33	; 51
    36fc:	43 ed       	ldi	r20, 0xD3	; 211
    36fe:	5f e3       	ldi	r21, 0x3F	; 63
    3700:	00 d1       	rcall	.+512    	; 0x3902 <__subsf3>
    3702:	24 ea       	ldi	r18, 0xA4	; 164
    3704:	30 e7       	ldi	r19, 0x70	; 112
    3706:	4d e3       	ldi	r20, 0x3D	; 61
    3708:	5e e3       	ldi	r21, 0x3E	; 62
    370a:	60 d1       	rcall	.+704    	; 0x39cc <__divsf3>
    370c:	6a 83       	std	Y+2, r22	; 0x02
    370e:	7b 83       	std	Y+3, r23	; 0x03
    3710:	28 2e       	mov	r2, r24
    3712:	39 2e       	mov	r3, r25
		
		// Calculate current
		float current = calculate_current(adc_result);

		// Display current via USART
		snprintf(strbufadc, sizeof(strbufadc), "Current: %.2f A\r\n", current);
    3714:	9f 93       	push	r25
    3716:	8f 93       	push	r24
    3718:	fb 81       	ldd	r31, Y+3	; 0x03
    371a:	ff 93       	push	r31
    371c:	2a 81       	ldd	r18, Y+2	; 0x02
    371e:	2f 93       	push	r18
    3720:	9f 92       	push	r9
    3722:	8f 92       	push	r8
    3724:	1f 92       	push	r1
    3726:	4f 92       	push	r4
    3728:	bf 92       	push	r11
    372a:	af 92       	push	r10
    372c:	24 d4       	rcall	.+2120   	; 0x3f76 <snprintf>
	
}

static void sendString(char *text)
{
	while(*text)
    372e:	d5 01       	movw	r26, r10
    3730:	9c 91       	ld	r25, X
    3732:	cd bf       	out	0x3d, r28	; 61
    3734:	de bf       	out	0x3e, r29	; 62
    3736:	99 23       	and	r25, r25
    3738:	59 f0       	breq	.+22     	; 0x3750 <monitor_current+0xe8>
    373a:	e3 ed       	ldi	r30, 0xD3	; 211
    373c:	f2 e2       	ldi	r31, 0x22	; 34
}

static void sendChar(char c)
{
	
	while( !(USARTC0_STATUS & USART_DREIF_bm) ); //Wait until DATA buffer is empty
    373e:	d8 01       	movw	r26, r16
    3740:	8c 91       	ld	r24, X
    3742:	85 ff       	sbrs	r24, 5
    3744:	fc cf       	rjmp	.-8      	; 0x373e <monitor_current+0xd6>
	
	USARTC0_DATA = c;
    3746:	d6 01       	movw	r26, r12
    3748:	9c 93       	st	X, r25
	
}

static void sendString(char *text)
{
	while(*text)
    374a:	91 91       	ld	r25, Z+
    374c:	91 11       	cpse	r25, r1
    374e:	f7 cf       	rjmp	.-18     	; 0x373e <monitor_current+0xd6>
		// Display current via USART
		snprintf(strbufadc, sizeof(strbufadc), "Current: %.2f A\r\n", current);
		sendString(strbufadc);
		
		// Check condition to trigger relay and buzzer
		if (current > 2.0) { // Example condition
    3750:	20 e0       	ldi	r18, 0x00	; 0
    3752:	30 e0       	ldi	r19, 0x00	; 0
    3754:	40 e0       	ldi	r20, 0x00	; 0
    3756:	50 e4       	ldi	r21, 0x40	; 64
    3758:	ba 81       	ldd	r27, Y+2	; 0x02
    375a:	ab 81       	ldd	r26, Y+3	; 0x03
    375c:	6b 2f       	mov	r22, r27
    375e:	7a 2f       	mov	r23, r26
    3760:	82 2d       	mov	r24, r2
    3762:	93 2d       	mov	r25, r3
    3764:	29 d2       	rcall	.+1106   	; 0x3bb8 <__gesf2>
    3766:	18 16       	cp	r1, r24
    3768:	8c f4       	brge	.+34     	; 0x378c <monitor_current+0x124>
    376a:	f3 01       	movw	r30, r6
    376c:	55 82       	std	Z+5, r5	; 0x05
			// Sound the buzzer
			buzzer_control(true);
			delay_ms(1000); // Buzzer on for 1 second
    376e:	66 e1       	ldi	r22, 0x16	; 22
    3770:	76 e1       	ldi	r23, 0x16	; 22
    3772:	85 e0       	ldi	r24, 0x05	; 5
    3774:	90 e0       	ldi	r25, 0x00	; 0
    3776:	6d df       	rcall	.-294    	; 0x3652 <__portable_avr_delay_cycles>
    3778:	d3 01       	movw	r26, r6
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    377a:	16 96       	adiw	r26, 0x06	; 6
    377c:	5c 92       	st	X, r5
    377e:	16 97       	sbiw	r26, 0x06	; 6
    3780:	82 e0       	ldi	r24, 0x02	; 2
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3782:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    3786:	16 96       	adiw	r26, 0x06	; 6

static void led_control(bool state) {
	if (state) {
		PORTC.OUTSET = PIN7_bm; // Turn on the LED
		} else {
		PORTC.OUTCLR = PIN7_bm; // Turn off the LED
    3788:	4c 92       	st	X, r4
    378a:	05 c0       	rjmp	.+10     	; 0x3796 <monitor_current+0x12e>
    378c:	82 e0       	ldi	r24, 0x02	; 2
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    378e:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
	PORTC.DIRSET = PIN7_bm; // Set PC3 as output
}

static void led_control(bool state) {
	if (state) {
		PORTC.OUTSET = PIN7_bm; // Turn on the LED
    3792:	f3 01       	movw	r30, r6
    3794:	45 82       	std	Z+5, r4	; 0x05
			// Ensure LED is on when relay is inactive
			led_control(true);
		}

		// Delay to prevent flooding
		delay_ms(500);
    3796:	6b e0       	ldi	r22, 0x0B	; 11
    3798:	7b e8       	ldi	r23, 0x8B	; 139
    379a:	82 e0       	ldi	r24, 0x02	; 2
    379c:	90 e0       	ldi	r25, 0x00	; 0
    379e:	59 df       	rcall	.-334    	; 0x3652 <__portable_avr_delay_cycles>
    37a0:	8b cf       	rjmp	.-234    	; 0x36b8 <monitor_current+0x50>

000037a2 <main>:
	}
    37a2:	ef 92       	push	r14
}


int main (void)
{
    37a4:	ff 92       	push	r15
    37a6:	0f 93       	push	r16
    37a8:	1f 93       	push	r17
    37aa:	cf 93       	push	r28
    37ac:	df 93       	push	r29
    37ae:	cd b7       	in	r28, 0x3d	; 61
    37b0:	de b7       	in	r29, 0x3e	; 62
    37b2:	2b 97       	sbiw	r28, 0x0b	; 11
    37b4:	cd bf       	out	0x3d, r28	; 61
    37b6:	de bf       	out	0x3e, r29	; 62
	board_init();
    37b8:	0e 94 5d 07 	call	0xeba	; 0xeba <board_init>
	sysclk_init();
    37bc:	0e 94 42 04 	call	0x884	; 0x884 <sysclk_init>
	gfx_mono_init();
    37c0:	0e 94 24 05 	call	0xa48	; 0xa48 <gfx_mono_st7565r_init>
	 * PC0 to control relay
	 * PC1 to control potentiometer
	 * PC4 to control buzzer
	 * PC6 to control ACS712
	 */
	PORTC.DIRCLR = PIN0_bm | PIN4_bm | PIN6_bm; // | PIN1_bm 
    37c4:	0f 2e       	mov	r0, r31
    37c6:	f0 e4       	ldi	r31, 0x40	; 64
    37c8:	ef 2e       	mov	r14, r31
    37ca:	f6 e0       	ldi	r31, 0x06	; 6
    37cc:	ff 2e       	mov	r15, r31
    37ce:	f0 2d       	mov	r31, r0
    37d0:	81 e5       	ldi	r24, 0x51	; 81
    37d2:	f7 01       	movw	r30, r14
    37d4:	82 83       	std	Z+2, r24	; 0x02
	
}

/* Sensor, LED, buzzer, relay */
static void led_init(void) {
	PORTC.DIRSET = PIN7_bm; // Set PC3 as output
    37d6:	80 e8       	ldi	r24, 0x80	; 128
    37d8:	81 83       	std	Z+1, r24	; 0x01
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    37da:	80 e1       	ldi	r24, 0x10	; 16
    37dc:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
	led_init();
	
	gpio_set_pin_high(LCD_BACKLIGHT_ENABLE_PIN);
	
	/* USART */
	PORTC_OUTSET = PIN3_bm; //PC3 as TX
    37e0:	88 e0       	ldi	r24, 0x08	; 8
    37e2:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
	PORTC_DIRSET = PIN3_bm; //TX pin as output
    37e6:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
	
	PORTC_OUTCLR = PIN2_bm; //PC2 as RX
    37ea:	84 e0       	ldi	r24, 0x04	; 4
    37ec:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
	PORTC_DIRCLR = PIN2_bm; //RX pin as input
    37f0:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x700642>
{
	// Baud rate selection
	// BSEL = (2000000 / (2^0 * 16*9600) -1 = 12.0208... ~ 12 -> BSCALE = 0
	// FBAUD = ( (2000000)/(2^0*16(12+1)) = 9615.384 -> mendekati lah ya
	
	USARTC0_BAUDCTRLB = 0; //memastikan BSCALE = 0
    37f4:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
	USARTC0_BAUDCTRLA = 0x0C; // 12
    37f8:	8c e0       	ldi	r24, 0x0C	; 12
    37fa:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
	
	//USARTC0_BAUDCTRLB = 0; //Just to be sure that BSCALE is 0
	//USARTC0_BAUDCTRLA = 0xCF; // 207
	
	//Disable interrupts, just for safety
	USARTC0_CTRLA = 0;
    37fe:	10 92 a3 08 	sts	0x08A3, r1	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
	//8 data bits, no parity and 1 stop bit
	USARTC0_CTRLC = USART_CHSIZE_8BIT_gc;
    3802:	83 e0       	ldi	r24, 0x03	; 3
    3804:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
	
	//Enable receive and transmit
	USARTC0_CTRLB = USART_TXEN_bm | USART_RXEN_bm;
    3808:	88 e1       	ldi	r24, 0x18	; 24
    380a:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
		.charlength = USART_SERIAL_CHAR_LENGTH,
		.paritytype = USART_SERIAL_PARITY,
		.stopbits = USART_SERIAL_STOP_BIT
	};
	
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    380e:	6d e0       	ldi	r22, 0x0D	; 13
    3810:	70 e2       	ldi	r23, 0x20	; 32
    3812:	80 ea       	ldi	r24, 0xA0	; 160
    3814:	98 e0       	ldi	r25, 0x08	; 8
    3816:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <usart_init_rs232>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    381a:	01 e0       	ldi	r16, 0x01	; 1
    381c:	00 93 21 06 	sts	0x0621, r16	; 0x800621 <__TEXT_REGION_LENGTH__+0x700621>
static void adc_init(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC, &adc_conf);
    3820:	be 01       	movw	r22, r28
    3822:	6f 5f       	subi	r22, 0xFF	; 255
    3824:	7f 4f       	sbci	r23, 0xFF	; 255
    3826:	80 e0       	ldi	r24, 0x00	; 0
    3828:	92 e0       	ldi	r25, 0x02	; 2
    382a:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <adc_read_configuration>
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    382e:	ae 01       	movw	r20, r28
    3830:	48 5f       	subi	r20, 0xF8	; 248
    3832:	5f 4f       	sbci	r21, 0xFF	; 255
    3834:	61 e0       	ldi	r22, 0x01	; 1
    3836:	80 e0       	ldi	r24, 0x00	; 0
    3838:	92 e0       	ldi	r25, 0x02	; 2
    383a:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    383e:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    3840:	8b 81       	ldd	r24, Y+3	; 0x03
    3842:	8f 78       	andi	r24, 0x8F	; 143
    3844:	80 61       	ori	r24, 0x10	; 16
    3846:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3848:	89 2f       	mov	r24, r25
    384a:	81 7e       	andi	r24, 0xE1	; 225
    384c:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    384e:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    3850:	12 e0       	ldi	r17, 0x02	; 2
    3852:	1d 83       	std	Y+5, r17	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3854:	08 87       	std	Y+8, r16	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3856:	80 e4       	ldi	r24, 0x40	; 64
    3858:	89 87       	std	Y+9, r24	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J2_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC, &adc_conf);
    385a:	be 01       	movw	r22, r28
    385c:	6f 5f       	subi	r22, 0xFF	; 255
    385e:	7f 4f       	sbci	r23, 0xFF	; 255
    3860:	80 e0       	ldi	r24, 0x00	; 0
    3862:	92 e0       	ldi	r25, 0x02	; 2
    3864:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <adc_write_configuration>
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    3868:	ae 01       	movw	r20, r28
    386a:	48 5f       	subi	r20, 0xF8	; 248
    386c:	5f 4f       	sbci	r21, 0xFF	; 255
    386e:	61 e0       	ldi	r22, 0x01	; 1
    3870:	80 e0       	ldi	r24, 0x00	; 0
    3872:	92 e0       	ldi	r25, 0x02	; 2
    3874:	0e 94 91 0a 	call	0x1522	; 0x1522 <adcch_write_configuration>
static void pwm_init(void) {
	/* Enable timer/counter (TCC0) for PWM on PORTC0 */
	//tc_enable(&TCC0);
	
	/* Set output */
	PORTC.DIR |= PIN0_bm;
    3878:	f7 01       	movw	r30, r14
    387a:	80 81       	ld	r24, Z
    387c:	81 60       	ori	r24, 0x01	; 1
    387e:	80 83       	st	Z, r24


	/* Set Register */ // belum disesuaikan
	TCC0.CTRLA = PIN1_bm; //(PIN2_bm) | (PIN0_bm);
    3880:	e0 e0       	ldi	r30, 0x00	; 0
    3882:	f8 e0       	ldi	r31, 0x08	; 8
    3884:	10 83       	st	Z, r17
	TCC0.CTRLB = (PIN4_bm) | (PIN2_bm) | (PIN1_bm);
    3886:	86 e1       	ldi	r24, 0x16	; 22
    3888:	81 83       	std	Z+1, r24	; 0x01
	
	/* Set Period */
	TCC0.PER = 3999;
    388a:	8f e9       	ldi	r24, 0x9F	; 159
    388c:	9f e0       	ldi	r25, 0x0F	; 15
    388e:	86 a3       	std	Z+38, r24	; 0x26
    3890:	97 a3       	std	Z+39, r25	; 0x27


	/* Set Compare Register value*/
	TCC0.CCA = 750;
    3892:	8e ee       	ldi	r24, 0xEE	; 238
    3894:	92 e0       	ldi	r25, 0x02	; 2
    3896:	80 a7       	std	Z+40, r24	; 0x28
    3898:	91 a7       	std	Z+41, r25	; 0x29
    389a:	e0 e0       	ldi	r30, 0x00	; 0
    389c:	f6 e0       	ldi	r31, 0x06	; 6
    389e:	11 83       	std	Z+1, r17	; 0x01
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    38a0:	16 83       	std	Z+6, r17	; 0x06
	
	/* Relay */
	relay_init();
	
	/* Create the task */
	xTaskCreate(monitor_current, "", 1000, NULL, tskIDLE_PRIORITY + 1, NULL);	// higher priority
    38a2:	e1 2c       	mov	r14, r1
    38a4:	f1 2c       	mov	r15, r1
    38a6:	20 e0       	ldi	r18, 0x00	; 0
    38a8:	30 e0       	ldi	r19, 0x00	; 0
    38aa:	48 ee       	ldi	r20, 0xE8	; 232
    38ac:	53 e0       	ldi	r21, 0x03	; 3
    38ae:	62 e3       	ldi	r22, 0x32	; 50
    38b0:	70 e2       	ldi	r23, 0x20	; 32
    38b2:	84 e3       	ldi	r24, 0x34	; 52
    38b4:	9b e1       	ldi	r25, 0x1B	; 27
    38b6:	28 d9       	rcall	.-3504   	; 0x2b08 <xTaskCreate>
	/* Semaphore */
	xSemaphore = xSemaphoreCreateBinary();
    38b8:	43 e0       	ldi	r20, 0x03	; 3
    38ba:	60 e0       	ldi	r22, 0x00	; 0
    38bc:	81 e0       	ldi	r24, 0x01	; 1
    38be:	0e 94 96 13 	call	0x272c	; 0x272c <xQueueGenericCreate>
    38c2:	80 93 5c 23 	sts	0x235C, r24	; 0x80235c <xSemaphore>
    38c6:	90 93 5d 23 	sts	0x235D, r25	; 0x80235d <xSemaphore+0x1>
	xSemaphoreGive(xSemaphore);
    38ca:	20 e0       	ldi	r18, 0x00	; 0
    38cc:	40 e0       	ldi	r20, 0x00	; 0
    38ce:	50 e0       	ldi	r21, 0x00	; 0
    38d0:	60 e0       	ldi	r22, 0x00	; 0
    38d2:	70 e0       	ldi	r23, 0x00	; 0
    38d4:	0e 94 b7 13 	call	0x276e	; 0x276e <xQueueGenericSend>
	
	/* Start the task */
	gfx_mono_draw_string("Embedder", 0, 0, &sysfont);
    38d8:	26 e0       	ldi	r18, 0x06	; 6
    38da:	30 e2       	ldi	r19, 0x20	; 32
    38dc:	40 e0       	ldi	r20, 0x00	; 0
    38de:	60 e0       	ldi	r22, 0x00	; 0
    38e0:	83 e3       	ldi	r24, 0x33	; 51
    38e2:	90 e2       	ldi	r25, 0x20	; 32
    38e4:	0e 94 98 06 	call	0xd30	; 0xd30 <gfx_mono_draw_string>
	vTaskStartScheduler();
    38e8:	0e da       	rcall	.-3044   	; 0x2d06 <vTaskStartScheduler>

}
    38ea:	80 e0       	ldi	r24, 0x00	; 0
    38ec:	90 e0       	ldi	r25, 0x00	; 0
    38ee:	2b 96       	adiw	r28, 0x0b	; 11
    38f0:	cd bf       	out	0x3d, r28	; 61
    38f2:	de bf       	out	0x3e, r29	; 62
    38f4:	df 91       	pop	r29
    38f6:	cf 91       	pop	r28
    38f8:	1f 91       	pop	r17
    38fa:	0f 91       	pop	r16
    38fc:	ff 90       	pop	r15
    38fe:	ef 90       	pop	r14
    3900:	08 95       	ret

00003902 <__subsf3>:
    3902:	50 58       	subi	r21, 0x80	; 128

00003904 <__addsf3>:
    3904:	bb 27       	eor	r27, r27
    3906:	aa 27       	eor	r26, r26
    3908:	0e d0       	rcall	.+28     	; 0x3926 <__addsf3x>
    390a:	1c c1       	rjmp	.+568    	; 0x3b44 <__fp_round>
    390c:	0d d1       	rcall	.+538    	; 0x3b28 <__fp_pscA>
    390e:	30 f0       	brcs	.+12     	; 0x391c <__addsf3+0x18>
    3910:	12 d1       	rcall	.+548    	; 0x3b36 <__fp_pscB>
    3912:	20 f0       	brcs	.+8      	; 0x391c <__addsf3+0x18>
    3914:	31 f4       	brne	.+12     	; 0x3922 <__addsf3+0x1e>
    3916:	9f 3f       	cpi	r25, 0xFF	; 255
    3918:	11 f4       	brne	.+4      	; 0x391e <__addsf3+0x1a>
    391a:	1e f4       	brtc	.+6      	; 0x3922 <__addsf3+0x1e>
    391c:	02 c1       	rjmp	.+516    	; 0x3b22 <__fp_nan>
    391e:	0e f4       	brtc	.+2      	; 0x3922 <__addsf3+0x1e>
    3920:	e0 95       	com	r30
    3922:	e7 fb       	bst	r30, 7
    3924:	f8 c0       	rjmp	.+496    	; 0x3b16 <__fp_inf>

00003926 <__addsf3x>:
    3926:	e9 2f       	mov	r30, r25
    3928:	1e d1       	rcall	.+572    	; 0x3b66 <__fp_split3>
    392a:	80 f3       	brcs	.-32     	; 0x390c <__addsf3+0x8>
    392c:	ba 17       	cp	r27, r26
    392e:	62 07       	cpc	r22, r18
    3930:	73 07       	cpc	r23, r19
    3932:	84 07       	cpc	r24, r20
    3934:	95 07       	cpc	r25, r21
    3936:	18 f0       	brcs	.+6      	; 0x393e <__addsf3x+0x18>
    3938:	71 f4       	brne	.+28     	; 0x3956 <__addsf3x+0x30>
    393a:	9e f5       	brtc	.+102    	; 0x39a2 <__addsf3x+0x7c>
    393c:	36 c1       	rjmp	.+620    	; 0x3baa <__fp_zero>
    393e:	0e f4       	brtc	.+2      	; 0x3942 <__addsf3x+0x1c>
    3940:	e0 95       	com	r30
    3942:	0b 2e       	mov	r0, r27
    3944:	ba 2f       	mov	r27, r26
    3946:	a0 2d       	mov	r26, r0
    3948:	0b 01       	movw	r0, r22
    394a:	b9 01       	movw	r22, r18
    394c:	90 01       	movw	r18, r0
    394e:	0c 01       	movw	r0, r24
    3950:	ca 01       	movw	r24, r20
    3952:	a0 01       	movw	r20, r0
    3954:	11 24       	eor	r1, r1
    3956:	ff 27       	eor	r31, r31
    3958:	59 1b       	sub	r21, r25
    395a:	99 f0       	breq	.+38     	; 0x3982 <__addsf3x+0x5c>
    395c:	59 3f       	cpi	r21, 0xF9	; 249
    395e:	50 f4       	brcc	.+20     	; 0x3974 <__addsf3x+0x4e>
    3960:	50 3e       	cpi	r21, 0xE0	; 224
    3962:	68 f1       	brcs	.+90     	; 0x39be <__addsf3x+0x98>
    3964:	1a 16       	cp	r1, r26
    3966:	f0 40       	sbci	r31, 0x00	; 0
    3968:	a2 2f       	mov	r26, r18
    396a:	23 2f       	mov	r18, r19
    396c:	34 2f       	mov	r19, r20
    396e:	44 27       	eor	r20, r20
    3970:	58 5f       	subi	r21, 0xF8	; 248
    3972:	f3 cf       	rjmp	.-26     	; 0x395a <__addsf3x+0x34>
    3974:	46 95       	lsr	r20
    3976:	37 95       	ror	r19
    3978:	27 95       	ror	r18
    397a:	a7 95       	ror	r26
    397c:	f0 40       	sbci	r31, 0x00	; 0
    397e:	53 95       	inc	r21
    3980:	c9 f7       	brne	.-14     	; 0x3974 <__addsf3x+0x4e>
    3982:	7e f4       	brtc	.+30     	; 0x39a2 <__addsf3x+0x7c>
    3984:	1f 16       	cp	r1, r31
    3986:	ba 0b       	sbc	r27, r26
    3988:	62 0b       	sbc	r22, r18
    398a:	73 0b       	sbc	r23, r19
    398c:	84 0b       	sbc	r24, r20
    398e:	ba f0       	brmi	.+46     	; 0x39be <__addsf3x+0x98>
    3990:	91 50       	subi	r25, 0x01	; 1
    3992:	a1 f0       	breq	.+40     	; 0x39bc <__addsf3x+0x96>
    3994:	ff 0f       	add	r31, r31
    3996:	bb 1f       	adc	r27, r27
    3998:	66 1f       	adc	r22, r22
    399a:	77 1f       	adc	r23, r23
    399c:	88 1f       	adc	r24, r24
    399e:	c2 f7       	brpl	.-16     	; 0x3990 <__addsf3x+0x6a>
    39a0:	0e c0       	rjmp	.+28     	; 0x39be <__addsf3x+0x98>
    39a2:	ba 0f       	add	r27, r26
    39a4:	62 1f       	adc	r22, r18
    39a6:	73 1f       	adc	r23, r19
    39a8:	84 1f       	adc	r24, r20
    39aa:	48 f4       	brcc	.+18     	; 0x39be <__addsf3x+0x98>
    39ac:	87 95       	ror	r24
    39ae:	77 95       	ror	r23
    39b0:	67 95       	ror	r22
    39b2:	b7 95       	ror	r27
    39b4:	f7 95       	ror	r31
    39b6:	9e 3f       	cpi	r25, 0xFE	; 254
    39b8:	08 f0       	brcs	.+2      	; 0x39bc <__addsf3x+0x96>
    39ba:	b3 cf       	rjmp	.-154    	; 0x3922 <__addsf3+0x1e>
    39bc:	93 95       	inc	r25
    39be:	88 0f       	add	r24, r24
    39c0:	08 f0       	brcs	.+2      	; 0x39c4 <__addsf3x+0x9e>
    39c2:	99 27       	eor	r25, r25
    39c4:	ee 0f       	add	r30, r30
    39c6:	97 95       	ror	r25
    39c8:	87 95       	ror	r24
    39ca:	08 95       	ret

000039cc <__divsf3>:
    39cc:	0c d0       	rcall	.+24     	; 0x39e6 <__divsf3x>
    39ce:	ba c0       	rjmp	.+372    	; 0x3b44 <__fp_round>
    39d0:	b2 d0       	rcall	.+356    	; 0x3b36 <__fp_pscB>
    39d2:	40 f0       	brcs	.+16     	; 0x39e4 <__divsf3+0x18>
    39d4:	a9 d0       	rcall	.+338    	; 0x3b28 <__fp_pscA>
    39d6:	30 f0       	brcs	.+12     	; 0x39e4 <__divsf3+0x18>
    39d8:	21 f4       	brne	.+8      	; 0x39e2 <__divsf3+0x16>
    39da:	5f 3f       	cpi	r21, 0xFF	; 255
    39dc:	19 f0       	breq	.+6      	; 0x39e4 <__divsf3+0x18>
    39de:	9b c0       	rjmp	.+310    	; 0x3b16 <__fp_inf>
    39e0:	51 11       	cpse	r21, r1
    39e2:	e4 c0       	rjmp	.+456    	; 0x3bac <__fp_szero>
    39e4:	9e c0       	rjmp	.+316    	; 0x3b22 <__fp_nan>

000039e6 <__divsf3x>:
    39e6:	bf d0       	rcall	.+382    	; 0x3b66 <__fp_split3>
    39e8:	98 f3       	brcs	.-26     	; 0x39d0 <__divsf3+0x4>

000039ea <__divsf3_pse>:
    39ea:	99 23       	and	r25, r25
    39ec:	c9 f3       	breq	.-14     	; 0x39e0 <__divsf3+0x14>
    39ee:	55 23       	and	r21, r21
    39f0:	b1 f3       	breq	.-20     	; 0x39de <__divsf3+0x12>
    39f2:	95 1b       	sub	r25, r21
    39f4:	55 0b       	sbc	r21, r21
    39f6:	bb 27       	eor	r27, r27
    39f8:	aa 27       	eor	r26, r26
    39fa:	62 17       	cp	r22, r18
    39fc:	73 07       	cpc	r23, r19
    39fe:	84 07       	cpc	r24, r20
    3a00:	38 f0       	brcs	.+14     	; 0x3a10 <__divsf3_pse+0x26>
    3a02:	9f 5f       	subi	r25, 0xFF	; 255
    3a04:	5f 4f       	sbci	r21, 0xFF	; 255
    3a06:	22 0f       	add	r18, r18
    3a08:	33 1f       	adc	r19, r19
    3a0a:	44 1f       	adc	r20, r20
    3a0c:	aa 1f       	adc	r26, r26
    3a0e:	a9 f3       	breq	.-22     	; 0x39fa <__divsf3_pse+0x10>
    3a10:	33 d0       	rcall	.+102    	; 0x3a78 <__divsf3_pse+0x8e>
    3a12:	0e 2e       	mov	r0, r30
    3a14:	3a f0       	brmi	.+14     	; 0x3a24 <__divsf3_pse+0x3a>
    3a16:	e0 e8       	ldi	r30, 0x80	; 128
    3a18:	30 d0       	rcall	.+96     	; 0x3a7a <__divsf3_pse+0x90>
    3a1a:	91 50       	subi	r25, 0x01	; 1
    3a1c:	50 40       	sbci	r21, 0x00	; 0
    3a1e:	e6 95       	lsr	r30
    3a20:	00 1c       	adc	r0, r0
    3a22:	ca f7       	brpl	.-14     	; 0x3a16 <__divsf3_pse+0x2c>
    3a24:	29 d0       	rcall	.+82     	; 0x3a78 <__divsf3_pse+0x8e>
    3a26:	fe 2f       	mov	r31, r30
    3a28:	27 d0       	rcall	.+78     	; 0x3a78 <__divsf3_pse+0x8e>
    3a2a:	66 0f       	add	r22, r22
    3a2c:	77 1f       	adc	r23, r23
    3a2e:	88 1f       	adc	r24, r24
    3a30:	bb 1f       	adc	r27, r27
    3a32:	26 17       	cp	r18, r22
    3a34:	37 07       	cpc	r19, r23
    3a36:	48 07       	cpc	r20, r24
    3a38:	ab 07       	cpc	r26, r27
    3a3a:	b0 e8       	ldi	r27, 0x80	; 128
    3a3c:	09 f0       	breq	.+2      	; 0x3a40 <__divsf3_pse+0x56>
    3a3e:	bb 0b       	sbc	r27, r27
    3a40:	80 2d       	mov	r24, r0
    3a42:	bf 01       	movw	r22, r30
    3a44:	ff 27       	eor	r31, r31
    3a46:	93 58       	subi	r25, 0x83	; 131
    3a48:	5f 4f       	sbci	r21, 0xFF	; 255
    3a4a:	2a f0       	brmi	.+10     	; 0x3a56 <__divsf3_pse+0x6c>
    3a4c:	9e 3f       	cpi	r25, 0xFE	; 254
    3a4e:	51 05       	cpc	r21, r1
    3a50:	68 f0       	brcs	.+26     	; 0x3a6c <__divsf3_pse+0x82>
    3a52:	61 c0       	rjmp	.+194    	; 0x3b16 <__fp_inf>
    3a54:	ab c0       	rjmp	.+342    	; 0x3bac <__fp_szero>
    3a56:	5f 3f       	cpi	r21, 0xFF	; 255
    3a58:	ec f3       	brlt	.-6      	; 0x3a54 <__divsf3_pse+0x6a>
    3a5a:	98 3e       	cpi	r25, 0xE8	; 232
    3a5c:	dc f3       	brlt	.-10     	; 0x3a54 <__divsf3_pse+0x6a>
    3a5e:	86 95       	lsr	r24
    3a60:	77 95       	ror	r23
    3a62:	67 95       	ror	r22
    3a64:	b7 95       	ror	r27
    3a66:	f7 95       	ror	r31
    3a68:	9f 5f       	subi	r25, 0xFF	; 255
    3a6a:	c9 f7       	brne	.-14     	; 0x3a5e <__divsf3_pse+0x74>
    3a6c:	88 0f       	add	r24, r24
    3a6e:	91 1d       	adc	r25, r1
    3a70:	96 95       	lsr	r25
    3a72:	87 95       	ror	r24
    3a74:	97 f9       	bld	r25, 7
    3a76:	08 95       	ret
    3a78:	e1 e0       	ldi	r30, 0x01	; 1
    3a7a:	66 0f       	add	r22, r22
    3a7c:	77 1f       	adc	r23, r23
    3a7e:	88 1f       	adc	r24, r24
    3a80:	bb 1f       	adc	r27, r27
    3a82:	62 17       	cp	r22, r18
    3a84:	73 07       	cpc	r23, r19
    3a86:	84 07       	cpc	r24, r20
    3a88:	ba 07       	cpc	r27, r26
    3a8a:	20 f0       	brcs	.+8      	; 0x3a94 <__divsf3_pse+0xaa>
    3a8c:	62 1b       	sub	r22, r18
    3a8e:	73 0b       	sbc	r23, r19
    3a90:	84 0b       	sbc	r24, r20
    3a92:	ba 0b       	sbc	r27, r26
    3a94:	ee 1f       	adc	r30, r30
    3a96:	88 f7       	brcc	.-30     	; 0x3a7a <__divsf3_pse+0x90>
    3a98:	e0 95       	com	r30
    3a9a:	08 95       	ret

00003a9c <__floatunsisf>:
    3a9c:	e8 94       	clt
    3a9e:	09 c0       	rjmp	.+18     	; 0x3ab2 <__floatsisf+0x12>

00003aa0 <__floatsisf>:
    3aa0:	97 fb       	bst	r25, 7
    3aa2:	3e f4       	brtc	.+14     	; 0x3ab2 <__floatsisf+0x12>
    3aa4:	90 95       	com	r25
    3aa6:	80 95       	com	r24
    3aa8:	70 95       	com	r23
    3aaa:	61 95       	neg	r22
    3aac:	7f 4f       	sbci	r23, 0xFF	; 255
    3aae:	8f 4f       	sbci	r24, 0xFF	; 255
    3ab0:	9f 4f       	sbci	r25, 0xFF	; 255
    3ab2:	99 23       	and	r25, r25
    3ab4:	a9 f0       	breq	.+42     	; 0x3ae0 <__floatsisf+0x40>
    3ab6:	f9 2f       	mov	r31, r25
    3ab8:	96 e9       	ldi	r25, 0x96	; 150
    3aba:	bb 27       	eor	r27, r27
    3abc:	93 95       	inc	r25
    3abe:	f6 95       	lsr	r31
    3ac0:	87 95       	ror	r24
    3ac2:	77 95       	ror	r23
    3ac4:	67 95       	ror	r22
    3ac6:	b7 95       	ror	r27
    3ac8:	f1 11       	cpse	r31, r1
    3aca:	f8 cf       	rjmp	.-16     	; 0x3abc <__floatsisf+0x1c>
    3acc:	fa f4       	brpl	.+62     	; 0x3b0c <__floatsisf+0x6c>
    3ace:	bb 0f       	add	r27, r27
    3ad0:	11 f4       	brne	.+4      	; 0x3ad6 <__floatsisf+0x36>
    3ad2:	60 ff       	sbrs	r22, 0
    3ad4:	1b c0       	rjmp	.+54     	; 0x3b0c <__floatsisf+0x6c>
    3ad6:	6f 5f       	subi	r22, 0xFF	; 255
    3ad8:	7f 4f       	sbci	r23, 0xFF	; 255
    3ada:	8f 4f       	sbci	r24, 0xFF	; 255
    3adc:	9f 4f       	sbci	r25, 0xFF	; 255
    3ade:	16 c0       	rjmp	.+44     	; 0x3b0c <__floatsisf+0x6c>
    3ae0:	88 23       	and	r24, r24
    3ae2:	11 f0       	breq	.+4      	; 0x3ae8 <__floatsisf+0x48>
    3ae4:	96 e9       	ldi	r25, 0x96	; 150
    3ae6:	11 c0       	rjmp	.+34     	; 0x3b0a <__floatsisf+0x6a>
    3ae8:	77 23       	and	r23, r23
    3aea:	21 f0       	breq	.+8      	; 0x3af4 <__floatsisf+0x54>
    3aec:	9e e8       	ldi	r25, 0x8E	; 142
    3aee:	87 2f       	mov	r24, r23
    3af0:	76 2f       	mov	r23, r22
    3af2:	05 c0       	rjmp	.+10     	; 0x3afe <__floatsisf+0x5e>
    3af4:	66 23       	and	r22, r22
    3af6:	71 f0       	breq	.+28     	; 0x3b14 <__floatsisf+0x74>
    3af8:	96 e8       	ldi	r25, 0x86	; 134
    3afa:	86 2f       	mov	r24, r22
    3afc:	70 e0       	ldi	r23, 0x00	; 0
    3afe:	60 e0       	ldi	r22, 0x00	; 0
    3b00:	2a f0       	brmi	.+10     	; 0x3b0c <__floatsisf+0x6c>
    3b02:	9a 95       	dec	r25
    3b04:	66 0f       	add	r22, r22
    3b06:	77 1f       	adc	r23, r23
    3b08:	88 1f       	adc	r24, r24
    3b0a:	da f7       	brpl	.-10     	; 0x3b02 <__floatsisf+0x62>
    3b0c:	88 0f       	add	r24, r24
    3b0e:	96 95       	lsr	r25
    3b10:	87 95       	ror	r24
    3b12:	97 f9       	bld	r25, 7
    3b14:	08 95       	ret

00003b16 <__fp_inf>:
    3b16:	97 f9       	bld	r25, 7
    3b18:	9f 67       	ori	r25, 0x7F	; 127
    3b1a:	80 e8       	ldi	r24, 0x80	; 128
    3b1c:	70 e0       	ldi	r23, 0x00	; 0
    3b1e:	60 e0       	ldi	r22, 0x00	; 0
    3b20:	08 95       	ret

00003b22 <__fp_nan>:
    3b22:	9f ef       	ldi	r25, 0xFF	; 255
    3b24:	80 ec       	ldi	r24, 0xC0	; 192
    3b26:	08 95       	ret

00003b28 <__fp_pscA>:
    3b28:	00 24       	eor	r0, r0
    3b2a:	0a 94       	dec	r0
    3b2c:	16 16       	cp	r1, r22
    3b2e:	17 06       	cpc	r1, r23
    3b30:	18 06       	cpc	r1, r24
    3b32:	09 06       	cpc	r0, r25
    3b34:	08 95       	ret

00003b36 <__fp_pscB>:
    3b36:	00 24       	eor	r0, r0
    3b38:	0a 94       	dec	r0
    3b3a:	12 16       	cp	r1, r18
    3b3c:	13 06       	cpc	r1, r19
    3b3e:	14 06       	cpc	r1, r20
    3b40:	05 06       	cpc	r0, r21
    3b42:	08 95       	ret

00003b44 <__fp_round>:
    3b44:	09 2e       	mov	r0, r25
    3b46:	03 94       	inc	r0
    3b48:	00 0c       	add	r0, r0
    3b4a:	11 f4       	brne	.+4      	; 0x3b50 <__fp_round+0xc>
    3b4c:	88 23       	and	r24, r24
    3b4e:	52 f0       	brmi	.+20     	; 0x3b64 <__fp_round+0x20>
    3b50:	bb 0f       	add	r27, r27
    3b52:	40 f4       	brcc	.+16     	; 0x3b64 <__fp_round+0x20>
    3b54:	bf 2b       	or	r27, r31
    3b56:	11 f4       	brne	.+4      	; 0x3b5c <__fp_round+0x18>
    3b58:	60 ff       	sbrs	r22, 0
    3b5a:	04 c0       	rjmp	.+8      	; 0x3b64 <__fp_round+0x20>
    3b5c:	6f 5f       	subi	r22, 0xFF	; 255
    3b5e:	7f 4f       	sbci	r23, 0xFF	; 255
    3b60:	8f 4f       	sbci	r24, 0xFF	; 255
    3b62:	9f 4f       	sbci	r25, 0xFF	; 255
    3b64:	08 95       	ret

00003b66 <__fp_split3>:
    3b66:	57 fd       	sbrc	r21, 7
    3b68:	90 58       	subi	r25, 0x80	; 128
    3b6a:	44 0f       	add	r20, r20
    3b6c:	55 1f       	adc	r21, r21
    3b6e:	59 f0       	breq	.+22     	; 0x3b86 <__fp_splitA+0x10>
    3b70:	5f 3f       	cpi	r21, 0xFF	; 255
    3b72:	71 f0       	breq	.+28     	; 0x3b90 <__fp_splitA+0x1a>
    3b74:	47 95       	ror	r20

00003b76 <__fp_splitA>:
    3b76:	88 0f       	add	r24, r24
    3b78:	97 fb       	bst	r25, 7
    3b7a:	99 1f       	adc	r25, r25
    3b7c:	61 f0       	breq	.+24     	; 0x3b96 <__fp_splitA+0x20>
    3b7e:	9f 3f       	cpi	r25, 0xFF	; 255
    3b80:	79 f0       	breq	.+30     	; 0x3ba0 <__fp_splitA+0x2a>
    3b82:	87 95       	ror	r24
    3b84:	08 95       	ret
    3b86:	12 16       	cp	r1, r18
    3b88:	13 06       	cpc	r1, r19
    3b8a:	14 06       	cpc	r1, r20
    3b8c:	55 1f       	adc	r21, r21
    3b8e:	f2 cf       	rjmp	.-28     	; 0x3b74 <__fp_split3+0xe>
    3b90:	46 95       	lsr	r20
    3b92:	f1 df       	rcall	.-30     	; 0x3b76 <__fp_splitA>
    3b94:	08 c0       	rjmp	.+16     	; 0x3ba6 <__fp_splitA+0x30>
    3b96:	16 16       	cp	r1, r22
    3b98:	17 06       	cpc	r1, r23
    3b9a:	18 06       	cpc	r1, r24
    3b9c:	99 1f       	adc	r25, r25
    3b9e:	f1 cf       	rjmp	.-30     	; 0x3b82 <__fp_splitA+0xc>
    3ba0:	86 95       	lsr	r24
    3ba2:	71 05       	cpc	r23, r1
    3ba4:	61 05       	cpc	r22, r1
    3ba6:	08 94       	sec
    3ba8:	08 95       	ret

00003baa <__fp_zero>:
    3baa:	e8 94       	clt

00003bac <__fp_szero>:
    3bac:	bb 27       	eor	r27, r27
    3bae:	66 27       	eor	r22, r22
    3bb0:	77 27       	eor	r23, r23
    3bb2:	cb 01       	movw	r24, r22
    3bb4:	97 f9       	bld	r25, 7
    3bb6:	08 95       	ret

00003bb8 <__gesf2>:
    3bb8:	66 d0       	rcall	.+204    	; 0x3c86 <__fp_cmp>
    3bba:	08 f4       	brcc	.+2      	; 0x3bbe <__gesf2+0x6>
    3bbc:	8f ef       	ldi	r24, 0xFF	; 255
    3bbe:	08 95       	ret

00003bc0 <__mulsf3>:
    3bc0:	0b d0       	rcall	.+22     	; 0x3bd8 <__mulsf3x>
    3bc2:	c0 cf       	rjmp	.-128    	; 0x3b44 <__fp_round>
    3bc4:	b1 df       	rcall	.-158    	; 0x3b28 <__fp_pscA>
    3bc6:	28 f0       	brcs	.+10     	; 0x3bd2 <__mulsf3+0x12>
    3bc8:	b6 df       	rcall	.-148    	; 0x3b36 <__fp_pscB>
    3bca:	18 f0       	brcs	.+6      	; 0x3bd2 <__mulsf3+0x12>
    3bcc:	95 23       	and	r25, r21
    3bce:	09 f0       	breq	.+2      	; 0x3bd2 <__mulsf3+0x12>
    3bd0:	a2 cf       	rjmp	.-188    	; 0x3b16 <__fp_inf>
    3bd2:	a7 cf       	rjmp	.-178    	; 0x3b22 <__fp_nan>
    3bd4:	11 24       	eor	r1, r1
    3bd6:	ea cf       	rjmp	.-44     	; 0x3bac <__fp_szero>

00003bd8 <__mulsf3x>:
    3bd8:	c6 df       	rcall	.-116    	; 0x3b66 <__fp_split3>
    3bda:	a0 f3       	brcs	.-24     	; 0x3bc4 <__mulsf3+0x4>

00003bdc <__mulsf3_pse>:
    3bdc:	95 9f       	mul	r25, r21
    3bde:	d1 f3       	breq	.-12     	; 0x3bd4 <__mulsf3+0x14>
    3be0:	95 0f       	add	r25, r21
    3be2:	50 e0       	ldi	r21, 0x00	; 0
    3be4:	55 1f       	adc	r21, r21
    3be6:	62 9f       	mul	r22, r18
    3be8:	f0 01       	movw	r30, r0
    3bea:	72 9f       	mul	r23, r18
    3bec:	bb 27       	eor	r27, r27
    3bee:	f0 0d       	add	r31, r0
    3bf0:	b1 1d       	adc	r27, r1
    3bf2:	63 9f       	mul	r22, r19
    3bf4:	aa 27       	eor	r26, r26
    3bf6:	f0 0d       	add	r31, r0
    3bf8:	b1 1d       	adc	r27, r1
    3bfa:	aa 1f       	adc	r26, r26
    3bfc:	64 9f       	mul	r22, r20
    3bfe:	66 27       	eor	r22, r22
    3c00:	b0 0d       	add	r27, r0
    3c02:	a1 1d       	adc	r26, r1
    3c04:	66 1f       	adc	r22, r22
    3c06:	82 9f       	mul	r24, r18
    3c08:	22 27       	eor	r18, r18
    3c0a:	b0 0d       	add	r27, r0
    3c0c:	a1 1d       	adc	r26, r1
    3c0e:	62 1f       	adc	r22, r18
    3c10:	73 9f       	mul	r23, r19
    3c12:	b0 0d       	add	r27, r0
    3c14:	a1 1d       	adc	r26, r1
    3c16:	62 1f       	adc	r22, r18
    3c18:	83 9f       	mul	r24, r19
    3c1a:	a0 0d       	add	r26, r0
    3c1c:	61 1d       	adc	r22, r1
    3c1e:	22 1f       	adc	r18, r18
    3c20:	74 9f       	mul	r23, r20
    3c22:	33 27       	eor	r19, r19
    3c24:	a0 0d       	add	r26, r0
    3c26:	61 1d       	adc	r22, r1
    3c28:	23 1f       	adc	r18, r19
    3c2a:	84 9f       	mul	r24, r20
    3c2c:	60 0d       	add	r22, r0
    3c2e:	21 1d       	adc	r18, r1
    3c30:	82 2f       	mov	r24, r18
    3c32:	76 2f       	mov	r23, r22
    3c34:	6a 2f       	mov	r22, r26
    3c36:	11 24       	eor	r1, r1
    3c38:	9f 57       	subi	r25, 0x7F	; 127
    3c3a:	50 40       	sbci	r21, 0x00	; 0
    3c3c:	8a f0       	brmi	.+34     	; 0x3c60 <__mulsf3_pse+0x84>
    3c3e:	e1 f0       	breq	.+56     	; 0x3c78 <__mulsf3_pse+0x9c>
    3c40:	88 23       	and	r24, r24
    3c42:	4a f0       	brmi	.+18     	; 0x3c56 <__mulsf3_pse+0x7a>
    3c44:	ee 0f       	add	r30, r30
    3c46:	ff 1f       	adc	r31, r31
    3c48:	bb 1f       	adc	r27, r27
    3c4a:	66 1f       	adc	r22, r22
    3c4c:	77 1f       	adc	r23, r23
    3c4e:	88 1f       	adc	r24, r24
    3c50:	91 50       	subi	r25, 0x01	; 1
    3c52:	50 40       	sbci	r21, 0x00	; 0
    3c54:	a9 f7       	brne	.-22     	; 0x3c40 <__mulsf3_pse+0x64>
    3c56:	9e 3f       	cpi	r25, 0xFE	; 254
    3c58:	51 05       	cpc	r21, r1
    3c5a:	70 f0       	brcs	.+28     	; 0x3c78 <__mulsf3_pse+0x9c>
    3c5c:	5c cf       	rjmp	.-328    	; 0x3b16 <__fp_inf>
    3c5e:	a6 cf       	rjmp	.-180    	; 0x3bac <__fp_szero>
    3c60:	5f 3f       	cpi	r21, 0xFF	; 255
    3c62:	ec f3       	brlt	.-6      	; 0x3c5e <__mulsf3_pse+0x82>
    3c64:	98 3e       	cpi	r25, 0xE8	; 232
    3c66:	dc f3       	brlt	.-10     	; 0x3c5e <__mulsf3_pse+0x82>
    3c68:	86 95       	lsr	r24
    3c6a:	77 95       	ror	r23
    3c6c:	67 95       	ror	r22
    3c6e:	b7 95       	ror	r27
    3c70:	f7 95       	ror	r31
    3c72:	e7 95       	ror	r30
    3c74:	9f 5f       	subi	r25, 0xFF	; 255
    3c76:	c1 f7       	brne	.-16     	; 0x3c68 <__mulsf3_pse+0x8c>
    3c78:	fe 2b       	or	r31, r30
    3c7a:	88 0f       	add	r24, r24
    3c7c:	91 1d       	adc	r25, r1
    3c7e:	96 95       	lsr	r25
    3c80:	87 95       	ror	r24
    3c82:	97 f9       	bld	r25, 7
    3c84:	08 95       	ret

00003c86 <__fp_cmp>:
    3c86:	99 0f       	add	r25, r25
    3c88:	00 08       	sbc	r0, r0
    3c8a:	55 0f       	add	r21, r21
    3c8c:	aa 0b       	sbc	r26, r26
    3c8e:	e0 e8       	ldi	r30, 0x80	; 128
    3c90:	fe ef       	ldi	r31, 0xFE	; 254
    3c92:	16 16       	cp	r1, r22
    3c94:	17 06       	cpc	r1, r23
    3c96:	e8 07       	cpc	r30, r24
    3c98:	f9 07       	cpc	r31, r25
    3c9a:	c0 f0       	brcs	.+48     	; 0x3ccc <__fp_cmp+0x46>
    3c9c:	12 16       	cp	r1, r18
    3c9e:	13 06       	cpc	r1, r19
    3ca0:	e4 07       	cpc	r30, r20
    3ca2:	f5 07       	cpc	r31, r21
    3ca4:	98 f0       	brcs	.+38     	; 0x3ccc <__fp_cmp+0x46>
    3ca6:	62 1b       	sub	r22, r18
    3ca8:	73 0b       	sbc	r23, r19
    3caa:	84 0b       	sbc	r24, r20
    3cac:	95 0b       	sbc	r25, r21
    3cae:	39 f4       	brne	.+14     	; 0x3cbe <__fp_cmp+0x38>
    3cb0:	0a 26       	eor	r0, r26
    3cb2:	61 f0       	breq	.+24     	; 0x3ccc <__fp_cmp+0x46>
    3cb4:	23 2b       	or	r18, r19
    3cb6:	24 2b       	or	r18, r20
    3cb8:	25 2b       	or	r18, r21
    3cba:	21 f4       	brne	.+8      	; 0x3cc4 <__fp_cmp+0x3e>
    3cbc:	08 95       	ret
    3cbe:	0a 26       	eor	r0, r26
    3cc0:	09 f4       	brne	.+2      	; 0x3cc4 <__fp_cmp+0x3e>
    3cc2:	a1 40       	sbci	r26, 0x01	; 1
    3cc4:	a6 95       	lsr	r26
    3cc6:	8f ef       	ldi	r24, 0xFF	; 255
    3cc8:	81 1d       	adc	r24, r1
    3cca:	81 1d       	adc	r24, r1
    3ccc:	08 95       	ret

00003cce <__udivmodsi4>:
    3cce:	a1 e2       	ldi	r26, 0x21	; 33
    3cd0:	1a 2e       	mov	r1, r26
    3cd2:	aa 1b       	sub	r26, r26
    3cd4:	bb 1b       	sub	r27, r27
    3cd6:	fd 01       	movw	r30, r26
    3cd8:	0d c0       	rjmp	.+26     	; 0x3cf4 <__udivmodsi4_ep>

00003cda <__udivmodsi4_loop>:
    3cda:	aa 1f       	adc	r26, r26
    3cdc:	bb 1f       	adc	r27, r27
    3cde:	ee 1f       	adc	r30, r30
    3ce0:	ff 1f       	adc	r31, r31
    3ce2:	a2 17       	cp	r26, r18
    3ce4:	b3 07       	cpc	r27, r19
    3ce6:	e4 07       	cpc	r30, r20
    3ce8:	f5 07       	cpc	r31, r21
    3cea:	20 f0       	brcs	.+8      	; 0x3cf4 <__udivmodsi4_ep>
    3cec:	a2 1b       	sub	r26, r18
    3cee:	b3 0b       	sbc	r27, r19
    3cf0:	e4 0b       	sbc	r30, r20
    3cf2:	f5 0b       	sbc	r31, r21

00003cf4 <__udivmodsi4_ep>:
    3cf4:	66 1f       	adc	r22, r22
    3cf6:	77 1f       	adc	r23, r23
    3cf8:	88 1f       	adc	r24, r24
    3cfa:	99 1f       	adc	r25, r25
    3cfc:	1a 94       	dec	r1
    3cfe:	69 f7       	brne	.-38     	; 0x3cda <__udivmodsi4_loop>
    3d00:	60 95       	com	r22
    3d02:	70 95       	com	r23
    3d04:	80 95       	com	r24
    3d06:	90 95       	com	r25
    3d08:	9b 01       	movw	r18, r22
    3d0a:	ac 01       	movw	r20, r24
    3d0c:	bd 01       	movw	r22, r26
    3d0e:	cf 01       	movw	r24, r30
    3d10:	08 95       	ret

00003d12 <__tablejump2__>:
    3d12:	ee 0f       	add	r30, r30
    3d14:	ff 1f       	adc	r31, r31
    3d16:	88 1f       	adc	r24, r24
    3d18:	8b bf       	out	0x3b, r24	; 59
    3d1a:	07 90       	elpm	r0, Z+
    3d1c:	f6 91       	elpm	r31, Z
    3d1e:	e0 2d       	mov	r30, r0
    3d20:	19 94       	eijmp

00003d22 <malloc>:
    3d22:	0f 93       	push	r16
    3d24:	1f 93       	push	r17
    3d26:	cf 93       	push	r28
    3d28:	df 93       	push	r29
    3d2a:	82 30       	cpi	r24, 0x02	; 2
    3d2c:	91 05       	cpc	r25, r1
    3d2e:	10 f4       	brcc	.+4      	; 0x3d34 <malloc+0x12>
    3d30:	82 e0       	ldi	r24, 0x02	; 2
    3d32:	90 e0       	ldi	r25, 0x00	; 0
    3d34:	e0 91 60 23 	lds	r30, 0x2360	; 0x802360 <__flp>
    3d38:	f0 91 61 23 	lds	r31, 0x2361	; 0x802361 <__flp+0x1>
    3d3c:	20 e0       	ldi	r18, 0x00	; 0
    3d3e:	30 e0       	ldi	r19, 0x00	; 0
    3d40:	a0 e0       	ldi	r26, 0x00	; 0
    3d42:	b0 e0       	ldi	r27, 0x00	; 0
    3d44:	30 97       	sbiw	r30, 0x00	; 0
    3d46:	19 f1       	breq	.+70     	; 0x3d8e <malloc+0x6c>
    3d48:	40 81       	ld	r20, Z
    3d4a:	51 81       	ldd	r21, Z+1	; 0x01
    3d4c:	02 81       	ldd	r16, Z+2	; 0x02
    3d4e:	13 81       	ldd	r17, Z+3	; 0x03
    3d50:	48 17       	cp	r20, r24
    3d52:	59 07       	cpc	r21, r25
    3d54:	c8 f0       	brcs	.+50     	; 0x3d88 <malloc+0x66>
    3d56:	84 17       	cp	r24, r20
    3d58:	95 07       	cpc	r25, r21
    3d5a:	69 f4       	brne	.+26     	; 0x3d76 <malloc+0x54>
    3d5c:	10 97       	sbiw	r26, 0x00	; 0
    3d5e:	31 f0       	breq	.+12     	; 0x3d6c <malloc+0x4a>
    3d60:	12 96       	adiw	r26, 0x02	; 2
    3d62:	0c 93       	st	X, r16
    3d64:	12 97       	sbiw	r26, 0x02	; 2
    3d66:	13 96       	adiw	r26, 0x03	; 3
    3d68:	1c 93       	st	X, r17
    3d6a:	27 c0       	rjmp	.+78     	; 0x3dba <malloc+0x98>
    3d6c:	00 93 60 23 	sts	0x2360, r16	; 0x802360 <__flp>
    3d70:	10 93 61 23 	sts	0x2361, r17	; 0x802361 <__flp+0x1>
    3d74:	22 c0       	rjmp	.+68     	; 0x3dba <malloc+0x98>
    3d76:	21 15       	cp	r18, r1
    3d78:	31 05       	cpc	r19, r1
    3d7a:	19 f0       	breq	.+6      	; 0x3d82 <malloc+0x60>
    3d7c:	42 17       	cp	r20, r18
    3d7e:	53 07       	cpc	r21, r19
    3d80:	18 f4       	brcc	.+6      	; 0x3d88 <malloc+0x66>
    3d82:	9a 01       	movw	r18, r20
    3d84:	bd 01       	movw	r22, r26
    3d86:	ef 01       	movw	r28, r30
    3d88:	df 01       	movw	r26, r30
    3d8a:	f8 01       	movw	r30, r16
    3d8c:	db cf       	rjmp	.-74     	; 0x3d44 <malloc+0x22>
    3d8e:	21 15       	cp	r18, r1
    3d90:	31 05       	cpc	r19, r1
    3d92:	f9 f0       	breq	.+62     	; 0x3dd2 <malloc+0xb0>
    3d94:	28 1b       	sub	r18, r24
    3d96:	39 0b       	sbc	r19, r25
    3d98:	24 30       	cpi	r18, 0x04	; 4
    3d9a:	31 05       	cpc	r19, r1
    3d9c:	80 f4       	brcc	.+32     	; 0x3dbe <malloc+0x9c>
    3d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    3da0:	9b 81       	ldd	r25, Y+3	; 0x03
    3da2:	61 15       	cp	r22, r1
    3da4:	71 05       	cpc	r23, r1
    3da6:	21 f0       	breq	.+8      	; 0x3db0 <malloc+0x8e>
    3da8:	fb 01       	movw	r30, r22
    3daa:	82 83       	std	Z+2, r24	; 0x02
    3dac:	93 83       	std	Z+3, r25	; 0x03
    3dae:	04 c0       	rjmp	.+8      	; 0x3db8 <malloc+0x96>
    3db0:	80 93 60 23 	sts	0x2360, r24	; 0x802360 <__flp>
    3db4:	90 93 61 23 	sts	0x2361, r25	; 0x802361 <__flp+0x1>
    3db8:	fe 01       	movw	r30, r28
    3dba:	32 96       	adiw	r30, 0x02	; 2
    3dbc:	44 c0       	rjmp	.+136    	; 0x3e46 <malloc+0x124>
    3dbe:	fe 01       	movw	r30, r28
    3dc0:	e2 0f       	add	r30, r18
    3dc2:	f3 1f       	adc	r31, r19
    3dc4:	81 93       	st	Z+, r24
    3dc6:	91 93       	st	Z+, r25
    3dc8:	22 50       	subi	r18, 0x02	; 2
    3dca:	31 09       	sbc	r19, r1
    3dcc:	28 83       	st	Y, r18
    3dce:	39 83       	std	Y+1, r19	; 0x01
    3dd0:	3a c0       	rjmp	.+116    	; 0x3e46 <malloc+0x124>
    3dd2:	20 91 5e 23 	lds	r18, 0x235E	; 0x80235e <__brkval>
    3dd6:	30 91 5f 23 	lds	r19, 0x235F	; 0x80235f <__brkval+0x1>
    3dda:	23 2b       	or	r18, r19
    3ddc:	41 f4       	brne	.+16     	; 0x3dee <malloc+0xcc>
    3dde:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    3de2:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    3de6:	20 93 5e 23 	sts	0x235E, r18	; 0x80235e <__brkval>
    3dea:	30 93 5f 23 	sts	0x235F, r19	; 0x80235f <__brkval+0x1>
    3dee:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    3df2:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    3df6:	21 15       	cp	r18, r1
    3df8:	31 05       	cpc	r19, r1
    3dfa:	41 f4       	brne	.+16     	; 0x3e0c <malloc+0xea>
    3dfc:	2d b7       	in	r18, 0x3d	; 61
    3dfe:	3e b7       	in	r19, 0x3e	; 62
    3e00:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    3e04:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    3e08:	24 1b       	sub	r18, r20
    3e0a:	35 0b       	sbc	r19, r21
    3e0c:	e0 91 5e 23 	lds	r30, 0x235E	; 0x80235e <__brkval>
    3e10:	f0 91 5f 23 	lds	r31, 0x235F	; 0x80235f <__brkval+0x1>
    3e14:	e2 17       	cp	r30, r18
    3e16:	f3 07       	cpc	r31, r19
    3e18:	a0 f4       	brcc	.+40     	; 0x3e42 <malloc+0x120>
    3e1a:	2e 1b       	sub	r18, r30
    3e1c:	3f 0b       	sbc	r19, r31
    3e1e:	28 17       	cp	r18, r24
    3e20:	39 07       	cpc	r19, r25
    3e22:	78 f0       	brcs	.+30     	; 0x3e42 <malloc+0x120>
    3e24:	ac 01       	movw	r20, r24
    3e26:	4e 5f       	subi	r20, 0xFE	; 254
    3e28:	5f 4f       	sbci	r21, 0xFF	; 255
    3e2a:	24 17       	cp	r18, r20
    3e2c:	35 07       	cpc	r19, r21
    3e2e:	48 f0       	brcs	.+18     	; 0x3e42 <malloc+0x120>
    3e30:	4e 0f       	add	r20, r30
    3e32:	5f 1f       	adc	r21, r31
    3e34:	40 93 5e 23 	sts	0x235E, r20	; 0x80235e <__brkval>
    3e38:	50 93 5f 23 	sts	0x235F, r21	; 0x80235f <__brkval+0x1>
    3e3c:	81 93       	st	Z+, r24
    3e3e:	91 93       	st	Z+, r25
    3e40:	02 c0       	rjmp	.+4      	; 0x3e46 <malloc+0x124>
    3e42:	e0 e0       	ldi	r30, 0x00	; 0
    3e44:	f0 e0       	ldi	r31, 0x00	; 0
    3e46:	cf 01       	movw	r24, r30
    3e48:	df 91       	pop	r29
    3e4a:	cf 91       	pop	r28
    3e4c:	1f 91       	pop	r17
    3e4e:	0f 91       	pop	r16
    3e50:	08 95       	ret

00003e52 <free>:
    3e52:	cf 93       	push	r28
    3e54:	df 93       	push	r29
    3e56:	00 97       	sbiw	r24, 0x00	; 0
    3e58:	09 f4       	brne	.+2      	; 0x3e5c <free+0xa>
    3e5a:	81 c0       	rjmp	.+258    	; 0x3f5e <free+0x10c>
    3e5c:	fc 01       	movw	r30, r24
    3e5e:	32 97       	sbiw	r30, 0x02	; 2
    3e60:	12 82       	std	Z+2, r1	; 0x02
    3e62:	13 82       	std	Z+3, r1	; 0x03
    3e64:	a0 91 60 23 	lds	r26, 0x2360	; 0x802360 <__flp>
    3e68:	b0 91 61 23 	lds	r27, 0x2361	; 0x802361 <__flp+0x1>
    3e6c:	10 97       	sbiw	r26, 0x00	; 0
    3e6e:	81 f4       	brne	.+32     	; 0x3e90 <free+0x3e>
    3e70:	20 81       	ld	r18, Z
    3e72:	31 81       	ldd	r19, Z+1	; 0x01
    3e74:	82 0f       	add	r24, r18
    3e76:	93 1f       	adc	r25, r19
    3e78:	20 91 5e 23 	lds	r18, 0x235E	; 0x80235e <__brkval>
    3e7c:	30 91 5f 23 	lds	r19, 0x235F	; 0x80235f <__brkval+0x1>
    3e80:	28 17       	cp	r18, r24
    3e82:	39 07       	cpc	r19, r25
    3e84:	51 f5       	brne	.+84     	; 0x3eda <free+0x88>
    3e86:	e0 93 5e 23 	sts	0x235E, r30	; 0x80235e <__brkval>
    3e8a:	f0 93 5f 23 	sts	0x235F, r31	; 0x80235f <__brkval+0x1>
    3e8e:	67 c0       	rjmp	.+206    	; 0x3f5e <free+0x10c>
    3e90:	ed 01       	movw	r28, r26
    3e92:	20 e0       	ldi	r18, 0x00	; 0
    3e94:	30 e0       	ldi	r19, 0x00	; 0
    3e96:	ce 17       	cp	r28, r30
    3e98:	df 07       	cpc	r29, r31
    3e9a:	40 f4       	brcc	.+16     	; 0x3eac <free+0x5a>
    3e9c:	4a 81       	ldd	r20, Y+2	; 0x02
    3e9e:	5b 81       	ldd	r21, Y+3	; 0x03
    3ea0:	9e 01       	movw	r18, r28
    3ea2:	41 15       	cp	r20, r1
    3ea4:	51 05       	cpc	r21, r1
    3ea6:	f1 f0       	breq	.+60     	; 0x3ee4 <free+0x92>
    3ea8:	ea 01       	movw	r28, r20
    3eaa:	f5 cf       	rjmp	.-22     	; 0x3e96 <free+0x44>
    3eac:	c2 83       	std	Z+2, r28	; 0x02
    3eae:	d3 83       	std	Z+3, r29	; 0x03
    3eb0:	40 81       	ld	r20, Z
    3eb2:	51 81       	ldd	r21, Z+1	; 0x01
    3eb4:	84 0f       	add	r24, r20
    3eb6:	95 1f       	adc	r25, r21
    3eb8:	c8 17       	cp	r28, r24
    3eba:	d9 07       	cpc	r29, r25
    3ebc:	59 f4       	brne	.+22     	; 0x3ed4 <free+0x82>
    3ebe:	88 81       	ld	r24, Y
    3ec0:	99 81       	ldd	r25, Y+1	; 0x01
    3ec2:	84 0f       	add	r24, r20
    3ec4:	95 1f       	adc	r25, r21
    3ec6:	02 96       	adiw	r24, 0x02	; 2
    3ec8:	80 83       	st	Z, r24
    3eca:	91 83       	std	Z+1, r25	; 0x01
    3ecc:	8a 81       	ldd	r24, Y+2	; 0x02
    3ece:	9b 81       	ldd	r25, Y+3	; 0x03
    3ed0:	82 83       	std	Z+2, r24	; 0x02
    3ed2:	93 83       	std	Z+3, r25	; 0x03
    3ed4:	21 15       	cp	r18, r1
    3ed6:	31 05       	cpc	r19, r1
    3ed8:	29 f4       	brne	.+10     	; 0x3ee4 <free+0x92>
    3eda:	e0 93 60 23 	sts	0x2360, r30	; 0x802360 <__flp>
    3ede:	f0 93 61 23 	sts	0x2361, r31	; 0x802361 <__flp+0x1>
    3ee2:	3d c0       	rjmp	.+122    	; 0x3f5e <free+0x10c>
    3ee4:	e9 01       	movw	r28, r18
    3ee6:	ea 83       	std	Y+2, r30	; 0x02
    3ee8:	fb 83       	std	Y+3, r31	; 0x03
    3eea:	49 91       	ld	r20, Y+
    3eec:	59 91       	ld	r21, Y+
    3eee:	c4 0f       	add	r28, r20
    3ef0:	d5 1f       	adc	r29, r21
    3ef2:	ec 17       	cp	r30, r28
    3ef4:	fd 07       	cpc	r31, r29
    3ef6:	61 f4       	brne	.+24     	; 0x3f10 <free+0xbe>
    3ef8:	80 81       	ld	r24, Z
    3efa:	91 81       	ldd	r25, Z+1	; 0x01
    3efc:	84 0f       	add	r24, r20
    3efe:	95 1f       	adc	r25, r21
    3f00:	02 96       	adiw	r24, 0x02	; 2
    3f02:	e9 01       	movw	r28, r18
    3f04:	88 83       	st	Y, r24
    3f06:	99 83       	std	Y+1, r25	; 0x01
    3f08:	82 81       	ldd	r24, Z+2	; 0x02
    3f0a:	93 81       	ldd	r25, Z+3	; 0x03
    3f0c:	8a 83       	std	Y+2, r24	; 0x02
    3f0e:	9b 83       	std	Y+3, r25	; 0x03
    3f10:	e0 e0       	ldi	r30, 0x00	; 0
    3f12:	f0 e0       	ldi	r31, 0x00	; 0
    3f14:	12 96       	adiw	r26, 0x02	; 2
    3f16:	8d 91       	ld	r24, X+
    3f18:	9c 91       	ld	r25, X
    3f1a:	13 97       	sbiw	r26, 0x03	; 3
    3f1c:	00 97       	sbiw	r24, 0x00	; 0
    3f1e:	19 f0       	breq	.+6      	; 0x3f26 <free+0xd4>
    3f20:	fd 01       	movw	r30, r26
    3f22:	dc 01       	movw	r26, r24
    3f24:	f7 cf       	rjmp	.-18     	; 0x3f14 <free+0xc2>
    3f26:	8d 91       	ld	r24, X+
    3f28:	9c 91       	ld	r25, X
    3f2a:	11 97       	sbiw	r26, 0x01	; 1
    3f2c:	9d 01       	movw	r18, r26
    3f2e:	2e 5f       	subi	r18, 0xFE	; 254
    3f30:	3f 4f       	sbci	r19, 0xFF	; 255
    3f32:	82 0f       	add	r24, r18
    3f34:	93 1f       	adc	r25, r19
    3f36:	20 91 5e 23 	lds	r18, 0x235E	; 0x80235e <__brkval>
    3f3a:	30 91 5f 23 	lds	r19, 0x235F	; 0x80235f <__brkval+0x1>
    3f3e:	28 17       	cp	r18, r24
    3f40:	39 07       	cpc	r19, r25
    3f42:	69 f4       	brne	.+26     	; 0x3f5e <free+0x10c>
    3f44:	30 97       	sbiw	r30, 0x00	; 0
    3f46:	29 f4       	brne	.+10     	; 0x3f52 <free+0x100>
    3f48:	10 92 60 23 	sts	0x2360, r1	; 0x802360 <__flp>
    3f4c:	10 92 61 23 	sts	0x2361, r1	; 0x802361 <__flp+0x1>
    3f50:	02 c0       	rjmp	.+4      	; 0x3f56 <free+0x104>
    3f52:	12 82       	std	Z+2, r1	; 0x02
    3f54:	13 82       	std	Z+3, r1	; 0x03
    3f56:	a0 93 5e 23 	sts	0x235E, r26	; 0x80235e <__brkval>
    3f5a:	b0 93 5f 23 	sts	0x235F, r27	; 0x80235f <__brkval+0x1>
    3f5e:	df 91       	pop	r29
    3f60:	cf 91       	pop	r28
    3f62:	08 95       	ret

00003f64 <memcpy>:
    3f64:	fb 01       	movw	r30, r22
    3f66:	dc 01       	movw	r26, r24
    3f68:	02 c0       	rjmp	.+4      	; 0x3f6e <memcpy+0xa>
    3f6a:	01 90       	ld	r0, Z+
    3f6c:	0d 92       	st	X+, r0
    3f6e:	41 50       	subi	r20, 0x01	; 1
    3f70:	50 40       	sbci	r21, 0x00	; 0
    3f72:	d8 f7       	brcc	.-10     	; 0x3f6a <memcpy+0x6>
    3f74:	08 95       	ret

00003f76 <snprintf>:
    3f76:	0f 93       	push	r16
    3f78:	1f 93       	push	r17
    3f7a:	cf 93       	push	r28
    3f7c:	df 93       	push	r29
    3f7e:	cd b7       	in	r28, 0x3d	; 61
    3f80:	de b7       	in	r29, 0x3e	; 62
    3f82:	2e 97       	sbiw	r28, 0x0e	; 14
    3f84:	cd bf       	out	0x3d, r28	; 61
    3f86:	de bf       	out	0x3e, r29	; 62
    3f88:	0e 89       	ldd	r16, Y+22	; 0x16
    3f8a:	1f 89       	ldd	r17, Y+23	; 0x17
    3f8c:	88 8d       	ldd	r24, Y+24	; 0x18
    3f8e:	99 8d       	ldd	r25, Y+25	; 0x19
    3f90:	26 e0       	ldi	r18, 0x06	; 6
    3f92:	2c 83       	std	Y+4, r18	; 0x04
    3f94:	09 83       	std	Y+1, r16	; 0x01
    3f96:	1a 83       	std	Y+2, r17	; 0x02
    3f98:	97 ff       	sbrs	r25, 7
    3f9a:	02 c0       	rjmp	.+4      	; 0x3fa0 <snprintf+0x2a>
    3f9c:	80 e0       	ldi	r24, 0x00	; 0
    3f9e:	90 e8       	ldi	r25, 0x80	; 128
    3fa0:	01 97       	sbiw	r24, 0x01	; 1
    3fa2:	8d 83       	std	Y+5, r24	; 0x05
    3fa4:	9e 83       	std	Y+6, r25	; 0x06
    3fa6:	ae 01       	movw	r20, r28
    3fa8:	44 5e       	subi	r20, 0xE4	; 228
    3faa:	5f 4f       	sbci	r21, 0xFF	; 255
    3fac:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3fae:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3fb0:	ce 01       	movw	r24, r28
    3fb2:	01 96       	adiw	r24, 0x01	; 1
    3fb4:	16 d0       	rcall	.+44     	; 0x3fe2 <vfprintf>
    3fb6:	4d 81       	ldd	r20, Y+5	; 0x05
    3fb8:	5e 81       	ldd	r21, Y+6	; 0x06
    3fba:	57 fd       	sbrc	r21, 7
    3fbc:	0a c0       	rjmp	.+20     	; 0x3fd2 <snprintf+0x5c>
    3fbe:	2f 81       	ldd	r18, Y+7	; 0x07
    3fc0:	38 85       	ldd	r19, Y+8	; 0x08
    3fc2:	42 17       	cp	r20, r18
    3fc4:	53 07       	cpc	r21, r19
    3fc6:	0c f4       	brge	.+2      	; 0x3fca <snprintf+0x54>
    3fc8:	9a 01       	movw	r18, r20
    3fca:	f8 01       	movw	r30, r16
    3fcc:	e2 0f       	add	r30, r18
    3fce:	f3 1f       	adc	r31, r19
    3fd0:	10 82       	st	Z, r1
    3fd2:	2e 96       	adiw	r28, 0x0e	; 14
    3fd4:	cd bf       	out	0x3d, r28	; 61
    3fd6:	de bf       	out	0x3e, r29	; 62
    3fd8:	df 91       	pop	r29
    3fda:	cf 91       	pop	r28
    3fdc:	1f 91       	pop	r17
    3fde:	0f 91       	pop	r16
    3fe0:	08 95       	ret

00003fe2 <vfprintf>:
    3fe2:	2f 92       	push	r2
    3fe4:	3f 92       	push	r3
    3fe6:	4f 92       	push	r4
    3fe8:	5f 92       	push	r5
    3fea:	6f 92       	push	r6
    3fec:	7f 92       	push	r7
    3fee:	8f 92       	push	r8
    3ff0:	9f 92       	push	r9
    3ff2:	af 92       	push	r10
    3ff4:	bf 92       	push	r11
    3ff6:	cf 92       	push	r12
    3ff8:	df 92       	push	r13
    3ffa:	ef 92       	push	r14
    3ffc:	ff 92       	push	r15
    3ffe:	0f 93       	push	r16
    4000:	1f 93       	push	r17
    4002:	cf 93       	push	r28
    4004:	df 93       	push	r29
    4006:	cd b7       	in	r28, 0x3d	; 61
    4008:	de b7       	in	r29, 0x3e	; 62
    400a:	2b 97       	sbiw	r28, 0x0b	; 11
    400c:	cd bf       	out	0x3d, r28	; 61
    400e:	de bf       	out	0x3e, r29	; 62
    4010:	6c 01       	movw	r12, r24
    4012:	7b 01       	movw	r14, r22
    4014:	8a 01       	movw	r16, r20
    4016:	fc 01       	movw	r30, r24
    4018:	16 82       	std	Z+6, r1	; 0x06
    401a:	17 82       	std	Z+7, r1	; 0x07
    401c:	83 81       	ldd	r24, Z+3	; 0x03
    401e:	81 ff       	sbrs	r24, 1
    4020:	bf c1       	rjmp	.+894    	; 0x43a0 <vfprintf+0x3be>
    4022:	ce 01       	movw	r24, r28
    4024:	01 96       	adiw	r24, 0x01	; 1
    4026:	3c 01       	movw	r6, r24
    4028:	f6 01       	movw	r30, r12
    402a:	93 81       	ldd	r25, Z+3	; 0x03
    402c:	f7 01       	movw	r30, r14
    402e:	93 fd       	sbrc	r25, 3
    4030:	85 91       	lpm	r24, Z+
    4032:	93 ff       	sbrs	r25, 3
    4034:	81 91       	ld	r24, Z+
    4036:	7f 01       	movw	r14, r30
    4038:	88 23       	and	r24, r24
    403a:	09 f4       	brne	.+2      	; 0x403e <vfprintf+0x5c>
    403c:	ad c1       	rjmp	.+858    	; 0x4398 <vfprintf+0x3b6>
    403e:	85 32       	cpi	r24, 0x25	; 37
    4040:	39 f4       	brne	.+14     	; 0x4050 <vfprintf+0x6e>
    4042:	93 fd       	sbrc	r25, 3
    4044:	85 91       	lpm	r24, Z+
    4046:	93 ff       	sbrs	r25, 3
    4048:	81 91       	ld	r24, Z+
    404a:	7f 01       	movw	r14, r30
    404c:	85 32       	cpi	r24, 0x25	; 37
    404e:	21 f4       	brne	.+8      	; 0x4058 <vfprintf+0x76>
    4050:	b6 01       	movw	r22, r12
    4052:	90 e0       	ldi	r25, 0x00	; 0
    4054:	d3 d1       	rcall	.+934    	; 0x43fc <fputc>
    4056:	e8 cf       	rjmp	.-48     	; 0x4028 <vfprintf+0x46>
    4058:	91 2c       	mov	r9, r1
    405a:	21 2c       	mov	r2, r1
    405c:	31 2c       	mov	r3, r1
    405e:	ff e1       	ldi	r31, 0x1F	; 31
    4060:	f3 15       	cp	r31, r3
    4062:	d8 f0       	brcs	.+54     	; 0x409a <vfprintf+0xb8>
    4064:	8b 32       	cpi	r24, 0x2B	; 43
    4066:	79 f0       	breq	.+30     	; 0x4086 <vfprintf+0xa4>
    4068:	38 f4       	brcc	.+14     	; 0x4078 <vfprintf+0x96>
    406a:	80 32       	cpi	r24, 0x20	; 32
    406c:	79 f0       	breq	.+30     	; 0x408c <vfprintf+0xaa>
    406e:	83 32       	cpi	r24, 0x23	; 35
    4070:	a1 f4       	brne	.+40     	; 0x409a <vfprintf+0xb8>
    4072:	23 2d       	mov	r18, r3
    4074:	20 61       	ori	r18, 0x10	; 16
    4076:	1d c0       	rjmp	.+58     	; 0x40b2 <vfprintf+0xd0>
    4078:	8d 32       	cpi	r24, 0x2D	; 45
    407a:	61 f0       	breq	.+24     	; 0x4094 <vfprintf+0xb2>
    407c:	80 33       	cpi	r24, 0x30	; 48
    407e:	69 f4       	brne	.+26     	; 0x409a <vfprintf+0xb8>
    4080:	23 2d       	mov	r18, r3
    4082:	21 60       	ori	r18, 0x01	; 1
    4084:	16 c0       	rjmp	.+44     	; 0x40b2 <vfprintf+0xd0>
    4086:	83 2d       	mov	r24, r3
    4088:	82 60       	ori	r24, 0x02	; 2
    408a:	38 2e       	mov	r3, r24
    408c:	e3 2d       	mov	r30, r3
    408e:	e4 60       	ori	r30, 0x04	; 4
    4090:	3e 2e       	mov	r3, r30
    4092:	2a c0       	rjmp	.+84     	; 0x40e8 <vfprintf+0x106>
    4094:	f3 2d       	mov	r31, r3
    4096:	f8 60       	ori	r31, 0x08	; 8
    4098:	1d c0       	rjmp	.+58     	; 0x40d4 <vfprintf+0xf2>
    409a:	37 fc       	sbrc	r3, 7
    409c:	2d c0       	rjmp	.+90     	; 0x40f8 <vfprintf+0x116>
    409e:	20 ed       	ldi	r18, 0xD0	; 208
    40a0:	28 0f       	add	r18, r24
    40a2:	2a 30       	cpi	r18, 0x0A	; 10
    40a4:	40 f0       	brcs	.+16     	; 0x40b6 <vfprintf+0xd4>
    40a6:	8e 32       	cpi	r24, 0x2E	; 46
    40a8:	b9 f4       	brne	.+46     	; 0x40d8 <vfprintf+0xf6>
    40aa:	36 fc       	sbrc	r3, 6
    40ac:	75 c1       	rjmp	.+746    	; 0x4398 <vfprintf+0x3b6>
    40ae:	23 2d       	mov	r18, r3
    40b0:	20 64       	ori	r18, 0x40	; 64
    40b2:	32 2e       	mov	r3, r18
    40b4:	19 c0       	rjmp	.+50     	; 0x40e8 <vfprintf+0x106>
    40b6:	36 fe       	sbrs	r3, 6
    40b8:	06 c0       	rjmp	.+12     	; 0x40c6 <vfprintf+0xe4>
    40ba:	8a e0       	ldi	r24, 0x0A	; 10
    40bc:	98 9e       	mul	r9, r24
    40be:	20 0d       	add	r18, r0
    40c0:	11 24       	eor	r1, r1
    40c2:	92 2e       	mov	r9, r18
    40c4:	11 c0       	rjmp	.+34     	; 0x40e8 <vfprintf+0x106>
    40c6:	ea e0       	ldi	r30, 0x0A	; 10
    40c8:	2e 9e       	mul	r2, r30
    40ca:	20 0d       	add	r18, r0
    40cc:	11 24       	eor	r1, r1
    40ce:	22 2e       	mov	r2, r18
    40d0:	f3 2d       	mov	r31, r3
    40d2:	f0 62       	ori	r31, 0x20	; 32
    40d4:	3f 2e       	mov	r3, r31
    40d6:	08 c0       	rjmp	.+16     	; 0x40e8 <vfprintf+0x106>
    40d8:	8c 36       	cpi	r24, 0x6C	; 108
    40da:	21 f4       	brne	.+8      	; 0x40e4 <vfprintf+0x102>
    40dc:	83 2d       	mov	r24, r3
    40de:	80 68       	ori	r24, 0x80	; 128
    40e0:	38 2e       	mov	r3, r24
    40e2:	02 c0       	rjmp	.+4      	; 0x40e8 <vfprintf+0x106>
    40e4:	88 36       	cpi	r24, 0x68	; 104
    40e6:	41 f4       	brne	.+16     	; 0x40f8 <vfprintf+0x116>
    40e8:	f7 01       	movw	r30, r14
    40ea:	93 fd       	sbrc	r25, 3
    40ec:	85 91       	lpm	r24, Z+
    40ee:	93 ff       	sbrs	r25, 3
    40f0:	81 91       	ld	r24, Z+
    40f2:	7f 01       	movw	r14, r30
    40f4:	81 11       	cpse	r24, r1
    40f6:	b3 cf       	rjmp	.-154    	; 0x405e <vfprintf+0x7c>
    40f8:	98 2f       	mov	r25, r24
    40fa:	9f 7d       	andi	r25, 0xDF	; 223
    40fc:	95 54       	subi	r25, 0x45	; 69
    40fe:	93 30       	cpi	r25, 0x03	; 3
    4100:	28 f4       	brcc	.+10     	; 0x410c <vfprintf+0x12a>
    4102:	0c 5f       	subi	r16, 0xFC	; 252
    4104:	1f 4f       	sbci	r17, 0xFF	; 255
    4106:	9f e3       	ldi	r25, 0x3F	; 63
    4108:	99 83       	std	Y+1, r25	; 0x01
    410a:	0d c0       	rjmp	.+26     	; 0x4126 <vfprintf+0x144>
    410c:	83 36       	cpi	r24, 0x63	; 99
    410e:	31 f0       	breq	.+12     	; 0x411c <vfprintf+0x13a>
    4110:	83 37       	cpi	r24, 0x73	; 115
    4112:	71 f0       	breq	.+28     	; 0x4130 <vfprintf+0x14e>
    4114:	83 35       	cpi	r24, 0x53	; 83
    4116:	09 f0       	breq	.+2      	; 0x411a <vfprintf+0x138>
    4118:	55 c0       	rjmp	.+170    	; 0x41c4 <vfprintf+0x1e2>
    411a:	20 c0       	rjmp	.+64     	; 0x415c <vfprintf+0x17a>
    411c:	f8 01       	movw	r30, r16
    411e:	80 81       	ld	r24, Z
    4120:	89 83       	std	Y+1, r24	; 0x01
    4122:	0e 5f       	subi	r16, 0xFE	; 254
    4124:	1f 4f       	sbci	r17, 0xFF	; 255
    4126:	88 24       	eor	r8, r8
    4128:	83 94       	inc	r8
    412a:	91 2c       	mov	r9, r1
    412c:	53 01       	movw	r10, r6
    412e:	12 c0       	rjmp	.+36     	; 0x4154 <vfprintf+0x172>
    4130:	28 01       	movw	r4, r16
    4132:	f2 e0       	ldi	r31, 0x02	; 2
    4134:	4f 0e       	add	r4, r31
    4136:	51 1c       	adc	r5, r1
    4138:	f8 01       	movw	r30, r16
    413a:	a0 80       	ld	r10, Z
    413c:	b1 80       	ldd	r11, Z+1	; 0x01
    413e:	36 fe       	sbrs	r3, 6
    4140:	03 c0       	rjmp	.+6      	; 0x4148 <vfprintf+0x166>
    4142:	69 2d       	mov	r22, r9
    4144:	70 e0       	ldi	r23, 0x00	; 0
    4146:	02 c0       	rjmp	.+4      	; 0x414c <vfprintf+0x16a>
    4148:	6f ef       	ldi	r22, 0xFF	; 255
    414a:	7f ef       	ldi	r23, 0xFF	; 255
    414c:	c5 01       	movw	r24, r10
    414e:	4b d1       	rcall	.+662    	; 0x43e6 <strnlen>
    4150:	4c 01       	movw	r8, r24
    4152:	82 01       	movw	r16, r4
    4154:	f3 2d       	mov	r31, r3
    4156:	ff 77       	andi	r31, 0x7F	; 127
    4158:	3f 2e       	mov	r3, r31
    415a:	15 c0       	rjmp	.+42     	; 0x4186 <vfprintf+0x1a4>
    415c:	28 01       	movw	r4, r16
    415e:	22 e0       	ldi	r18, 0x02	; 2
    4160:	42 0e       	add	r4, r18
    4162:	51 1c       	adc	r5, r1
    4164:	f8 01       	movw	r30, r16
    4166:	a0 80       	ld	r10, Z
    4168:	b1 80       	ldd	r11, Z+1	; 0x01
    416a:	36 fe       	sbrs	r3, 6
    416c:	03 c0       	rjmp	.+6      	; 0x4174 <vfprintf+0x192>
    416e:	69 2d       	mov	r22, r9
    4170:	70 e0       	ldi	r23, 0x00	; 0
    4172:	02 c0       	rjmp	.+4      	; 0x4178 <vfprintf+0x196>
    4174:	6f ef       	ldi	r22, 0xFF	; 255
    4176:	7f ef       	ldi	r23, 0xFF	; 255
    4178:	c5 01       	movw	r24, r10
    417a:	2a d1       	rcall	.+596    	; 0x43d0 <strnlen_P>
    417c:	4c 01       	movw	r8, r24
    417e:	f3 2d       	mov	r31, r3
    4180:	f0 68       	ori	r31, 0x80	; 128
    4182:	3f 2e       	mov	r3, r31
    4184:	82 01       	movw	r16, r4
    4186:	33 fc       	sbrc	r3, 3
    4188:	19 c0       	rjmp	.+50     	; 0x41bc <vfprintf+0x1da>
    418a:	82 2d       	mov	r24, r2
    418c:	90 e0       	ldi	r25, 0x00	; 0
    418e:	88 16       	cp	r8, r24
    4190:	99 06       	cpc	r9, r25
    4192:	a0 f4       	brcc	.+40     	; 0x41bc <vfprintf+0x1da>
    4194:	b6 01       	movw	r22, r12
    4196:	80 e2       	ldi	r24, 0x20	; 32
    4198:	90 e0       	ldi	r25, 0x00	; 0
    419a:	30 d1       	rcall	.+608    	; 0x43fc <fputc>
    419c:	2a 94       	dec	r2
    419e:	f5 cf       	rjmp	.-22     	; 0x418a <vfprintf+0x1a8>
    41a0:	f5 01       	movw	r30, r10
    41a2:	37 fc       	sbrc	r3, 7
    41a4:	85 91       	lpm	r24, Z+
    41a6:	37 fe       	sbrs	r3, 7
    41a8:	81 91       	ld	r24, Z+
    41aa:	5f 01       	movw	r10, r30
    41ac:	b6 01       	movw	r22, r12
    41ae:	90 e0       	ldi	r25, 0x00	; 0
    41b0:	25 d1       	rcall	.+586    	; 0x43fc <fputc>
    41b2:	21 10       	cpse	r2, r1
    41b4:	2a 94       	dec	r2
    41b6:	21 e0       	ldi	r18, 0x01	; 1
    41b8:	82 1a       	sub	r8, r18
    41ba:	91 08       	sbc	r9, r1
    41bc:	81 14       	cp	r8, r1
    41be:	91 04       	cpc	r9, r1
    41c0:	79 f7       	brne	.-34     	; 0x41a0 <vfprintf+0x1be>
    41c2:	e1 c0       	rjmp	.+450    	; 0x4386 <vfprintf+0x3a4>
    41c4:	84 36       	cpi	r24, 0x64	; 100
    41c6:	11 f0       	breq	.+4      	; 0x41cc <vfprintf+0x1ea>
    41c8:	89 36       	cpi	r24, 0x69	; 105
    41ca:	39 f5       	brne	.+78     	; 0x421a <vfprintf+0x238>
    41cc:	f8 01       	movw	r30, r16
    41ce:	37 fe       	sbrs	r3, 7
    41d0:	07 c0       	rjmp	.+14     	; 0x41e0 <vfprintf+0x1fe>
    41d2:	60 81       	ld	r22, Z
    41d4:	71 81       	ldd	r23, Z+1	; 0x01
    41d6:	82 81       	ldd	r24, Z+2	; 0x02
    41d8:	93 81       	ldd	r25, Z+3	; 0x03
    41da:	0c 5f       	subi	r16, 0xFC	; 252
    41dc:	1f 4f       	sbci	r17, 0xFF	; 255
    41de:	08 c0       	rjmp	.+16     	; 0x41f0 <vfprintf+0x20e>
    41e0:	60 81       	ld	r22, Z
    41e2:	71 81       	ldd	r23, Z+1	; 0x01
    41e4:	07 2e       	mov	r0, r23
    41e6:	00 0c       	add	r0, r0
    41e8:	88 0b       	sbc	r24, r24
    41ea:	99 0b       	sbc	r25, r25
    41ec:	0e 5f       	subi	r16, 0xFE	; 254
    41ee:	1f 4f       	sbci	r17, 0xFF	; 255
    41f0:	f3 2d       	mov	r31, r3
    41f2:	ff 76       	andi	r31, 0x6F	; 111
    41f4:	3f 2e       	mov	r3, r31
    41f6:	97 ff       	sbrs	r25, 7
    41f8:	09 c0       	rjmp	.+18     	; 0x420c <vfprintf+0x22a>
    41fa:	90 95       	com	r25
    41fc:	80 95       	com	r24
    41fe:	70 95       	com	r23
    4200:	61 95       	neg	r22
    4202:	7f 4f       	sbci	r23, 0xFF	; 255
    4204:	8f 4f       	sbci	r24, 0xFF	; 255
    4206:	9f 4f       	sbci	r25, 0xFF	; 255
    4208:	f0 68       	ori	r31, 0x80	; 128
    420a:	3f 2e       	mov	r3, r31
    420c:	2a e0       	ldi	r18, 0x0A	; 10
    420e:	30 e0       	ldi	r19, 0x00	; 0
    4210:	a3 01       	movw	r20, r6
    4212:	30 d1       	rcall	.+608    	; 0x4474 <__ultoa_invert>
    4214:	88 2e       	mov	r8, r24
    4216:	86 18       	sub	r8, r6
    4218:	44 c0       	rjmp	.+136    	; 0x42a2 <vfprintf+0x2c0>
    421a:	85 37       	cpi	r24, 0x75	; 117
    421c:	31 f4       	brne	.+12     	; 0x422a <vfprintf+0x248>
    421e:	23 2d       	mov	r18, r3
    4220:	2f 7e       	andi	r18, 0xEF	; 239
    4222:	b2 2e       	mov	r11, r18
    4224:	2a e0       	ldi	r18, 0x0A	; 10
    4226:	30 e0       	ldi	r19, 0x00	; 0
    4228:	25 c0       	rjmp	.+74     	; 0x4274 <vfprintf+0x292>
    422a:	93 2d       	mov	r25, r3
    422c:	99 7f       	andi	r25, 0xF9	; 249
    422e:	b9 2e       	mov	r11, r25
    4230:	8f 36       	cpi	r24, 0x6F	; 111
    4232:	c1 f0       	breq	.+48     	; 0x4264 <vfprintf+0x282>
    4234:	18 f4       	brcc	.+6      	; 0x423c <vfprintf+0x25a>
    4236:	88 35       	cpi	r24, 0x58	; 88
    4238:	79 f0       	breq	.+30     	; 0x4258 <vfprintf+0x276>
    423a:	ae c0       	rjmp	.+348    	; 0x4398 <vfprintf+0x3b6>
    423c:	80 37       	cpi	r24, 0x70	; 112
    423e:	19 f0       	breq	.+6      	; 0x4246 <vfprintf+0x264>
    4240:	88 37       	cpi	r24, 0x78	; 120
    4242:	21 f0       	breq	.+8      	; 0x424c <vfprintf+0x26a>
    4244:	a9 c0       	rjmp	.+338    	; 0x4398 <vfprintf+0x3b6>
    4246:	e9 2f       	mov	r30, r25
    4248:	e0 61       	ori	r30, 0x10	; 16
    424a:	be 2e       	mov	r11, r30
    424c:	b4 fe       	sbrs	r11, 4
    424e:	0d c0       	rjmp	.+26     	; 0x426a <vfprintf+0x288>
    4250:	fb 2d       	mov	r31, r11
    4252:	f4 60       	ori	r31, 0x04	; 4
    4254:	bf 2e       	mov	r11, r31
    4256:	09 c0       	rjmp	.+18     	; 0x426a <vfprintf+0x288>
    4258:	34 fe       	sbrs	r3, 4
    425a:	0a c0       	rjmp	.+20     	; 0x4270 <vfprintf+0x28e>
    425c:	29 2f       	mov	r18, r25
    425e:	26 60       	ori	r18, 0x06	; 6
    4260:	b2 2e       	mov	r11, r18
    4262:	06 c0       	rjmp	.+12     	; 0x4270 <vfprintf+0x28e>
    4264:	28 e0       	ldi	r18, 0x08	; 8
    4266:	30 e0       	ldi	r19, 0x00	; 0
    4268:	05 c0       	rjmp	.+10     	; 0x4274 <vfprintf+0x292>
    426a:	20 e1       	ldi	r18, 0x10	; 16
    426c:	30 e0       	ldi	r19, 0x00	; 0
    426e:	02 c0       	rjmp	.+4      	; 0x4274 <vfprintf+0x292>
    4270:	20 e1       	ldi	r18, 0x10	; 16
    4272:	32 e0       	ldi	r19, 0x02	; 2
    4274:	f8 01       	movw	r30, r16
    4276:	b7 fe       	sbrs	r11, 7
    4278:	07 c0       	rjmp	.+14     	; 0x4288 <vfprintf+0x2a6>
    427a:	60 81       	ld	r22, Z
    427c:	71 81       	ldd	r23, Z+1	; 0x01
    427e:	82 81       	ldd	r24, Z+2	; 0x02
    4280:	93 81       	ldd	r25, Z+3	; 0x03
    4282:	0c 5f       	subi	r16, 0xFC	; 252
    4284:	1f 4f       	sbci	r17, 0xFF	; 255
    4286:	06 c0       	rjmp	.+12     	; 0x4294 <vfprintf+0x2b2>
    4288:	60 81       	ld	r22, Z
    428a:	71 81       	ldd	r23, Z+1	; 0x01
    428c:	80 e0       	ldi	r24, 0x00	; 0
    428e:	90 e0       	ldi	r25, 0x00	; 0
    4290:	0e 5f       	subi	r16, 0xFE	; 254
    4292:	1f 4f       	sbci	r17, 0xFF	; 255
    4294:	a3 01       	movw	r20, r6
    4296:	ee d0       	rcall	.+476    	; 0x4474 <__ultoa_invert>
    4298:	88 2e       	mov	r8, r24
    429a:	86 18       	sub	r8, r6
    429c:	fb 2d       	mov	r31, r11
    429e:	ff 77       	andi	r31, 0x7F	; 127
    42a0:	3f 2e       	mov	r3, r31
    42a2:	36 fe       	sbrs	r3, 6
    42a4:	0d c0       	rjmp	.+26     	; 0x42c0 <vfprintf+0x2de>
    42a6:	23 2d       	mov	r18, r3
    42a8:	2e 7f       	andi	r18, 0xFE	; 254
    42aa:	a2 2e       	mov	r10, r18
    42ac:	89 14       	cp	r8, r9
    42ae:	58 f4       	brcc	.+22     	; 0x42c6 <vfprintf+0x2e4>
    42b0:	34 fe       	sbrs	r3, 4
    42b2:	0b c0       	rjmp	.+22     	; 0x42ca <vfprintf+0x2e8>
    42b4:	32 fc       	sbrc	r3, 2
    42b6:	09 c0       	rjmp	.+18     	; 0x42ca <vfprintf+0x2e8>
    42b8:	83 2d       	mov	r24, r3
    42ba:	8e 7e       	andi	r24, 0xEE	; 238
    42bc:	a8 2e       	mov	r10, r24
    42be:	05 c0       	rjmp	.+10     	; 0x42ca <vfprintf+0x2e8>
    42c0:	b8 2c       	mov	r11, r8
    42c2:	a3 2c       	mov	r10, r3
    42c4:	03 c0       	rjmp	.+6      	; 0x42cc <vfprintf+0x2ea>
    42c6:	b8 2c       	mov	r11, r8
    42c8:	01 c0       	rjmp	.+2      	; 0x42cc <vfprintf+0x2ea>
    42ca:	b9 2c       	mov	r11, r9
    42cc:	a4 fe       	sbrs	r10, 4
    42ce:	0f c0       	rjmp	.+30     	; 0x42ee <vfprintf+0x30c>
    42d0:	fe 01       	movw	r30, r28
    42d2:	e8 0d       	add	r30, r8
    42d4:	f1 1d       	adc	r31, r1
    42d6:	80 81       	ld	r24, Z
    42d8:	80 33       	cpi	r24, 0x30	; 48
    42da:	21 f4       	brne	.+8      	; 0x42e4 <vfprintf+0x302>
    42dc:	9a 2d       	mov	r25, r10
    42de:	99 7e       	andi	r25, 0xE9	; 233
    42e0:	a9 2e       	mov	r10, r25
    42e2:	09 c0       	rjmp	.+18     	; 0x42f6 <vfprintf+0x314>
    42e4:	a2 fe       	sbrs	r10, 2
    42e6:	06 c0       	rjmp	.+12     	; 0x42f4 <vfprintf+0x312>
    42e8:	b3 94       	inc	r11
    42ea:	b3 94       	inc	r11
    42ec:	04 c0       	rjmp	.+8      	; 0x42f6 <vfprintf+0x314>
    42ee:	8a 2d       	mov	r24, r10
    42f0:	86 78       	andi	r24, 0x86	; 134
    42f2:	09 f0       	breq	.+2      	; 0x42f6 <vfprintf+0x314>
    42f4:	b3 94       	inc	r11
    42f6:	a3 fc       	sbrc	r10, 3
    42f8:	10 c0       	rjmp	.+32     	; 0x431a <vfprintf+0x338>
    42fa:	a0 fe       	sbrs	r10, 0
    42fc:	06 c0       	rjmp	.+12     	; 0x430a <vfprintf+0x328>
    42fe:	b2 14       	cp	r11, r2
    4300:	80 f4       	brcc	.+32     	; 0x4322 <vfprintf+0x340>
    4302:	28 0c       	add	r2, r8
    4304:	92 2c       	mov	r9, r2
    4306:	9b 18       	sub	r9, r11
    4308:	0d c0       	rjmp	.+26     	; 0x4324 <vfprintf+0x342>
    430a:	b2 14       	cp	r11, r2
    430c:	58 f4       	brcc	.+22     	; 0x4324 <vfprintf+0x342>
    430e:	b6 01       	movw	r22, r12
    4310:	80 e2       	ldi	r24, 0x20	; 32
    4312:	90 e0       	ldi	r25, 0x00	; 0
    4314:	73 d0       	rcall	.+230    	; 0x43fc <fputc>
    4316:	b3 94       	inc	r11
    4318:	f8 cf       	rjmp	.-16     	; 0x430a <vfprintf+0x328>
    431a:	b2 14       	cp	r11, r2
    431c:	18 f4       	brcc	.+6      	; 0x4324 <vfprintf+0x342>
    431e:	2b 18       	sub	r2, r11
    4320:	02 c0       	rjmp	.+4      	; 0x4326 <vfprintf+0x344>
    4322:	98 2c       	mov	r9, r8
    4324:	21 2c       	mov	r2, r1
    4326:	a4 fe       	sbrs	r10, 4
    4328:	0f c0       	rjmp	.+30     	; 0x4348 <vfprintf+0x366>
    432a:	b6 01       	movw	r22, r12
    432c:	80 e3       	ldi	r24, 0x30	; 48
    432e:	90 e0       	ldi	r25, 0x00	; 0
    4330:	65 d0       	rcall	.+202    	; 0x43fc <fputc>
    4332:	a2 fe       	sbrs	r10, 2
    4334:	16 c0       	rjmp	.+44     	; 0x4362 <vfprintf+0x380>
    4336:	a1 fc       	sbrc	r10, 1
    4338:	03 c0       	rjmp	.+6      	; 0x4340 <vfprintf+0x35e>
    433a:	88 e7       	ldi	r24, 0x78	; 120
    433c:	90 e0       	ldi	r25, 0x00	; 0
    433e:	02 c0       	rjmp	.+4      	; 0x4344 <vfprintf+0x362>
    4340:	88 e5       	ldi	r24, 0x58	; 88
    4342:	90 e0       	ldi	r25, 0x00	; 0
    4344:	b6 01       	movw	r22, r12
    4346:	0c c0       	rjmp	.+24     	; 0x4360 <vfprintf+0x37e>
    4348:	8a 2d       	mov	r24, r10
    434a:	86 78       	andi	r24, 0x86	; 134
    434c:	51 f0       	breq	.+20     	; 0x4362 <vfprintf+0x380>
    434e:	a1 fe       	sbrs	r10, 1
    4350:	02 c0       	rjmp	.+4      	; 0x4356 <vfprintf+0x374>
    4352:	8b e2       	ldi	r24, 0x2B	; 43
    4354:	01 c0       	rjmp	.+2      	; 0x4358 <vfprintf+0x376>
    4356:	80 e2       	ldi	r24, 0x20	; 32
    4358:	a7 fc       	sbrc	r10, 7
    435a:	8d e2       	ldi	r24, 0x2D	; 45
    435c:	b6 01       	movw	r22, r12
    435e:	90 e0       	ldi	r25, 0x00	; 0
    4360:	4d d0       	rcall	.+154    	; 0x43fc <fputc>
    4362:	89 14       	cp	r8, r9
    4364:	30 f4       	brcc	.+12     	; 0x4372 <vfprintf+0x390>
    4366:	b6 01       	movw	r22, r12
    4368:	80 e3       	ldi	r24, 0x30	; 48
    436a:	90 e0       	ldi	r25, 0x00	; 0
    436c:	47 d0       	rcall	.+142    	; 0x43fc <fputc>
    436e:	9a 94       	dec	r9
    4370:	f8 cf       	rjmp	.-16     	; 0x4362 <vfprintf+0x380>
    4372:	8a 94       	dec	r8
    4374:	f3 01       	movw	r30, r6
    4376:	e8 0d       	add	r30, r8
    4378:	f1 1d       	adc	r31, r1
    437a:	80 81       	ld	r24, Z
    437c:	b6 01       	movw	r22, r12
    437e:	90 e0       	ldi	r25, 0x00	; 0
    4380:	3d d0       	rcall	.+122    	; 0x43fc <fputc>
    4382:	81 10       	cpse	r8, r1
    4384:	f6 cf       	rjmp	.-20     	; 0x4372 <vfprintf+0x390>
    4386:	22 20       	and	r2, r2
    4388:	09 f4       	brne	.+2      	; 0x438c <vfprintf+0x3aa>
    438a:	4e ce       	rjmp	.-868    	; 0x4028 <vfprintf+0x46>
    438c:	b6 01       	movw	r22, r12
    438e:	80 e2       	ldi	r24, 0x20	; 32
    4390:	90 e0       	ldi	r25, 0x00	; 0
    4392:	34 d0       	rcall	.+104    	; 0x43fc <fputc>
    4394:	2a 94       	dec	r2
    4396:	f7 cf       	rjmp	.-18     	; 0x4386 <vfprintf+0x3a4>
    4398:	f6 01       	movw	r30, r12
    439a:	86 81       	ldd	r24, Z+6	; 0x06
    439c:	97 81       	ldd	r25, Z+7	; 0x07
    439e:	02 c0       	rjmp	.+4      	; 0x43a4 <vfprintf+0x3c2>
    43a0:	8f ef       	ldi	r24, 0xFF	; 255
    43a2:	9f ef       	ldi	r25, 0xFF	; 255
    43a4:	2b 96       	adiw	r28, 0x0b	; 11
    43a6:	cd bf       	out	0x3d, r28	; 61
    43a8:	de bf       	out	0x3e, r29	; 62
    43aa:	df 91       	pop	r29
    43ac:	cf 91       	pop	r28
    43ae:	1f 91       	pop	r17
    43b0:	0f 91       	pop	r16
    43b2:	ff 90       	pop	r15
    43b4:	ef 90       	pop	r14
    43b6:	df 90       	pop	r13
    43b8:	cf 90       	pop	r12
    43ba:	bf 90       	pop	r11
    43bc:	af 90       	pop	r10
    43be:	9f 90       	pop	r9
    43c0:	8f 90       	pop	r8
    43c2:	7f 90       	pop	r7
    43c4:	6f 90       	pop	r6
    43c6:	5f 90       	pop	r5
    43c8:	4f 90       	pop	r4
    43ca:	3f 90       	pop	r3
    43cc:	2f 90       	pop	r2
    43ce:	08 95       	ret

000043d0 <strnlen_P>:
    43d0:	fc 01       	movw	r30, r24
    43d2:	05 90       	lpm	r0, Z+
    43d4:	61 50       	subi	r22, 0x01	; 1
    43d6:	70 40       	sbci	r23, 0x00	; 0
    43d8:	01 10       	cpse	r0, r1
    43da:	d8 f7       	brcc	.-10     	; 0x43d2 <strnlen_P+0x2>
    43dc:	80 95       	com	r24
    43de:	90 95       	com	r25
    43e0:	8e 0f       	add	r24, r30
    43e2:	9f 1f       	adc	r25, r31
    43e4:	08 95       	ret

000043e6 <strnlen>:
    43e6:	fc 01       	movw	r30, r24
    43e8:	61 50       	subi	r22, 0x01	; 1
    43ea:	70 40       	sbci	r23, 0x00	; 0
    43ec:	01 90       	ld	r0, Z+
    43ee:	01 10       	cpse	r0, r1
    43f0:	d8 f7       	brcc	.-10     	; 0x43e8 <strnlen+0x2>
    43f2:	80 95       	com	r24
    43f4:	90 95       	com	r25
    43f6:	8e 0f       	add	r24, r30
    43f8:	9f 1f       	adc	r25, r31
    43fa:	08 95       	ret

000043fc <fputc>:
    43fc:	0f 93       	push	r16
    43fe:	1f 93       	push	r17
    4400:	cf 93       	push	r28
    4402:	df 93       	push	r29
    4404:	fb 01       	movw	r30, r22
    4406:	23 81       	ldd	r18, Z+3	; 0x03
    4408:	21 fd       	sbrc	r18, 1
    440a:	03 c0       	rjmp	.+6      	; 0x4412 <fputc+0x16>
    440c:	8f ef       	ldi	r24, 0xFF	; 255
    440e:	9f ef       	ldi	r25, 0xFF	; 255
    4410:	2c c0       	rjmp	.+88     	; 0x446a <fputc+0x6e>
    4412:	22 ff       	sbrs	r18, 2
    4414:	16 c0       	rjmp	.+44     	; 0x4442 <fputc+0x46>
    4416:	46 81       	ldd	r20, Z+6	; 0x06
    4418:	57 81       	ldd	r21, Z+7	; 0x07
    441a:	24 81       	ldd	r18, Z+4	; 0x04
    441c:	35 81       	ldd	r19, Z+5	; 0x05
    441e:	42 17       	cp	r20, r18
    4420:	53 07       	cpc	r21, r19
    4422:	44 f4       	brge	.+16     	; 0x4434 <fputc+0x38>
    4424:	a0 81       	ld	r26, Z
    4426:	b1 81       	ldd	r27, Z+1	; 0x01
    4428:	9d 01       	movw	r18, r26
    442a:	2f 5f       	subi	r18, 0xFF	; 255
    442c:	3f 4f       	sbci	r19, 0xFF	; 255
    442e:	20 83       	st	Z, r18
    4430:	31 83       	std	Z+1, r19	; 0x01
    4432:	8c 93       	st	X, r24
    4434:	26 81       	ldd	r18, Z+6	; 0x06
    4436:	37 81       	ldd	r19, Z+7	; 0x07
    4438:	2f 5f       	subi	r18, 0xFF	; 255
    443a:	3f 4f       	sbci	r19, 0xFF	; 255
    443c:	26 83       	std	Z+6, r18	; 0x06
    443e:	37 83       	std	Z+7, r19	; 0x07
    4440:	14 c0       	rjmp	.+40     	; 0x446a <fputc+0x6e>
    4442:	8b 01       	movw	r16, r22
    4444:	ec 01       	movw	r28, r24
    4446:	fb 01       	movw	r30, r22
    4448:	00 84       	ldd	r0, Z+8	; 0x08
    444a:	f1 85       	ldd	r31, Z+9	; 0x09
    444c:	e0 2d       	mov	r30, r0
    444e:	19 95       	eicall
    4450:	89 2b       	or	r24, r25
    4452:	e1 f6       	brne	.-72     	; 0x440c <fputc+0x10>
    4454:	d8 01       	movw	r26, r16
    4456:	16 96       	adiw	r26, 0x06	; 6
    4458:	8d 91       	ld	r24, X+
    445a:	9c 91       	ld	r25, X
    445c:	17 97       	sbiw	r26, 0x07	; 7
    445e:	01 96       	adiw	r24, 0x01	; 1
    4460:	16 96       	adiw	r26, 0x06	; 6
    4462:	8d 93       	st	X+, r24
    4464:	9c 93       	st	X, r25
    4466:	17 97       	sbiw	r26, 0x07	; 7
    4468:	ce 01       	movw	r24, r28
    446a:	df 91       	pop	r29
    446c:	cf 91       	pop	r28
    446e:	1f 91       	pop	r17
    4470:	0f 91       	pop	r16
    4472:	08 95       	ret

00004474 <__ultoa_invert>:
    4474:	fa 01       	movw	r30, r20
    4476:	aa 27       	eor	r26, r26
    4478:	28 30       	cpi	r18, 0x08	; 8
    447a:	51 f1       	breq	.+84     	; 0x44d0 <__ultoa_invert+0x5c>
    447c:	20 31       	cpi	r18, 0x10	; 16
    447e:	81 f1       	breq	.+96     	; 0x44e0 <__ultoa_invert+0x6c>
    4480:	e8 94       	clt
    4482:	6f 93       	push	r22
    4484:	6e 7f       	andi	r22, 0xFE	; 254
    4486:	6e 5f       	subi	r22, 0xFE	; 254
    4488:	7f 4f       	sbci	r23, 0xFF	; 255
    448a:	8f 4f       	sbci	r24, 0xFF	; 255
    448c:	9f 4f       	sbci	r25, 0xFF	; 255
    448e:	af 4f       	sbci	r26, 0xFF	; 255
    4490:	b1 e0       	ldi	r27, 0x01	; 1
    4492:	3e d0       	rcall	.+124    	; 0x4510 <__ultoa_invert+0x9c>
    4494:	b4 e0       	ldi	r27, 0x04	; 4
    4496:	3c d0       	rcall	.+120    	; 0x4510 <__ultoa_invert+0x9c>
    4498:	67 0f       	add	r22, r23
    449a:	78 1f       	adc	r23, r24
    449c:	89 1f       	adc	r24, r25
    449e:	9a 1f       	adc	r25, r26
    44a0:	a1 1d       	adc	r26, r1
    44a2:	68 0f       	add	r22, r24
    44a4:	79 1f       	adc	r23, r25
    44a6:	8a 1f       	adc	r24, r26
    44a8:	91 1d       	adc	r25, r1
    44aa:	a1 1d       	adc	r26, r1
    44ac:	6a 0f       	add	r22, r26
    44ae:	71 1d       	adc	r23, r1
    44b0:	81 1d       	adc	r24, r1
    44b2:	91 1d       	adc	r25, r1
    44b4:	a1 1d       	adc	r26, r1
    44b6:	20 d0       	rcall	.+64     	; 0x44f8 <__ultoa_invert+0x84>
    44b8:	09 f4       	brne	.+2      	; 0x44bc <__ultoa_invert+0x48>
    44ba:	68 94       	set
    44bc:	3f 91       	pop	r19
    44be:	2a e0       	ldi	r18, 0x0A	; 10
    44c0:	26 9f       	mul	r18, r22
    44c2:	11 24       	eor	r1, r1
    44c4:	30 19       	sub	r19, r0
    44c6:	30 5d       	subi	r19, 0xD0	; 208
    44c8:	31 93       	st	Z+, r19
    44ca:	de f6       	brtc	.-74     	; 0x4482 <__ultoa_invert+0xe>
    44cc:	cf 01       	movw	r24, r30
    44ce:	08 95       	ret
    44d0:	46 2f       	mov	r20, r22
    44d2:	47 70       	andi	r20, 0x07	; 7
    44d4:	40 5d       	subi	r20, 0xD0	; 208
    44d6:	41 93       	st	Z+, r20
    44d8:	b3 e0       	ldi	r27, 0x03	; 3
    44da:	0f d0       	rcall	.+30     	; 0x44fa <__ultoa_invert+0x86>
    44dc:	c9 f7       	brne	.-14     	; 0x44d0 <__ultoa_invert+0x5c>
    44de:	f6 cf       	rjmp	.-20     	; 0x44cc <__ultoa_invert+0x58>
    44e0:	46 2f       	mov	r20, r22
    44e2:	4f 70       	andi	r20, 0x0F	; 15
    44e4:	40 5d       	subi	r20, 0xD0	; 208
    44e6:	4a 33       	cpi	r20, 0x3A	; 58
    44e8:	18 f0       	brcs	.+6      	; 0x44f0 <__ultoa_invert+0x7c>
    44ea:	49 5d       	subi	r20, 0xD9	; 217
    44ec:	31 fd       	sbrc	r19, 1
    44ee:	40 52       	subi	r20, 0x20	; 32
    44f0:	41 93       	st	Z+, r20
    44f2:	02 d0       	rcall	.+4      	; 0x44f8 <__ultoa_invert+0x84>
    44f4:	a9 f7       	brne	.-22     	; 0x44e0 <__ultoa_invert+0x6c>
    44f6:	ea cf       	rjmp	.-44     	; 0x44cc <__ultoa_invert+0x58>
    44f8:	b4 e0       	ldi	r27, 0x04	; 4
    44fa:	a6 95       	lsr	r26
    44fc:	97 95       	ror	r25
    44fe:	87 95       	ror	r24
    4500:	77 95       	ror	r23
    4502:	67 95       	ror	r22
    4504:	ba 95       	dec	r27
    4506:	c9 f7       	brne	.-14     	; 0x44fa <__ultoa_invert+0x86>
    4508:	00 97       	sbiw	r24, 0x00	; 0
    450a:	61 05       	cpc	r22, r1
    450c:	71 05       	cpc	r23, r1
    450e:	08 95       	ret
    4510:	9b 01       	movw	r18, r22
    4512:	ac 01       	movw	r20, r24
    4514:	0a 2e       	mov	r0, r26
    4516:	06 94       	lsr	r0
    4518:	57 95       	ror	r21
    451a:	47 95       	ror	r20
    451c:	37 95       	ror	r19
    451e:	27 95       	ror	r18
    4520:	ba 95       	dec	r27
    4522:	c9 f7       	brne	.-14     	; 0x4516 <__ultoa_invert+0xa2>
    4524:	62 0f       	add	r22, r18
    4526:	73 1f       	adc	r23, r19
    4528:	84 1f       	adc	r24, r20
    452a:	95 1f       	adc	r25, r21
    452c:	a0 1d       	adc	r26, r0
    452e:	08 95       	ret

00004530 <_exit>:
    4530:	f8 94       	cli

00004532 <__stop_program>:
    4532:	ff cf       	rjmp	.-2      	; 0x4532 <__stop_program>
